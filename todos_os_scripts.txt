ARQUIVO DE C√ìDIGO CONSOLIDADO
Gerado em: 2025-08-14 11:41:59
Diret√≥rio: /home/mariagoreti/quan_qiu_wu_tai
Conte√∫do de todos os scripts principais reunidos.

================================================================================

================================================================================
üìÅ ESTRUTURA DO PROJETO
================================================================================

üìÅ .
‚îú‚îÄ‚îÄ server
‚îÇ   ‚îú‚îÄ‚îÄ saves
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ mundo_5e946bdf-961d-43dd-8b5b-6284733ef02b.json
‚îÇ   ‚îú‚îÄ‚îÄ aws_loader.py
‚îÇ   ‚îú‚îÄ‚îÄ commander.py
‚îÇ   ‚îú‚îÄ‚îÄ initializer.py
‚îÇ   ‚îú‚îÄ‚îÄ interface.py
‚îÇ   ‚îú‚îÄ‚îÄ main.py
‚îÇ   ‚îú‚îÄ‚îÄ manager.py
‚îÇ   ‚îî‚îÄ‚îÄ serialization.py
‚îú‚îÄ‚îÄ client
‚îÇ   ‚îú‚îÄ‚îÄ main.py
‚îÇ   ‚îî‚îÄ‚îÄ window.py
‚îú‚îÄ‚îÄ shared
‚îÇ   ‚îú‚îÄ‚îÄ civilization.py
‚îÇ   ‚îú‚îÄ‚îÄ geography.py
‚îÇ   ‚îú‚îÄ‚îÄ naming.py
‚îÇ   ‚îú‚îÄ‚îÄ planet.py
‚îÇ   ‚îú‚îÄ‚îÄ polygons.py
‚îÇ   ‚îú‚îÄ‚îÄ province.py
‚îÇ   ‚îú‚îÄ‚îÄ references.py
‚îÇ   ‚îî‚îÄ‚îÄ world.py

================================================================================
üìÑ CONTE√öDO DOS ARQUIVOS
================================================================================

================================================================================
üìÑ server/commander.py
================================================================================
# server/commander.py
import queue
import threading
import time
import uuid
from typing import Callable, Optional

class Comando:
    def __init__(
        self,
        nome: str,
        callback: Callable,
        args=None,
        kwargs=None,
        on_success: Callable = None,
        on_error: Callable = None
    ):
        self.id = str(uuid.uuid4())[:8]
        self.nome = nome
        self.callback = callback
        self.args = args or ()
        self.kwargs = kwargs or {}
        self.on_success = on_success
        self.on_error = on_error
        self.timestamp = time.time()

    def __repr__(self):
        return f"<Comando(id={self.id}, nome='{self.nome}')>"

class ServidorDeComandos:
    def __init__(self):
        self.fila = queue.Queue()
        self.ativo = True
        self.thread = threading.Thread(target=self._loop, daemon=True)

    def iniciar(self):
        self.thread.start()
        print("‚úÖ Servidor de comandos iniciado.")

    def enviar(self, comando: Comando):
        self.fila.put(comando)

    def _loop(self):
        while self.ativo:
            try:
                comando = self.fila.get(timeout=0.2)
                print(f"‚öôÔ∏è Executando [{comando.id}]: {comando.nome}")
                try:
                    resultado = comando.callback(*comando.args, **comando.kwargs)
                    print(f"‚úÖ [{comando.id}] {comando.nome} conclu√≠do.")
                    if comando.on_success:
                        comando.on_success(resultado)
                except Exception as e:
                    print(f"‚ùå [{comando.id}] Erro em '{comando.nome}': {e}")
                    if comando.on_error:
                        comando.on_error(e)
                finally:
                    self.fila.task_done()
            except queue.Empty:
                continue

    def parar(self, timeout: float = 2.0):
        self.ativo = False
        while not self.fila.empty():
            try:
                self.fila.get_nowait()
            except queue.Empty:
                break
        self.thread.join(timeout=timeout)
        if self.thread.is_alive():
            print("‚ö†Ô∏è Thread do servidor de comandos n√£o encerrou a tempo.")
        else:
            print("üõë Servidor de comandos parado.")

================================================================================
üìÑ server/initializer.py
================================================================================
# server/initializer.py
"""
M√≥dulo para inicializar ou reinicializar a infraestrutura AWS:
- Cria/recria a tabela DynamoDB 'GlobalArena' com PK/SK.
- Limpa os dados no S3 nos prefixos usados.
- Garante que o bucket S3 exista.

Pode ser executado como script: python server/inicializador.py
"""

import boto3
from botocore.exceptions import ClientError
from typing import Dict
from server.aws_loader import AWSLoader


class InicializadorAWS:
    def __init__(self, aws_loader: AWSLoader):
        self.aws_loader = aws_loader
        self.dynamodb = self.aws_loader.get_client('dynamodb')
        self.s3 = self.aws_loader.get_client('s3')
        self.bucket_name = "global-arena-tiles"
        self.region = aws_loader.region_name

    def inicializar(self, confirmar: bool = True):
        """
        Inicializa ou reinicializa toda a infraestrutura.
        :param confirmar: Se True, pede confirma√ß√£o antes de apagar dados.
        """
        if confirmar:
            resposta = input(
                "‚ö†Ô∏è  Isso apagar√° todos os mundos e metadados no S3 e DynamoDB.\n"
                "Deseja continuar? (s/N): "
            )
            if resposta.lower() not in ['s', 'sim', 'y', 'yes']:
                print("‚ùå Opera√ß√£o cancelada.")
                return False

        print("üîÑ Inicializando infraestrutura AWS...")

        try:
            # 1. Garantir que o bucket S3 existe
            self._criar_bucket_se_nao_existir()

            # 2. Limpar dados no S3
            prefixos = ["planetas/", "saves/"]
            for prefix in prefixos:
                self._limpar_prefixo_s3(prefix)

            # 3. Recriar tabela DynamoDB (√∫nica: GlobalArena)
            self._recriar_tabela_globalarena()

            print("‚úÖ Infraestrutura AWS reinicializada com sucesso!")
            return True

        except Exception as e:
            print(f"‚ùå Erro ao inicializar infraestrutura: {e}")
            return False

    def _criar_bucket_se_nao_existir(self):
        """Cria o bucket S3 se ele n√£o existir."""
        try:
            self.s3.head_bucket(Bucket=self.bucket_name)
            print(f"‚ÑπÔ∏è  Bucket S3 '{self.bucket_name}' j√° existe.")
        except ClientError:
            print(f"üì¶ Criando bucket S3 '{self.bucket_name}'...")
            try:
                if self.region == "us-east-1":
                    self.s3.create_bucket(Bucket=self.bucket_name)
                else:
                    self.s3.create_bucket(
                        Bucket=self.bucket_name,
                        CreateBucketConfiguration={'LocationConstraint': self.region}
                    )
                print(f"‚úÖ Bucket '{self.bucket_name}' criado com sucesso.")
            except ClientError as e:
                print(f"‚ùå Falha ao criar bucket: {e}")
                raise

    def _limpar_prefixo_s3(self, prefix: str):
        """Remove todos os objetos com o prefixo dado no S3."""
        print(f"üßπ Limpando S3: s3://{self.bucket_name}/{prefix}")
        paginator = self.s3.get_paginator('list_objects_v2')
        apagados = 0

        try:
            pages = paginator.paginate(Bucket=self.bucket_name, Prefix=prefix)
            for page in pages:
                if 'Contents' not in page:
                    continue
                keys = [{'Key': obj['Key']} for obj in page['Contents']]
                if keys:
                    self.s3.delete_objects(Bucket=self.bucket_name, Delete={'Objects': keys})
                    apagados += len(keys)
            print(f"‚úÖ {apagados} objetos apagados no prefixo '{prefix}'.")
        except ClientError as e:
            print(f"‚ùå Erro ao limpar S3 no prefixo '{prefix}': {e}")

    def _recriar_tabela_globalarena(self):
        """Deleta e recria a tabela GlobalArena com PK/SK."""
        table_name = "GlobalArena"
        try:
            print(f"üîç Verificando tabela '{table_name}'...")
            self.dynamodb.describe_table(TableName=table_name)
            print(f"üóëÔ∏è  Tabela '{table_name}' encontrada. Deletando...")
            self.dynamodb.delete_table(TableName=table_name)

            # Aguardar exclus√£o
            waiter = self.dynamodb.get_waiter('table_not_exists')
            waiter.wait(TableName=table_name, WaiterConfig={'Delay': 2, 'MaxAttempts': 30})
            print(f"‚úÖ Tabela '{table_name}' deletada.")
        except ClientError as e:
            if e.response['Error']['Code'] != 'ResourceNotFoundException':
                raise e
            print(f"‚ÑπÔ∏è  Tabela '{table_name}' n√£o existe. Ser√° criada.")

        # Criar tabela com PK/SK
        print(f"üÜï Criando tabela '{table_name}' com PK/SK...")
        try:
            self.dynamodb.create_table(
                TableName=table_name,
                AttributeDefinitions=[
                    {'AttributeName': 'PK', 'AttributeType': 'S'},
                    {'AttributeName': 'SK', 'AttributeType': 'S'}
                ],
                KeySchema=[
                    {'AttributeName': 'PK', 'KeyType': 'HASH'},
                    {'AttributeName': 'SK', 'KeyType': 'RANGE'}
                ],
                BillingMode='PAY_PER_REQUEST'
            )

            # Aguardar ativa√ß√£o
            waiter = self.dynamodb.get_waiter('table_exists')
            waiter.wait(TableName=table_name, WaiterConfig={'Delay': 2, 'MaxAttempts': 30})
            print(f"‚úÖ Tabela '{table_name}' criada e ativa.")
        except ClientError as e:
            print(f"‚ùå Falha ao criar tabela '{table_name}': {e}")
            raise


# ========================== CLI ==========================
if __name__ == "__main__":
    """
    Execu√ß√£o direta do m√≥dulo:
    $ python server/inicializador.py
    """
    print("üîß Inicializador AWS - Reinicializa√ß√£o de Infraestrutura\n")

    # Cria o loader AWS
    try:
        aws_loader = AWSLoader()
        print(f"‚úÖ Conectado √† AWS (regi√£o: {aws_loader.region_name})")
    except Exception as e:
        print(f"‚ùå Falha ao conectar √† AWS: {e}")
        exit(1)

    # Inicializa
    inicializador = InicializadorAWS(aws_loader)
    inicializador.inicializar(confirmar=True)

================================================================================
üìÑ server/aws_loader.py
================================================================================
# aws_loader.py

import boto3
from botocore.exceptions import NoCredentialsError, PartialCredentialsError


class AWSLoader:
    def __init__(self, profile_name=None, region_name='us-east-2'):
        """
        Inicializa o loader de credenciais AWS.

        :param profile_name: Nome do perfil no arquivo ~/.aws/credentials (opcional)
        :param region_name: Regi√£o AWS padr√£o
        """
        self.profile_name = profile_name
        self.region_name = region_name
        self.session = None
        self._create_session()

    def _create_session(self):
        """Cria uma sess√£o boto3 com base no perfil ou nas credenciais padr√£o."""
        try:
            if self.profile_name:
                self.session = boto3.Session(profile_name=self.profile_name, region_name=self.region_name)
            else:
                self.session = boto3.Session(region_name=self.region_name)

            # Testa credenciais
            sts = self.session.client('sts')
            sts.get_caller_identity()
            print("‚úÖ Credenciais AWS carregadas com sucesso.")

        except NoCredentialsError:
            raise Exception("‚ùå Credenciais AWS n√£o encontradas. Configure AWS_ACCESS_KEY_ID e AWS_SECRET_ACCESS_KEY.")
        except PartialCredentialsError:
            raise Exception("‚ùå Credenciais incompletas. Verifique AWS_ACCESS_KEY_ID e AWS_SECRET_ACCESS_KEY.")
        except Exception as e:
            raise Exception(f"‚ùå Erro ao carregar credenciais: {e}")

    def get_credentials(self):
        """
        Retorna as credenciais (access key, secret key, token).
        """
        credentials = self.session.get_credentials()
        frozen_creds = credentials.get_frozen_credentials()
        return {
            'access_key': frozen_creds.access_key,
            'secret_key': frozen_creds.secret_key,
            'token': frozen_creds.token
        }

    def get_client(self, service_name):
        """Retorna um cliente boto3 para o servi√ßo especificado."""
        return self.session.client(service_name)

    def get_resource(self, service_name):
        """Retorna um recurso boto3 (ex: S3 resource)."""
        return self.session.resource(service_name)

    # --- üîß Novos m√©todos adicionados ---
    def get_account_info(self):
        """Retorna informa√ß√µes da conta AWS: ID, ARN, usu√°rio, regi√£o."""
        sts = self.session.client('sts')
        identity = sts.get_caller_identity()
        return {
            'account_id': identity['Account'],
            'user_id': identity['UserId'],
            'arn': identity['Arn'],
            'region': self.region_name
        }

    def list_s3_buckets(self):
        """Lista todos os buckets S3 da conta."""
        s3 = self.get_client('s3')
        response = s3.list_buckets()
        return [bucket['Name'] for bucket in response['Buckets']]

    def list_dynamodb_tables(self):
        """Lista todas as tabelas DynamoDB da conta."""
        dynamodb = self.get_client('dynamodb')
        response = dynamodb.list_tables()
        return response['TableNames']

================================================================================
üìÑ server/manager.py
================================================================================
# server/manager.py
import json
from pathlib import Path
from typing import Optional, Tuple

from server.serialization import Serializador
from server.aws_loader import AWSLoader
from shared.world import Mundo


class Gerenciador:
    """
    Gerencia opera√ß√µes de mundo: cria√ß√£o, serializa√ß√£o, upload S3 e salvamento de metadados no DynamoDB.
    Nada √© salvo localmente.
    """

    def __init__(self, aws_loader: AWSLoader, save_dir: str = "saves"):
        self.aws_loader = aws_loader
        self.save_dir = Path(save_dir)
        self.save_dir.mkdir(exist_ok=True)  # Mantido para compatibilidade futura

    def upload_mundo(self, mundo: Mundo, bucket_name: str = "global-arena-tiles", s3_prefix: str = "planetas/") -> bool:
        """
        Separa os dados do mundo:
        - Dados pesados (geografia, civilizacoes) ‚Üí S3
        - Metadados leves (fator, bioma_inicial, vagas) ‚Üí DynamoDB (GlobalArena)

        :param mundo: Inst√¢ncia de Mundo a ser enviada
        :param bucket_name: Nome do bucket S3
        :param s3_prefix: Prefixo (pasta virtual) no bucket
        :return: True se sucesso, False caso contr√°rio
        """
        try:
            # --- 1. Serializar com Serializador (para garantir compatibilidade) ---
            full_data = Serializador.to_serializable_dict(mundo)

            # Extrair apenas o necess√°rio para o S3
            data_s3 = {
                "id_mundo": full_data["id_mundo"],
                "geografia": full_data["geografia"],
                "civilizacoes": full_data["civilizacoes"]
            }

            # Upload para S3
            s3_key = f"{s3_prefix}{mundo.id_mundo}.json"
            s3_client = self.aws_loader.get_client('s3')
            s3_client.put_object(
                Bucket=bucket_name,
                Key=s3_key,
                Body=json.dumps(data_s3, ensure_ascii=False, indent=2).encode('utf-8'),
                ContentType='application/json'
            )
            print(f"‚úÖ Mundo enviado para S3: s3://{bucket_name}/{s3_key}")

            # --- 2. Salvar metadados no DynamoDB (GlobalArena) ---
            pk = f"PLANET#{mundo.id_mundo}"
            sk = "METADATA"
            bioma_inicial = mundo.planeta.geografia.nodes[mundo.planeta.capitais_players[0]]['bioma']
            vagas = mundo.planeta.numero_de_jogadores

            dynamodb = self.aws_loader.get_client('dynamodb')
            dynamodb.put_item(
                TableName="GlobalArena",
                Item={
                    'PK': {'S': pk},
                    'SK': {'S': sk},
                    'entityType': {'S': 'Planet'},
                    'fator': {'N': str(mundo.planeta.fator)},
                    'bioma_inicial': {'S': bioma_inicial},
                    'vagas': {'N': str(vagas)}  # n√∫mero de vagas (atualiz√°vel)
                }
            )
            print(f"‚úÖ Metadados salvos no DynamoDB: {pk}")

            return True

        except Exception as e:
            print(f"‚ùå Falha ao salvar/upload mundo: {e}")
            return False

    def criar_e_upload_mundo(
        self,
        fator: int,
        bioma: str,
        bucket_name: str = "global-arena-tiles",
        s3_prefix: str = "planetas/"
    ) -> bool:
        """
        Cria um novo mundo com fator e bioma dados, e faz upload direto para S3 + DynamoDB.

        :param fator: N√≠vel de detalhe da grade geogr√°fica (ex: 4)
        :param bioma: Bioma inicial para escolha de capitais (ex: "Meadow")
        :param bucket_name: Nome do bucket S3
        :param s3_prefix: Prefixo (pasta) no bucket
        :return: True se sucesso, False caso contr√°rio
        """
        try:
            print(f"üåç Criando mundo com fator={fator}, bioma='{bioma}'...")
            mundo = Mundo(fator=fator, bioma=bioma)
            print(f"‚úÖ Mundo criado: {mundo.id_mundo}")

            sucesso = self.upload_mundo(mundo, bucket_name=bucket_name, s3_prefix=s3_prefix)

            if sucesso:
                print(f"üéâ Mundo {mundo.id_mundo} enviado com sucesso para a nuvem!")
            else:
                print(f"‚ùå Falha no upload do mundo {mundo.id_mundo}")

            return sucesso

        except Exception as e:
            print(f"‚ùå Erro ao criar e upload mundo: {e}")
            return False

    def criar_e_upload_mundo_com_retorno(
        self,
        fator: int,
        bioma: str,
        bucket_name: str = "global-arena-tiles",
        s3_prefix: str = "planetas/"
    ) -> Tuple[bool, Optional[Mundo]]:
        """
        Cria um novo mundo com fator e bioma dados, faz upload para S3 + DynamoDB,
        e retorna sucesso e a inst√¢ncia do mundo.

        √ötil para opera√ß√µes que precisam do objeto Mundo ap√≥s o upload (ex: salvar localmente).

        :param fator: N√≠vel de detalhe da grade geogr√°fica.
        :param bioma: Bioma inicial para escolha de capitais.
        :param bucket_name: Nome do bucket S3.
        :param s3_prefix: Prefixo (pasta) no bucket.
        :return: (sucesso: bool, mundo: Mundo ou None)
        """
        try:
            print(f"üåç Criando mundo com fator={fator}, bioma='{bioma}'...")
            mundo = Mundo(fator=fator, bioma=bioma)
            print(f"‚úÖ Mundo criado: {mundo.id_mundo}")

            sucesso = self.upload_mundo(mundo, bucket_name=bucket_name, s3_prefix=s3_prefix)

            if sucesso:
                print(f"üéâ Mundo {mundo.id_mundo} enviado com sucesso para a nuvem!")
            else:
                print(f"‚ùå Falha no upload do mundo {mundo.id_mundo}")

            return sucesso, mundo

        except Exception as e:
            print(f"‚ùå Erro ao criar e upload mundo: {e}")
            return False, None

    def criar_mundo(self, fator: int, bioma: str) -> Mundo:
        """Cria e retorna um novo mundo."""
        return Mundo(fator=fator, bioma=bioma)

================================================================================
üìÑ server/serialization.py
================================================================================
# server/serialization.py
import json
import networkx as nx
import numpy as np
from pathlib import Path
from typing import Any, Dict, Optional
from shared.world import Mundo
from shared.references import Referencias


class Serializador:
    """
    Classe respons√°vel por serializar e desserializar o estado completo de um Mundo.
    Converte para dict serializ√°vel em JSON, salva em disco e recarrega.
    """

    @staticmethod
    def _convert(value: Any) -> Any:
        """
        Converte valores n√£o serializ√°veis em tipos compat√≠veis com JSON.
        """
        if isinstance(value, np.integer):
            return int(value)
        if isinstance(value, np.floating):
            return float(value)
        if isinstance(value, np.ndarray):
            return value.tolist()
        if isinstance(value, tuple):
            return list(value)
        if hasattr(value, '__dict__'):
            return {k: Serializador._convert(v) for k, v in value.__dict__.items() if not k.startswith('_')}
        return value

    @classmethod
    def to_serializable_dict(cls, mundo: Mundo) -> Dict[str, Any]:
        """
        Converte um objeto Mundo em um dicion√°rio compat√≠vel com JSON.
        Remove atributos deriv√°veis para reduzir tamanho.
        """
        if not hasattr(mundo, 'planeta') or not hasattr(mundo, 'civs'):
            raise ValueError("Objeto mundo inv√°lido: falta atributos 'planeta' ou 'civs'")

        G = mundo.planeta.geografia.copy()

        # Atributos que podem ser recalculados, ent√£o n√£o precisam ser salvos
        node_attrs_to_remove = {
            'cor_placa', 'cor_bioma', 'letra_grega', 'cust_mob', 'tipo', 'altitude', 'umidade', 'temperatura',
        }
        for node in G.nodes:
            for attr in node_attrs_to_remove:
                G.nodes[node].pop(attr, None)  # Remove silenciosamente

        # Remover arestas (ser√£o recalculadas com custo de mobilidade)
        G.remove_edges_from(list(G.edges))

        # Converter atributos dos n√≥s
        for node in G.nodes:
            attrs = G.nodes[node]
            for key in list(attrs.keys()):
                attrs[key] = cls._convert(attrs[key])

        G_data = nx.node_link_data(G)
        G_data.pop("directed", None)
        G_data.pop("multigraph", None)
        G_data.pop("graph", None)

        # Serializar civiliza√ß√µes
        civilizacoes_data = []
        for civ in mundo.civs:
            civ_data = {
                'nome': civ.nome,
                'cultura': civ.cultura,
                'cor': cls._convert(civ.cor),
                'modalidade_bandeira': civ.modalidade_bandeira,
                'cores_bandeira': cls._convert(civ.cores_bandeira),
                'player': civ.player,
                'provincias': [
                    {
                        'coordenadas': cls._convert(p.coordenadas),
                        'nome': p.nome
                    }
                    for p in civ.provincias
                ]
            }
            civilizacoes_data.append(civ_data)

        return {
            "id_mundo": mundo.id_mundo,
            "fator": mundo.planeta.fator,
            "bioma_inicial": mundo.planeta.bioma_inicial,
            "vagas": mundo.planeta.numero_de_jogadores,
            "geografia": G_data,
            "civilizacoes": civilizacoes_data
        }

    @classmethod
    def from_serializable_dict(cls, data: Dict[str, Any], ref: Optional[Referencias] = None):
        """
        Reconstroi um objeto Mundo a partir de um dicion√°rio.
        Requer uma inst√¢ncia de Referencias para inicializa√ß√£o.
        """
        """
        Ainda a ser implementado
        retorna Mundo
        """

    @classmethod
    def save_to_json(cls, mundo: Mundo, filepath: str) -> bool:
        try:
            data = cls.to_serializable_dict(mundo)
            path = Path(filepath)
            path.parent.mkdir(exist_ok=True, parents=True)
            with open(path, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
            print(f"‚úÖ Mundo salvo em JSON: {filepath}")
            return True
        except Exception as e:
            print(f"‚ùå Falha ao salvar mundo: {e}")
            return False

    @classmethod
    def save_mundo(cls, mundo: Mundo, filepath: str = None) -> str:
        """
        Salva um objeto Mundo em JSON.
        Se filepath n√£o for fornecido, gera um nome autom√°tico em 'saves/'.
        :param mundo: Inst√¢ncia de Mundo
        :param filepath: Caminho opcional para salvar
        :return: Caminho final usado, ou string vazia se falhar
        """
        from pathlib import Path

        if filepath is None:
            # Gera caminho padr√£o: saves/mundo_{id}.json
            saves_dir = Path("saves")
            saves_dir.mkdir(exist_ok=True)
            filepath = saves_dir / f"mundo_{mundo.id_mundo}.json"
        else:
            # Garante que o diret√≥rio pai exista
            path = Path(filepath)
            path.parent.mkdir(exist_ok=True, parents=True)

        sucesso = cls.save_to_json(mundo, filepath)
        return str(filepath) if sucesso else ""

================================================================================
üìÑ server/main.py
================================================================================
# main.py

from aws_loader import AWSLoader  # ou from server.aws_loader import AWSLoader

def main():
    print("üöÄ Iniciando aplica√ß√£o...\n")

    # --- Configura√ß√£o ---
    loader = AWSLoader(
        region_name='us-east-2',
        # profile_name='seu-perfil'  # opcional
    )

    # --- 1. Informa√ß√µes da conta ---
    try:
        account = loader.get_account_info()
        print(f"‚úÖ Logado na conta AWS: {account['account_id']}")
        print(f"üë§ Usu√°rio/Role: {account['arn']}\n")
    except Exception as e:
        print(f"‚ùå Falha ao obter conta: {e}")
        return

    # --- 2. Listar buckets S3 ---
    try:
        buckets = loader.list_s3_buckets()
        print(f"üì¶ Buckets S3 encontrados ({len(buckets)}):")
        for bucket in buckets:
            print(f"  - {bucket}")
    except Exception as e:
        print(f"‚ùå Erro ao listar buckets S3: {e}")

    # --- 3. Listar tabelas DynamoDB ---
    try:
        tables = loader.list_dynamodb_tables()
        print(f"\nüìä Tabelas DynamoDB encontradas ({len(tables)}):")
        for table in tables:
            print(f"  - {table}")
    except Exception as e:
        print(f"‚ùå Erro ao listar tabelas DynamoDB: {e}")

    # --- 4. Exemplo: usar cliente S3 ---
    try:
        s3 = loader.get_client('s3')
        response = s3.list_buckets()
        print(f"\nüåç Conex√£o S3 bem-sucedida. Total de buckets: {len(response['Buckets'])}")
    except Exception as e:
        print(f"‚ùå Falha ao usar cliente S3: {e}")


if __name__ == "__main__":
    main()

================================================================================
üìÑ server/interface.py
================================================================================
# server/interface.py
import sys
from PyQt6.QtWidgets import (
    QApplication, QMainWindow, QTabWidget, QWidget, QVBoxLayout, QPushButton,
    QComboBox, QSpinBox, QMessageBox, QFormLayout, QGroupBox,
    QFileDialog
)
from server.serialization import Serializador
from server.manager import Gerenciador
from server.aws_loader import AWSLoader
from server.initializer import InicializadorAWS


class Interface(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Gerenciador de Servidor - Global Arena")
        self.setGeometry(100, 100, 700, 500)

        # === Inicializa√ß√£o do Gerenciador ===
        try:
            self.aws_loader = AWSLoader()
            self.gerenciador = Gerenciador(self.aws_loader)
            print("‚úÖ Gerenciador inicializado com AWS.")
        except Exception as e:
            QMessageBox.critical(self, "Erro AWS", f"N√£o foi poss√≠vel conectar √† AWS:\n{e}")
            self.gerenciador = None

        # ‚úÖ Armazena o √∫ltimo mundo criado (inicialmente None)
        self.ultimo_mundo = None

        # Configura√ß√£o do sistema de abas
        self.tabs = QTabWidget()
        self.setCentralWidget(self.tabs)

        # Cria√ß√£o das abas
        self.backup_tab = self.create_backup_tab()
        self.config_tab = QWidget()
        self.tabs.addTab(self.backup_tab, "Backup & Cria√ß√£o")
        self.tabs.addTab(self.config_tab, "Configura√ß√µes")

    def create_backup_tab(self):
        """Cria a aba de opera√ß√µes de backup e cria√ß√£o de mundos"""
        tab = QWidget()
        layout = QVBoxLayout()

        # === Grupo: Criar e Upload de Mundo ===
        group_criar = QGroupBox("Criar e Enviar Novo Mundo")
        form_layout = QFormLayout()

        self.spin_fator = QSpinBox()
        self.spin_fator.setMinimum(2)
        self.spin_fator.setMaximum(8)
        self.spin_fator.setValue(4)
        form_layout.addRow("Fator:", self.spin_fator)

        self.combo_bioma = QComboBox()
        biomas = ["Meadow", "Forest", "Savanna", "Desert", "Hills", "Mountains"]
        self.combo_bioma.addItems(biomas)
        self.combo_bioma.setCurrentText("Meadow")
        form_layout.addRow("Bioma Inicial:", self.combo_bioma)

        group_criar.setLayout(form_layout)
        layout.addWidget(group_criar)

        btn_upload = QPushButton("üåç Criar e Enviar Mundo para Nuvem")
        btn_upload.clicked.connect(self.handle_criar_e_upload)
        layout.addWidget(btn_upload)

        layout.addSpacing(20)

        # === Grupo: Salvar Localmente ===
        group_local = QGroupBox("Salvar Estado Localmente")
        layout_local = QVBoxLayout()

        btn_save = QPushButton("üíæ Salvar Estado como JSON (Local)")
        btn_save.clicked.connect(self.handle_save_json)
        layout_local.addWidget(btn_save)

        group_local.setLayout(layout_local)
        layout.addWidget(group_local)

        layout.addSpacing(20)

        # === Bot√£o: Reinicializar Infraestrutura AWS ===
        btn_reiniciar = QPushButton("‚ö†Ô∏è Reinicializar Infraestrutura AWS")
        btn_reiniciar.setStyleSheet("""
            QPushButton {
                background-color: #a83232;
                color: white;
                font-weight: bold;
                border-radius: 6px;
                padding: 8px;
            }
            QPushButton:hover {
                background-color: #c03939;
            }
        """)
        btn_reiniciar.clicked.connect(self.handle_reinicializar_servidor)
        layout.addWidget(btn_reiniciar)
        layout.addSpacing(10)

        layout.addStretch()
        tab.setLayout(layout)
        return tab

    def handle_save_json(self):
        """Cria um mundo com os par√¢metros da UI e salva localmente."""
        if not self.gerenciador:
            QMessageBox.critical(self, "Erro", "Gerenciador n√£o est√° dispon√≠vel.")
            return

        fator = self.spin_fator.value()
        bioma = self.combo_bioma.currentText()

        try:
            # 1. Criar mundo usando o Gerenciador
            mundo = self.gerenciador.criar_mundo(fator, bioma)

            # 2. Escolher caminho com di√°logo
            filepath, _ = QFileDialog.getSaveFileName(
                self,
                "Salvar Mundo como JSON",
                f"saves/mundo_{mundo.id_mundo}.json",
                "JSON Files (*.json)"
            )
            if not filepath:
                return  # Cancelado pelo usu√°rio

            # 3. Salvar usando Serializador.save_mundo (j√° trata diret√≥rios)
            caminho_salvo = Serializador.save_mundo(mundo, filepath)

            if caminho_salvo:
                QMessageBox.information(
                    self,
                    "Sucesso",
                    f"Mundo salvo com sucesso!\nArquivo: {caminho_salvo}",
                    QMessageBox.StandardButton.Ok
                )
            else:
                QMessageBox.critical(
                    self,
                    "Falha",
                    "Erro ao salvar o arquivo JSON.",
                    QMessageBox.StandardButton.Ok
                )

        except Exception as e:
            QMessageBox.critical(
                self,
                "Erro",
                f"Falha ao salvar: {str(e)}",
                QMessageBox.StandardButton.Ok
            )

    def handle_criar_e_upload(self):
        """Manipula a cria√ß√£o e upload de um novo mundo"""
        if not self.gerenciador:
            QMessageBox.critical(self, "Erro", "Gerenciador n√£o est√° dispon√≠vel.")
            return

        fator = self.spin_fator.value()
        bioma = self.combo_bioma.currentText()

        reply = QMessageBox.question(
            self,
            "Confirmar",
            f"Criar e enviar um novo mundo?\nFator: {fator}\nBioma: {bioma}",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
        )
        if reply != QMessageBox.StandardButton.Yes:
            return

        try:
            print(f"üîÑ Criando e enviando mundo com fator={fator}, bioma='{bioma}'...")
            sucesso, mundo = self.gerenciador.criar_e_upload_mundo_com_retorno(fator=fator, bioma=bioma)

            if sucesso:
                self.ultimo_mundo = mundo  # Armazena para poss√≠vel salvamento local
                QMessageBox.information(
                    self,
                    "Sucesso",
                    f"Mundo criado e enviado com sucesso!\nID: {mundo.id_mundo}",
                    QMessageBox.StandardButton.Ok
                )
            else:
                QMessageBox.critical(
                    self,
                    "Falha",
                    "O upload falhou. Veja o log para detalhes.",
                    QMessageBox.StandardButton.Ok
                )

        except Exception as e:
            QMessageBox.critical(
                self,
                "Erro",
                f"Erro ao criar/upload do mundo:\n{str(e)}",
                QMessageBox.StandardButton.Ok
            )
            print(f"‚ùå Erro em handle_criar_e_upload: {e}")

    def handle_reinicializar_servidor(self):
        """
        Abre um di√°logo de confirma√ß√£o e, se confirmado,
        reinicializa a infraestrutura AWS (S3 + DynamoDB).
        """
        reply = QMessageBox.question(
            self,
            "‚ö†Ô∏è Reinicializar Servidor",
            "Isso apagar√° TODOS os mundos e metadados no S3 e DynamoDB.\n"
            "Continuar?",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
        )
        if reply != QMessageBox.StandardButton.Yes:
            return

        try:
            # Reutiliza o aws_loader j√° inicializado (n√£o cria um novo)
            if not hasattr(self, 'aws_loader') or self.aws_loader is None:
                QMessageBox.critical(self, "Erro", "Falha ao acessar AWS Loader.")
                return

            # Cria o inicializador e executa
            inicializador = InicializadorAWS(self.aws_loader)
            sucesso = inicializador.inicializar(confirmar=False)

            if sucesso:
                QMessageBox.information(
                    self,
                    "Sucesso",
                    "Servidor reinicializado com sucesso!\n"
                    "Todas as tabelas e arquivos foram limpos e recriados."
                )
            else:
                QMessageBox.warning(
                    self,
                    "Aten√ß√£o",
                    "A reinicializa√ß√£o foi executada, mas pode ter falhado em algum ponto."
                )
        except ModuleNotFoundError:
            QMessageBox.critical(
                self,
                "Erro",
                "M√≥dulo 'inicializador' n√£o encontrado.\n"
                "Certifique-se de que 'server/inicializador.py' existe."
            )
        except Exception as e:
            QMessageBox.critical(
                self,
                "Erro",
                f"Falha ao reinicializar o servidor:\n{str(e)}"
            )


# Execu√ß√£o da aplica√ß√£o
if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = Interface()
    window.show()
    sys.exit(app.exec())

================================================================================
üìÑ client/window.py
================================================================================
import glfw
from OpenGL.GL import *
import sys


class Janela:
    def __init__(self, width=800, height=600, title="OpenGL Fullscreen"):
        self.width = width
        self.height = height
        self.title = title
        self.window = None

        # Inicializa o GLFW
        if not glfw.init():
            raise Exception("Falha ao inicializar o GLFW")

        # Configura√ß√µes da janela (OpenGL 3.3 Core Profile)
        glfw.window_hint(glfw.CONTEXT_VERSION_MAJOR, 3)
        glfw.window_hint(glfw.CONTEXT_VERSION_MINOR, 3)
        glfw.window_hint(glfw.OPENGL_PROFILE, glfw.OPENGL_CORE_PROFILE)
        glfw.window_hint(glfw.OPENGL_FORWARD_COMPAT, True)  # Necess√°rio no macOS

        # Obter o monitor prim√°rio e modo de v√≠deo
        self.monitor = glfw.get_primary_monitor()
        mode = glfw.get_video_mode(self.monitor)
        self.width = mode.size.width
        self.height = mode.size.height

        # Criar janela em fullscreen
        self.window = glfw.create_window(
            self.width, self.height, self.title, self.monitor, None
        )
        if not self.window:
            glfw.terminate()
            raise Exception("Falha ao criar a janela")

        # Tornar o contexto OpenGL atual
        glfw.make_context_current(self.window)

        # Capturar teclado (para ESC)
        glfw.set_key_callback(self.window, self.key_callback)

        # Habilitar vsync
        glfw.swap_interval(1)

        print(f"Janela em fullscreen: {self.width}x{self.height}")

    def key_callback(self, window, key, scancode, action, mods):
        """Callback para teclas"""
        if key == glfw.KEY_ESCAPE and action == glfw.PRESS:
            glfw.set_window_should_close(window, True)

    def setup_opengl(self):
        """Configura√ß√µes iniciais do OpenGL"""
        glViewport(0, 0, self.width, self.height)
        glClearColor(0.1, 0.1, 0.4, 1.0)  # Fundo azul escuro

    def main_loop(self):
        """Loop principal de renderiza√ß√£o"""
        self.setup_opengl()

        while not glfw.window_should_close(self.window):
            # Processar eventos
            glfw.poll_events()

            # Limpar tela
            glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)

            # Aqui voc√™ pode adicionar sua renderiza√ß√£o (shaders, buffers, etc.)

            # Trocar buffers
            glfw.swap_buffers(self.window)

        self.terminate()

    def terminate(self):
        """Encerra o GLFW"""
        glfw.destroy_window(self.window)
        glfw.terminate()
        print("Aplica√ß√£o encerrada.")

    def run(self):
        """Inicia a aplica√ß√£o"""
        self.main_loop()


# === Execu√ß√£o ===
if __name__ == "__main__":
    app = Janela(title="Minha Janela Fullscreen")
    app.run()
    sys.exit()

================================================================================
üìÑ client/main.py
================================================================================
# client/aws_loader.py

"""
Ponto de entrada do cliente gr√°fico.
Inicializa a janela OpenGL em fullscreen e inicia o loop principal.
"""

import sys
from client.window import Janela


def main():
    """
    Fun√ß√£o principal do cliente.
    Cria a janela e inicia o loop de renderiza√ß√£o.
    """
    print("Inicializando cliente gr√°fico...")

    try:
        # Cria a janela em fullscreen
        app = Janela(title="Cliente OpenGL - Fullscreen")

        # Inicia o loop principal (renderiza√ß√£o + eventos)
        app.run()

        print("Cliente encerrado com sucesso.")
        return 0

    except Exception as e:
        print(f"Erro cr√≠tico no cliente: {e}", file=sys.stderr)
        return 1


if __name__ == "__main__":
    # Executa a aplica√ß√£o e retorna c√≥digo de sa√≠da
    sys.exit(main())

================================================================================
üìÑ shared/polygons.py
================================================================================
import math
import numpy

def dicionario_poligonos(fator):

    def icosaedro():
        
        def triangulo_original():
            
            def primeira_definicao_pontos():
                lista_pontos = []
                for x in range(fator ** 2):
                    if x % 2 == 0:
                        coord_x = x / 2 + 0.5
                        coord_y = math.sin(math.pi / 6)
                    else:
                        coord_x = x / 2 + 0.5
                        coord_y = math.sqrt(3) / 3
                    lista_pontos.append((round(coord_x, 15), round(coord_y, 15)))
                return lista_pontos
            
            def ponto_por_linha():
                lista_pontos = [0]
                ppf = fator * 2 - 1
                una = fator * 2 - 1
                while una != 1:
                    lista_pontos.append(ppf)
                    ppf += una - 2
                    una -= 2
                return lista_pontos

            def processar_coordenadas(coordenadas, indices):
                r = math.sqrt(3) / 3
                h = math.sqrt(0.75) * fator
                coords = []
                for i in range(len(indices)):
                    if i == len(indices) - 1:
                        segmento = [coordenadas[-1]]
                    else:
                        inicio, fim = indices[i], indices[i + 1]
                        segmento = coordenadas[inicio:fim]
                    for x in range(len(segmento)):
                        coefy = math.sin(math.pi / 6) * r
                        cx = (0.5 * i + 0.5 * x) + 0.5 - fator / 2
                        if x % 2 == 0:
                            cy = 0 + math.sqrt(0.75) * i + coefy - h / 2
                        else:
                            cy = r - coefy + math.sqrt(0.75) * i + coefy - h / 2
                        coords.append((cx, cy))
                return coords
            return processar_coordenadas(primeira_definicao_pontos(), ponto_por_linha())

        to = triangulo_original()

        def triangulos_equatoriais_em_pe():
            raio = fator / (2 * math.sin(math.pi / 5))
            apotema = fator / (2 * math.tan(math.pi / 5))
            theta = math.asin((raio - apotema) / fator)
            h = fator * math.sqrt(0.75)
            t1 = [(x, math.cos(theta) * y, math.sin(theta) * y) for x, y in to]
            t1 = [(x, y, z + apotema + math.sin(theta) * h / 2) for x, y, z in t1]
            return t1

        t1 = triangulos_equatoriais_em_pe()

        def rotacionar_em_torno_do_eixo_y(coordenadas, angulo_graus):
            angulo_radianos = math.radians(angulo_graus)
            cos_theta = math.cos(angulo_radianos)
            sin_theta = math.sin(angulo_radianos)
            coordenadas_rotacionadas = []
            for x, y, z in coordenadas:
                x_novo = cos_theta * x + sin_theta * z
                y_novo = y
                z_novo = -sin_theta * x + cos_theta * z
                coordenadas_rotacionadas.append((x_novo, y_novo, z_novo))
            return coordenadas_rotacionadas

        t2 = rotacionar_em_torno_do_eixo_y(t1, 72)
        t3 = rotacionar_em_torno_do_eixo_y(t1, 144)
        t4 = rotacionar_em_torno_do_eixo_y(t1, 216)
        t5 = rotacionar_em_torno_do_eixo_y(t1, 288)

        def triangulos_equatoriais_invertidos():
            raio = fator / (2 * math.sin(math.pi / 5))
            apotema = fator / (2 * math.tan(math.pi / 5))
            theta = math.asin((raio - apotema) / fator)
            h = fator * math.sqrt(0.75)
            t6 = [(x, -y) for x, y in to]
            t6 = [(x, math.cos(theta) * y, math.sin(theta) * -y) for x, y in t6]
            t6 = [(x, y, z + apotema + math.sin(theta) * h / 2) for x, y, z in t6]
            return t6

        tr = triangulos_equatoriais_invertidos()
        t6 = rotacionar_em_torno_do_eixo_y(tr, 36)
        t7 = rotacionar_em_torno_do_eixo_y(tr, 108)
        t8 = rotacionar_em_torno_do_eixo_y(tr, 180)
        t9 = rotacionar_em_torno_do_eixo_y(tr, 252)
        t10 = rotacionar_em_torno_do_eixo_y(tr, 324)

        def triangulos_polares_norte():
            alpha = math.acos(1 / (2 * math.tan(math.pi / 5) * math.sqrt(0.75)))
            apotema = fator / (2 * math.tan(math.pi / 5))
            h = fator * math.sqrt(0.75)
            deslocamento = apotema - math.cos(alpha) * h / 2
            raio = fator / (2 * math.sin(math.pi / 5))
            theta = math.asin((raio - apotema) / fator)
            deslocamento_vertical = (math.cos(theta) * h / 2) + (math.sin(alpha) * h / 2)
            tr = [(x, 0, -y) for x, y in to]
            tr = [(x, math.sin(alpha) * -z + deslocamento_vertical,
                z * math.cos(alpha) + deslocamento) for x, y, z in tr]
            return tr

        tr = triangulos_polares_norte()

        t11 = rotacionar_em_torno_do_eixo_y(tr, 36)
        t12 = rotacionar_em_torno_do_eixo_y(tr, 108)
        t13 = rotacionar_em_torno_do_eixo_y(tr, 180)
        t14 = rotacionar_em_torno_do_eixo_y(tr, 252)
        t15 = rotacionar_em_torno_do_eixo_y(tr, 324)

        def triangulos_polares_sul():
            alpha = math.acos(1 / (2 * math.tan(math.pi / 5) * math.sqrt(0.75)))
            apotema = fator / (2 * math.tan(math.pi / 5))
            h = fator * math.sqrt(0.75)
            deslocamento = apotema - math.cos(alpha) * h / 2
            raio = fator / (2 * math.sin(math.pi / 5))
            theta = math.asin((raio - apotema) / fator)
            deslocamento_vertical = (math.cos(theta) * h / 2) + (math.sin(alpha) * h / 2)
            t16 = [(x, 0, -y) for x, y in to]
            t16 = [(x, math.sin(alpha) * z - deslocamento_vertical,
                    z * math.cos(alpha) + deslocamento) for x, y, z in t16]
            return t16

        t16 = triangulos_polares_sul()
        t17 = rotacionar_em_torno_do_eixo_y(t16, 72)
        t18 = rotacionar_em_torno_do_eixo_y(t16, 144)
        t19 = rotacionar_em_torno_do_eixo_y(t16, 216)
        t20 = rotacionar_em_torno_do_eixo_y(t16, 288)
        return [t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20]

    def esfera(pontos, raio):

        def projetar_ponto_na_esfera(ponto, raio):
            x, y, z = ponto
            magnitude = math.sqrt(x**2 + y**2 + z**2)
            return (
                raio * x / magnitude,
                raio * y / magnitude,
                raio * z / magnitude
            )

        return [[projetar_ponto_na_esfera(ponto, raio) for ponto in lista] for lista in pontos]

    esfera = esfera(icosaedro(), fator)

    def poligonos():
        poligonos = []
        
        def ponto_por_linha():
            lista_pontos = [0]
            ppf = fator * 2 - 1
            una = fator * 2 - 1
            while una != 1:
                lista_pontos.append(ppf)
                ppf += una - 2
                una -= 2
            return lista_pontos

        p = ponto_por_linha()

        def hexagonos_centrais():
            hexagonos = []
            for t in esfera:
                i = 0
                for x in range(fator - 2, 0, -1):
                    for y in range(x):
                        hexagonos.append(numpy.array([
                            t[p[y] + i * 2 + 1],
                            t[p[y] + i * 2 + 2],
                            t[p[y] + i * 2 + 3],
                            t[p[y + 1] + i * 2 + 2],
                            t[p[y + 1] + i * 2 + 1],
                            t[p[y + 1] + i * 2]
                        ]))
                    i += 1
            return hexagonos

        poligonos.append(hexagonos_centrais())

        def hexagonos_tropicais_sul():
            hexagonos = []
            for x in range(5):
                for y in range(fator - 1):
                    hexagonos.append(numpy.array([
                        esfera[x][y * 2],
                        esfera[x][y * 2 + 1],
                        esfera[x][y * 2 + 2],
                        esfera[x + 15][y * 2 + 2],
                        esfera[x + 15][y * 2 + 1],
                        esfera[x + 15][y * 2]
                    ]))
            return hexagonos

        poligonos.append(hexagonos_tropicais_sul())

        def hexagonos_tropicais_norte():
            hexagonos = []
            for x in range(5, 10, 1):
                for y in range(fator - 1):
                    hexagonos.append(numpy.array([
                        esfera[x][y * 2],
                        esfera[x][y * 2 + 1],
                        esfera[x][y * 2 + 2],
                        esfera[x + 5][y * 2 + 2],
                        esfera[x + 5][y * 2 + 1],
                        esfera[x + 5][y * 2]
                    ]))
            return hexagonos

        poligonos.append(hexagonos_tropicais_norte())

        def hexagonos_equatoriais_ascendentes():
            hexagonos = []
            for x in range(5):
                for y in range(fator - 1):
                    if x == 0:
                        hexagonos.append(numpy.array([
                            esfera[x][p[y]],
                            esfera[x][p[y] + 1],
                            esfera[x][p[y + 1]],
                            esfera[x + 9][p[fator - y - 1] - 1],
                            esfera[x + 9][p[fator - y - 1] - 2],
                            esfera[x + 9][p[fator - y - 1] + 2 * y]
                        ]))
                    else:
                        hexagonos.append(numpy.array([
                            esfera[x][p[y]],
                            esfera[x][p[y] + 1],
                            esfera[x][p[y + 1]],
                            esfera[x + 4][p[fator - y - 1] - 1],
                            esfera[x + 4][p[fator - y - 1] - 2],
                            esfera[x + 4][p[fator - y - 1] + 2 * y]
                        ]))
            return hexagonos

        poligonos.append(hexagonos_equatoriais_ascendentes())

        def hexagonos_equatoriais_descendentes():
            hexagonos = []
            for x in range(5):
                for y in range(fator - 1):
                    hexagonos.append(numpy.array([
                        esfera[x][p[fator - 1 - y] + 2 * y],
                        esfera[x][p[fator - 1 - y] - 2],
                        esfera[x][p[fator - 1 - y] - 1],
                        esfera[x + 5][p[y + 1]],
                        esfera[x + 5][p[y] + 1],
                        esfera[x + 5][p[y]]
                    ]))
            return hexagonos

        poligonos.append(hexagonos_equatoriais_descendentes())

        def hexagonos_polares_norte():
            hexagonos = []
            for x in range(10, 15, 1):
                for y in range(fator - 1):
                    if x == 10:
                        hexagonos.append(numpy.array([
                            esfera[x][p[y]],
                            esfera[x][p[y] + 1],
                            esfera[x][p[y + 1]],
                            esfera[x + 4][p[y + 1] + (fator - y - 2) * 2],
                            esfera[x + 4][p[y + 1] - 2],
                            esfera[x + 4][p[y + 1] - 1]
                        ]))
                    else:
                        hexagonos.append(numpy.array([
                            esfera[x][p[y]],
                            esfera[x][p[y] + 1],
                            esfera[x][p[y + 1]],
                            esfera[x - 1][p[y + 1] + (fator - y - 2) * 2],
                            esfera[x - 1][p[y + 1] - 2],
                            esfera[x - 1][p[y + 1] - 1]
                        ]))
            return hexagonos

        poligonos.append(hexagonos_polares_norte())

        def hexagonos_polares_sul():
            hexagonos = []
            for x in range(15, 20):
                for y in range(fator - 1):
                    if x == 15:
                        hexagonos.append(numpy.array([
                            esfera[x][p[y]],
                            esfera[x][p[y] + 1],
                            esfera[x][p[y + 1]],
                            esfera[x + 4][p[y + 1] + (fator - y - 2) * 2],
                            esfera[x + 4][p[y + 1] - 2],
                            esfera[x + 4][p[y + 1] - 1]
                        ]))
                    else:
                        hexagonos.append(numpy.array([
                            esfera[x][p[y]],
                            esfera[x][p[y] + 1],
                            esfera[x][p[y + 1]],
                            esfera[x - 1][p[y + 1] + (fator - y - 2) * 2],
                            esfera[x - 1][p[y + 1] - 2],
                            esfera[x - 1][p[y + 1] - 1]
                        ]))
            return hexagonos

        poligonos.append(hexagonos_polares_sul())

        def pentagonos():

            pentagonos = []

            def pentagonos_tropicais_sul():
                pentagonos = []
                for x in range(5):
                    if x == 0:
                        pentagonos.append(numpy.array([
                            esfera[0][0],
                            esfera[9][p[fator - 1]],
                            esfera[4][p[1] - 1],
                            esfera[19][p[1] - 1],
                            esfera[15][0]
                        ]))
                    else:
                        pentagonos.append(numpy.array([
                            esfera[x][0],
                            esfera[x + 4][p[fator - 1]],
                            esfera[x - 1][p[1] - 1],
                            esfera[x + 14][p[1] - 1],
                            esfera[x + 15][0]
                        ]))
                return pentagonos

            pentagonos.extend(pentagonos_tropicais_sul())

            def pentagonos_tropicais_norte():
                pentagonos = []
                for x in range(5):
                    if x == 0:
                        pentagonos.append(numpy.array([
                            esfera[0][p[fator - 1]],
                            esfera[5][0],
                            esfera[10][0],
                            esfera[14][p[1] - 1],
                            esfera[9][p[1] - 1]
                        ]))
                    else:
                        pentagonos.append(numpy.array([
                            esfera[x][p[fator - 1]],
                            esfera[x + 5][0],
                            esfera[x + 10][0],
                            esfera[x + 9][p[1] - 1],
                            esfera[x + 4][p[1] - 1]
                        ]))
                return pentagonos

            pentagonos.extend(pentagonos_tropicais_norte())

            def pentagono_polo_norte():
                return numpy.array([
                    esfera[10][p[fator - 1]],
                    esfera[11][p[fator - 1]],
                    esfera[12][p[fator - 1]],
                    esfera[13][p[fator - 1]],
                    esfera[14][p[fator - 1]]
                ])

            pentagonos.append(pentagono_polo_norte())

            def pentagono_polo_sul():
                return numpy.array([
                    esfera[15][p[fator - 1]],
                    esfera[16][p[fator - 1]],
                    esfera[17][p[fator - 1]],
                    esfera[18][p[fator - 1]],
                    esfera[19][p[fator - 1]]
                ])

            pentagonos.append(pentagono_polo_sul())
            
            return pentagonos

        poligonos.append(pentagonos())

        return poligonos

    poligonos = poligonos()

    def dic_pol():
        coord_vert = {}
        h = 0
        for x in range(5):        
            for i, z in enumerate(range(fator - 2, 0, -1)):
                n = fator * 2 - 1
                for a in range(z):
                    coord_vert[(n - a, fator * x + i + 1)] = poligonos[0][h]
                    h += 1

        for x in range(5):
            for i, z in enumerate(range(fator - 2, 0, -1)):
                n = fator + 1
                for a in range(z):
                    coord_vert[(n + a, fator * x + 2 + i + a)] = poligonos[0][h]
                    h += 1

        for x in range(5):
            for i, z in enumerate(range(fator - 2, 0, -1)):
                n = fator - 1
                for a in range(z):
                    coord_vert[(n - a, fator * x + 1 - x * (a + 1) + i)] = poligonos[0][h]
                    h += 1

        for x in range(5):
            b = fator * x + 1 - x
            for i, z in enumerate(range(fator - 2, 0, -1)):
                n = fator * 2 + 1
                for a in range(z):
                    coord_vert[(n + a, b + i - a * x)] = poligonos[0][h]
                    h += 1
        h = 0
        for x in range(5):
            for z in range(fator - 1):
                coord_vert[(fator * 2, fator * x + z + 1)] = poligonos[1][h]
                h += 1
        h = 0
        for x in range(5):
            for z in range(fator - 1):
                coord_vert[(fator, fator * x + z + 1)] = poligonos[2][h]
                h += 1
        h = 0
        for x in range(5):
            for z in range(fator - 1):
                coord_vert[(fator * 2 - z - 1, fator * x)] = poligonos[3][h]
                h += 1
        h = 0
        for x in range(5):
            for z in range(fator - 1):
                coord_vert[(fator + z + 1, fator * x + z + 1)] = poligonos[4][h]
                h += 1
        h = 0
        for x in range(5):
            for z in range(fator - 1):
                coord_vert[(fator - z - 1, (fator - z - 1) * x)] = poligonos[5][h]
                h += 1
        h = 0
        for x in range(5):
            for i, z in enumerate(range(fator - 1, 0, -1)):
                coord_vert[(fator * 2 + i + 1, z * x)] = poligonos[6][h]
                h += 1
        h = 0
        for x in range(5):
            coord_vert[(fator * 2, fator * x)] = poligonos[7][h]
            h += 1
        for x in range(5):
            coord_vert[(fator, fator * x)] = poligonos[7][h]
            h += 1
        coord_vert[(0, 0)] = poligonos[7][h]
        h += 1
        coord_vert[(fator * 3, 0)] = poligonos[7][h]

        return coord_vert
    
    return dic_pol()

================================================================================
üìÑ shared/planet.py
================================================================================
import random
from shared.polygons import dicionario_poligonos
from shared.geography import definir_geografia

class Planeta:
    def __init__(self, fator, bioma):
        self.fator = fator
        self.bioma_inicial = bioma
        self.geografia, self.capitais_players = definir_geografia(dicionario_poligonos(fator), fator, bioma) # capitais = [(int, int), ...]
        random.shuffle(self.capitais_players)
        self.numero_de_jogadores = len(self.capitais_players)
        biomas_invalidos = {"Ice", "Sea", "Ocean", "Coast", bioma}
        capitais_player_set = set(self.capitais_players)
        nodos_validos = [
            n for n in self.geografia.nodes()
            if self.geografia.nodes[n]["bioma"] not in biomas_invalidos and n not in capitais_player_set
        ]
        npn = 27 - len(self.capitais_players)  # Lembrar de evitar npn (pa√≠ses neutros) negativo
        self.capitais_neutros = random.sample(nodos_validos, npn)
        random.shuffle(self.capitais_neutros)
        self.civilizacoes = []


================================================================================
üìÑ shared/geography.py
================================================================================
import networkx
import random
import math
from statistics import mean
from random import choice

# CUSTOS BASE
CUSTOS_BASE = {
    'Ice': 20.0,
    'Mountains': 12.0,
    'Hills': 6.0,
    'Forest': 4.0,
    'Meadow': 3.0,
    'Savanna': 4.0,
    'Desert': 5.0,
    'Coast': 0.8,
    'Sea': 0.6,
    'Ocean': 0.4
}

PENALIDADE_TRANSICAO = 15.0

def letra_grega(placa):
    letras_gregas_dict = {
        "Alpha": "Œë", "Beta": "Œí", "Gamma": "Œì", "Delta": "Œî",
        "Epsilon": "Œï", "Zeta": "Œñ", "Eta": "Œó", "Theta": "Œò",
        "Iota": "Œô", "Kappa": "Œö", "Lambda": "Œõ", "Mu": "Œú",
        "Nu": "Œù", "Xi": "Œû", "Omicron": "Œü", "Pi": "Œ†",
        "Rho": "Œ°", "Sigma": "Œ£", "Tau": "Œ§", "Upsilon": "Œ•",
        "Phi": "Œ¶", "Chi": "Œß", "Psi": "Œ®", "Omega": "Œ©"
    }
    return letras_gregas_dict.get(placa)

def definir_geografia(poligonos, fator, bioma):

    geografia = networkx.DiGraph()

    for coordenadas in poligonos:
        geografia.add_node(coordenadas)

    def tipo_de_poligono(c):
        if c == (0, 0):
            geografia.nodes[c]['tipo'] = 'pn'
            return "pn"
        elif 0 < c[0] < fator and c[1] % c[0] == 0:
            geografia.nodes[c]['tipo'] = 'ipn'
            return "ipn"
        elif 0 < c[0] < fator and c[1] % c[0] != 0:
            geografia.nodes[c]['tipo'] = 'cpn'
            return "cpn"
        elif c[0] == fator and c[1] % c[0] == 0:
            geografia.nodes[c]['tipo'] = 'ntn'
            return "ntn"
        elif c[0] == fator and c[1] % c[0] != 0:
            geografia.nodes[c]['tipo'] = 'itn'
            return "itn"
        elif fator < c[0] < fator * 2:
            geografia.nodes[c]['tipo'] = 'e'
            return "e"
        elif c[0] == fator * 2 and c[1] % fator != 0:
            geografia.nodes[c]['tipo'] = 'its'
            return "its"
        elif c[0] == fator * 2 and c[1] % fator == 0:
            geografia.nodes[c]['tipo'] = 'nts'
            return "nts"
        elif fator * 2 < c[0] < fator * 3 and c[1] % (fator * 3 - c[0]) != 0:
            geografia.nodes[c]['tipo'] = 'cps'
            return "cps"
        elif fator * 2 < c[0] < fator * 3 and c[1] % (fator * 3 - c[0]) == 0:
            geografia.nodes[c]['tipo'] = 'ips'
            return "ips"
        elif c[0] == fator * 3:
            geografia.nodes[c]['tipo'] = 'ps'
            return "ps"

    for n in list(geografia.nodes):
        no = tipo_de_poligono(n)
        if no == "pn":
            for y in range(5):
                geografia.add_edge(n, (1, y), direcao=f'S{y+1}')
            continue
        if no == "ps":
            for y in range(5):
                geografia.add_edge(n, (fator * 3 - 1, y), direcao=f'N{y+1}')
            continue
        x = n[1] // n[0]
        y = n[1] // (fator * 3 - n[0])
        if no == "ipn":
            if n[1] != n[0] * 5 - 1:
                geografia.add_edge(n, (n[0] + 1, n[1] + x), direcao='S')
                geografia.add_edge(n, (n[0] + 1, n[1] + x + 1), direcao='SE')
                geografia.add_edge(n, (n[0], n[1] + 1), direcao='E')
                geografia.add_edge(n, (n[0] - 1, n[1] - x), direcao='N')
                geografia.add_edge(n, (n[0], n[1] - 1), direcao='W') if n[1] != 0 else geografia.add_edge(n, (n[0], n[0] * 5 - 1), direcao='W')
                geografia.add_edge(n, (n[0] + 1, n[1] + x - 1), direcao='SW') if n[1] != 0 else \
                                        geografia.add_edge(n, (n[0] + 1, (n[0] + 1) * 5 - 1), direcao='SW')
            else:
                geografia.add_edge(n, (n[0] + 1, n[1] + x), direcao='S')
                geografia.add_edge(n, (n[0] + 1, n[1] + x + 1), direcao='SE')
                geografia.add_edge(n, (n[0], 0), direcao='E')
                geografia.add_edge(n, (n[0] - 1, n[1] - x), direcao='N')
                geografia.add_edge(n, (n[0], n[1] - 1), direcao='W')
                geografia.add_edge(n, (n[0] + 1, n[1] + x - 1), direcao='SW')
        elif no == "cpn":
            if n[1] != n[0] * 5 - 1:
                geografia.add_edge(n, (n[0] + 1, n[1] + x + 1), direcao='SE')
                geografia.add_edge(n, (n[0], n[1] + 1), direcao='E')
                geografia.add_edge(n, (n[0] - 1, n[1] - x), direcao='NE')
                geografia.add_edge(n, (n[0] - 1, n[1] - x - 1), direcao='NW')
                geografia.add_edge(n, (n[0], n[1] - 1), direcao='W')
                geografia.add_edge(n, (n[0] + 1, n[1] + x), direcao='SW')
            else:
                geografia.add_edge(n, (n[0] + 1, n[1] + x + 1), direcao='SE')
                geografia.add_edge(n, (n[0], 0), direcao='E')
                geografia.add_edge(n, (n[0] - 1, 0), direcao='NE')
                geografia.add_edge(n, (n[0] - 1, n[1] - x - 1), direcao='NW')
                geografia.add_edge(n, (n[0], n[1] - 1), direcao='W')
                geografia.add_edge(n, (n[0] + 1, n[1] + x), direcao='SW')
        elif no == "ntn":
            geografia.add_edge(n, (n[0] + 1, n[1]), direcao='SW')
            geografia.add_edge(n, (n[0] + 1, n[1] + 1), direcao='SE')
            geografia.add_edge(n, (n[0], n[1] + 1), direcao='NE')
            geografia.add_edge(n, (n[0] - 1, n[1] - x), direcao='N')
            geografia.add_edge(n, (n[0], n[1] - 1), direcao='NW') if n[1] != 0 else geografia.add_edge(n, (n[0], n[0] * 5 - 1), direcao='NW')
        elif no == "itn":
            if n[1] != fator * 5 - 1:
                geografia.add_edge(n, (n[0] + 1, n[1]), direcao='SW')
                geografia.add_edge(n, (n[0] + 1, n[1] + 1), direcao='NE')
                geografia.add_edge(n, (n[0], n[1] + 1), direcao='E')
                geografia.add_edge(n, (n[0] - 1, n[1] - x), direcao='NE')
                geografia.add_edge(n, (n[0] - 1, n[1] - x - 1), direcao='NW')
                geografia.add_edge(n, (n[0], n[1] - 1), direcao='W')
            else:
                geografia.add_edge(n, (n[0] + 1, n[1]), direcao='SW')
                geografia.add_edge(n, (n[0] + 1, 0), direcao='NE')
                geografia.add_edge(n, (n[0], 0), direcao='E')
                geografia.add_edge(n, (n[0] - 1, 0), direcao='NE')
                geografia.add_edge(n, (n[0] - 1, n[1] - x - 1), direcao='NW')
                geografia.add_edge(n, (n[0], n[1] - 1), direcao='W')
        elif no == "e":
            if n[1] != fator * 5 - 1:
                geografia.add_edge(n, (n[0] + 1, n[1]), direcao='SW')
                geografia.add_edge(n, (n[0] + 1, n[1] + 1), direcao='SE')
                geografia.add_edge(n, (n[0], n[1] + 1), direcao='E')
                geografia.add_edge(n, (n[0] - 1, n[1]), direcao='NE')
                geografia.add_edge(n, (n[0] - 1, n[1] - 1), direcao='NW') if n[1] != 0 else geografia.add_edge(n, (n[0] - 1, fator * 5 - 1), direcao='NW')
                geografia.add_edge(n, (n[0], n[1] - 1), direcao='W') if n[1] != 0 else geografia.add_edge(n, (n[0], fator * 5 - 1), direcao='W')
            else:
                geografia.add_edge(n, (n[0] + 1, n[1]), direcao='SW')
                geografia.add_edge(n, (n[0] + 1, 0), direcao='SE')
                geografia.add_edge(n, (n[0], 0), direcao='E')
                geografia.add_edge(n, (n[0] - 1, n[1]), direcao='NE')
                geografia.add_edge(n, (n[0] - 1, n[1] - 1), direcao='NW')
                geografia.add_edge(n, (n[0], n[1] - 1), direcao='W')
        elif no == "its":
            if n[1] != fator * 5 - 1:
                geografia.add_edge(n, (n[0] + 1, n[1] - y), direcao='SE')
                geografia.add_edge(n, (n[0], n[1] + 1), direcao='E')
                geografia.add_edge(n, (n[0] - 1, n[1]), direcao='NE')
                geografia.add_edge(n, (n[0] - 1, n[1] - 1), direcao='NW')
                geografia.add_edge(n, (n[0], n[1] - 1), direcao='W')
                geografia.add_edge(n, (n[0] + 1, n[1] - y - 1), direcao='SW')
            else:
                geografia.add_edge(n, (n[0] + 1, 0), direcao='SE')
                geografia.add_edge(n, (n[0], 0), direcao='E')
                geografia.add_edge(n, (n[0] - 1, n[1]), direcao='NE')
                geografia.add_edge(n, (n[0] - 1, n[1] - 1), direcao='NW')
                geografia.add_edge(n, (n[0], n[1] - 1), direcao='W')
                geografia.add_edge(n, (n[0] + 1, n[1] - y - 1), direcao='SW')
        elif no == "nts":
            geografia.add_edge(n, (n[0] + 1, n[1] - y), direcao='S')
            geografia.add_edge(n, (n[0], n[1] + 1), direcao='SE')
            geografia.add_edge(n, (n[0] - 1, n[1]), direcao='NE')
            geografia.add_edge(n, (n[0] - 1, n[1] - 1), direcao='NW') if n[1] != 0 else geografia.add_edge(n, (n[0] - 1, fator * 5 - 1), direcao='NW')
            geografia.add_edge(n, (n[0], n[1] - 1), direcao='SW') if n[1] != 0 else geografia.add_edge(n, (n[0], fator * 5 - 1), direcao='SW')
        elif no == "cps":
            if n[1] != (fator * 3 - n[0]) * 5 - 1:
                geografia.add_edge(n, (n[0] + 1, n[1] - y), direcao='SE')
                geografia.add_edge(n, (n[0], n[1] + 1), direcao='E')
                geografia.add_edge(n, (n[0] - 1, n[1] + y + 1), direcao='NE')
                geografia.add_edge(n, (n[0] - 1, n[1] + y), direcao='NW')
                geografia.add_edge(n, (n[0], n[1] - 1), direcao='W')
                geografia.add_edge(n, (n[0] + 1, n[1] - y - 1), direcao='SW')
            else:
                geografia.add_edge(n, (n[0] + 1, 0), direcao='SE')
                geografia.add_edge(n, (n[0], 0), direcao='E')
                geografia.add_edge(n, (n[0] - 1, n[1] + y + 1), direcao='NE')
                geografia.add_edge(n, (n[0] - 1, n[1] + y), direcao='NW')
                geografia.add_edge(n, (n[0], n[1] - 1), direcao='W')
                geografia.add_edge(n, (n[0] + 1, n[1] - y - 1), direcao='SW')
        elif no == "ips":
            if n[1] != (fator * 3 - n[0]) * 5 - 1:
                geografia.add_edge(n, (n[0] + 1, n[1] - y), direcao='S')
                geografia.add_edge(n, (n[0], n[1] + 1), direcao='SE')
                geografia.add_edge(n, (n[0] - 1, n[1] + y + 1), direcao='NE')
                geografia.add_edge(n, (n[0] - 1, n[1] + y), direcao='N')
                geografia.add_edge(n, (n[0] - 1, n[1] + y - 1), direcao='NW') if n[1] != 0 else \
                                        geografia.add_edge(n, (n[0] - 1, (fator * 3 - n[0] + 1) * 5 - 1), direcao='NW')
                geografia.add_edge(n, (n[0], n[1] - 1), direcao='SW') if n[1] != 0 else \
                                        geografia.add_edge(n, (n[0], (fator * 3 - n[0]) * 5 - 1), direcao='SW')
            else:
                geografia.add_edge(n, (n[0] + 1, n[1] - y), direcao='S')
                geografia.add_edge(n, (n[0], 0), direcao='SE')
                geografia.add_edge(n, (n[0] - 1, n[1] + y + 1), direcao='NE')
                geografia.add_edge(n, (n[0] - 1, n[1] + y), direcao='N')
                geografia.add_edge(n, (n[0] - 1, n[1] + y - 1), direcao='NW')
                geografia.add_edge(n, (n[0], n[1] - 1), direcao='SW')

    areas = list(poligonos.keys())
    areas_sem_definicao = {}
    areas_definidas = {}
    referencias_relevo = random.sample(areas, fator * 20)

    for area in areas:
        areas_sem_definicao[area] = []
        areas_definidas[area] = []

    for n in range(fator * 3 // 2):
        if not areas_sem_definicao:
            break
        for node in referencias_relevo:
            altitude = random.randint(0, 12)
            areas_definidas[node].append(altitude)
            if node in areas_sem_definicao:
                del areas_sem_definicao[node]
            distancias = networkx.single_source_shortest_path_length(geografia, node)
            nos_a_n_arestas = [node for node, distance in distancias.items() if distance == n + 1]
            for neighbor in nos_a_n_arestas:
                if neighbor in areas_sem_definicao and neighbor not in referencias_relevo:
                    areas_sem_definicao[neighbor].append(altitude)
        for chave in list(areas_sem_definicao.keys()):
            if areas_sem_definicao[chave]:
                areas_definidas[chave].append(round(mean(areas_sem_definicao[chave]), 3))
                del areas_sem_definicao[chave]

    chaves = list(areas_definidas.keys())
    random.shuffle(chaves)
    chaves_ordenadas = sorted(chaves, key=lambda chave: areas_definidas[chave])
    percentual_terra = random.randint(35, 45)
    limite_abissal = (100 - percentual_terra) // 2
    limite_barreira = limite_abissal + (100 - percentual_terra) // 3
    nivel_do_mar = 100 - percentual_terra
    limite_planicie = nivel_do_mar + (100 - nivel_do_mar) * 4 // 6
    limite_planalto = limite_planicie + (100 - limite_planicie) // 2

    for i, chave in enumerate(chaves_ordenadas):
        if i <= len(chaves_ordenadas) * limite_abissal // 100:
            geografia.nodes[chave]['altitude'] = 'abissal'
        elif i <= len(chaves_ordenadas) * limite_barreira // 100:
            geografia.nodes[chave]['altitude'] = 'barreira'
        elif i <= len(chaves_ordenadas) * nivel_do_mar // 100:
            geografia.nodes[chave]['altitude'] = 'plataforma'
        elif i <= len(chaves_ordenadas) * limite_planicie // 100:
            geografia.nodes[chave]['altitude'] = 'planicie'
        elif i <= len(chaves_ordenadas) * limite_planalto // 100:
            geografia.nodes[chave]['altitude'] = 'planalto'
        else:
            geografia.nodes[chave]['altitude'] = 'cordilheira'

    areas_sem_definicao = {}
    areas_definidas = {}
    referencias_umidade = random.sample(areas, 60)

    for area in areas:
        areas_sem_definicao[area] = []
        areas_definidas[area] = []

    for n in range(fator * 3 // 2):
        if not areas_sem_definicao:
            break
        for node in referencias_umidade:
            altitude = random.randint(0, 12)
            areas_definidas[node].append(altitude)
            if node in areas_sem_definicao:
                del areas_sem_definicao[node]
            distancias = networkx.single_source_shortest_path_length(geografia, node)
            nos_a_n_arestas = [node for node, distance in distancias.items() if distance == n + 1]
            for neighbor in nos_a_n_arestas:
                if neighbor in areas_sem_definicao and neighbor not in referencias_umidade:
                    areas_sem_definicao[neighbor].append(altitude)
        for chave in list(areas_sem_definicao.keys()):
            if areas_sem_definicao[chave]:
                areas_definidas[chave].append(round(mean(areas_sem_definicao[chave]), 3))
                del areas_sem_definicao[chave]

    chaves = list(areas_definidas.keys())
    random.shuffle(chaves)
    chaves_ordenadas = sorted(chaves, key=lambda chave: areas_definidas[chave])

    for i, chave in enumerate(chaves_ordenadas):
        if i <= len(chaves_ordenadas) * 25 // 100:
            geografia.nodes[chave]['umidade'] = 'arido'
        elif i <= len(chaves_ordenadas) * 50 // 100:
            geografia.nodes[chave]['umidade'] = 'semi-arido'
        elif i <= len(chaves_ordenadas) * 75 // 100:
            geografia.nodes[chave]['umidade'] = 'fertil'
        else:
            geografia.nodes[chave]['umidade'] = 'umido'

    # Defini√ß√£o das placas com dois pontos de refer√™ncia cada
    placas = ['Alpha', 'Beta', 'Gamma', 'Delta', 'Epsilon', 'Zeta',
            'Eta', 'Theta', 'Iota', 'Kappa', 'Lambda', 'Mu',
            'Nu', 'Xi', 'Omicron', 'Pi', 'Rho', 'Sigma',
            'Tau', 'Upsilon', 'Phi', 'Chi', 'Psi', 'Omega']
    
    # Gerar duas refer√™ncias para cada placa (total 48)
    placas_duplicadas = placas * 2
    random.shuffle(placas_duplicadas)
    referencias_geologia = random.sample(areas, 48)

    # Atribuir cada refer√™ncia a uma placa
    areas_definidas = {area: None for area in areas}
    for i, node in enumerate(referencias_geologia):
        areas_definidas[node] = placas_duplicadas[i]

    # Calcular a placa para cada n√≥ baseado na proximidade
    for node in areas_definidas:
        if areas_definidas[node] is not None:
            continue  # Pula pontos de refer√™ncia j√° definidos
        
        # Encontrar todas as dist√¢ncias para pontos de refer√™ncia
        distancias = []
        for ref in referencias_geologia:
            try:
                dist = networkx.shortest_path_length(geografia, ref, node)
                distancias.append( (ref, dist) )
            except networkx.exception.NetworkXNoPath:
                continue
        
        if not distancias:
            areas_definidas[node] = random.choice(placas)
            continue
        
        # Encontrar a dist√¢ncia m√≠nima
        min_dist = min(d[1] for d in distancias)
        candidatos = [d[0] for d in distancias if d[1] == min_dist]
        
        # Escolher aleatoriamente entre candidatos equidistantes
        ref_escolhida = random.choice(candidatos)
        areas_definidas[node] = areas_definidas[ref_escolhida]
    
    coeficiente_movimento = 300

    # Gerar cores para as placas
    cores_placas = []
    for _ in range(24):
        while True:
            r = random.randint(0, 255)
            g = random.randint(0, 255)
            b = random.randint(0, 255)
            if (r + g + b) > 127.5:
                cores_placas.append((r, g, b))
                break

    latitude_equador = fator * 3 / 2

    for chave, valor in areas_definidas.items():
        geografia.nodes[chave]['placa'] = valor
        geografia.nodes[chave]['cor_placa'] = cores_placas[placas.index(valor)]
        geografia.nodes[chave]['letra_grega'] = letra_grega(geografia.nodes[chave]['placa'])
        if chave[0] < latitude_equador:
            distancia_para_equador = latitude_equador - chave[0]
            angulo = distancia_para_equador * 90 / latitude_equador
            incidencia_solar = math.cos(math.radians(angulo))
        elif chave[0] == latitude_equador:
            distancia_para_equador = 0
            angulo = distancia_para_equador * 90 / latitude_equador
            incidencia_solar = math.cos(math.radians(angulo))
        else:
            distancia_para_equador = chave[0] - latitude_equador
            angulo = distancia_para_equador * 90 / latitude_equador
            incidencia_solar = math.cos(math.radians(angulo))
        if geografia.nodes[chave]['altitude'] == 'abissal' \
        or geografia.nodes[chave]['altitude'] == 'barreira' \
        or geografia.nodes[chave]['altitude'] == 'plataforma':
            fator_altitude = 3
        elif geografia.nodes[chave]['altitude'] == 'planicie':
            fator_altitude = 1
        elif geografia.nodes[chave]['altitude'] == 'planalto':
            fator_altitude = -1
        elif geografia.nodes[chave]['altitude'] == 'cordilheira':
            fator_altitude = -3
        if geografia.nodes[chave]['umidade'] == 'umido':
            fator_umidade = 1.5
        elif geografia.nodes[chave]['umidade'] == 'fertil':
            fator_umidade = 0.5
        elif geografia.nodes[chave]['umidade'] == 'semi-arido':
            fator_umidade = -0.5
        elif geografia.nodes[chave]['umidade'] == 'arido':
            fator_umidade = -1.5
        geografia.nodes[chave]['temperatura'] = round(40 * incidencia_solar - 8 + fator_altitude + fator_umidade, 1) - 4

    for node, atributos in geografia.nodes(data=True):
        temperatura = atributos.get('temperatura')
        altitude = atributos.get('altitude')
        umidade = atributos.get('umidade')
        
        if temperatura < 0:
            atributos['bioma'] = 'Ice'
        else:
            if altitude == 'cordilheira':
                atributos['bioma'] = 'Mountains'
            elif altitude == 'planalto':
                atributos['bioma'] = 'Hills'
            elif altitude == 'planicie':
                if umidade == 'umido':
                    atributos['bioma'] = 'Forest'
                elif umidade == 'fertil':
                    atributos['bioma'] = 'Meadow'
                elif umidade == 'semi-arido':
                    atributos['bioma'] = 'Savanna'
                else:
                    atributos['bioma'] = 'Desert'
            elif altitude == 'plataforma':
                atributos['bioma'] = 'Coast'
            elif altitude == 'barreira':
                atributos['bioma'] = 'Sea'
            else:
                atributos['bioma'] = 'Ocean'
        
        # Aplica custo base diretamente do dicion√°rio
        atributos['cust_mob'] = CUSTOS_BASE[atributos['bioma']] * coeficiente_movimento

    for u, v in geografia.edges():
        mob_u = geografia.nodes[u]['cust_mob']
        mob_v = geografia.nodes[v]['cust_mob']
        
        u_maritimo = geografia.nodes[u]['bioma'] in ['Coast', 'Sea', 'Ocean']
        v_maritimo = geografia.nodes[v]['bioma'] in ['Coast', 'Sea', 'Ocean']
        
        if u_maritimo != v_maritimo:  # Transi√ß√£o terra-mar
            geografia[u][v]['cust_mob'] = max(mob_u, mob_v) * 2 + PENALIDADE_TRANSICAO * coeficiente_movimento
        else:
            geografia[u][v]['cust_mob'] = (mob_u + mob_v) / 2

        # B√¥nus para rotas oce√¢nicas longas
        if u_maritimo and v_maritimo:
            geografia[u][v]['cust_mob'] *= 0.7

    cores_biomas = {
        'Ocean': (0, 23, 98), 'Sea': (8, 33, 113), 'Coast': (12, 71, 108), 'Meadow': (91, 174, 70), 'Savanna': (231, 190, 141),
        'Forest': (75, 129, 66), 'Desert': (242, 242, 166), 'Hills': (201, 147, 121), 'Mountains': (158, 86, 86), 'Ice': (245, 255, 245)
    }

    bioma_escolhido = []

    for node in geografia.nodes:
        geografia.nodes[node]['cor_bioma'] = cores_biomas[geografia.nodes[node]['bioma']]
        if geografia.nodes[node]['bioma'] == f'{bioma}':
            bioma_escolhido.append(node)

    bioma_escolhido = [n for n, attr in geografia.nodes(data=True) if attr['bioma'] == f'{bioma}']
    lista_capitais = [choice(bioma_escolhido)]
    while len(lista_capitais) < len(bioma_escolhido) // 2:
        d2 = {}
        for candidato in bioma_escolhido:
            if candidato in lista_capitais:
                continue
            d = {}
            for capital in lista_capitais:
                d[capital] = networkx.shortest_path_length(geografia, source=candidato, target=capital, weight='custo_mobilidade')
            d2[candidato] = min(d.values())
        if not d2:  # Se n√£o houver candidatos poss√≠veis, o planeta n√£o comporta a quantidade desejada
            print("d2 vazio")
            raise ValueError("O planeta n√£o comporta essa quantidade de civiliza√ß√µes!")
        maior_valor = max(d2.values())
        chaves_maior_valor = [chave for chave, valor in d2.items() if valor == maior_valor]
        lista_capitais.append(choice(chaves_maior_valor))

    print(f"n√∫mero de {bioma}:", len(bioma_escolhido))
    return geografia, lista_capitais


================================================================================
üìÑ shared/naming.py
================================================================================
import random

# ==========================   NOMES DAS PROV√çNCIAS EM INGL√äS   ==========================#

adj_ing = ["Good", "White", "Sacred", "Broken", "Hidden",
           "Long", "Little", "Old", "Heavenly", "Big",
           "High", "Small", "Large", "Pristine", "Bad",
           "Red", "Blue", "Green", "Yellow", "Black",
           "Golden", "Calm", "Dry", "Lost", "Brave",
           "Deep", "Bright", "Heavy", "Joyful", "Mysterious",
           "Petrified", "Split", "Pleasant", "Cooling", "Falling",
           "Sharp", "Distant", "Ancient", "Sad", "Beautiful",
           "Eternal", "Enchanted", "Sunny", "Cold", "Steep",
           "Gentle", "Peaceful", "Turbulent", "Dead", "Wide",
           "Open", "Closed", "Flat", "Dark", "Warm",
           "Serene", "Giant", "Pure"]

nouns_ing = ["Rock", "Mountain", "River", "Land", "House",
             "Field", "Cavern", "Sky", "Star", "Swamp",
             "Spring", "Forest", "Lake", "Sand", "Soil",
             "Winds", "Rain", "Cliff", "Fountain", "Water",
             "Man", "Grove", "Air", "Fire", "Leaf",
             "Trail", "Night", "Fruit", "Bird", "Snake",
             "Ville", "Hill", "Creek", "Hut", "Meadow",
             "Wolf", "Spirit", "Light", "Slope", "Soldier",
             "Valley", "Mound", "Town",
             "Woods", "Ridge", "Day", "Peak",
             "Refuge", "Sign", "Bush",
             "Pond", "Road", "Chapel", "City",
             "Bridge", "Priest", "Grave", "Curse",
             "Ground", "View", "Grass"]

# ==========================   NOMES DAS PROV√çNCIAS EM CHIN√äS   ==========================#

adj_chi = [
    "H«éo", "B√°i", "Sh√©nsh√®ng", "P√≤su√¨", "Y«ênc√°ng",
    "Xi«éo", "L«éo", "TiƒÅnt√°ng de", "D√†", "GƒÅo",
    "Yu√°nsh«ê de", "Hu√†i", "H√≥ngs√® de", "L√°ns√® de", "L«ús√® de",
    "Hu√°ngs√® de", "Hƒìis√® de", "Jƒ´n s√® de", "ƒÄnj√¨ng", "GƒÅnz√†o",
    "M√≠shƒ´", "Y«íngg«én", "Shƒìn", "M√≠ngli√†ng", "Zh√≤ng",
    "Ku√†il√®", "Sh√©nm√¨", "Sh√≠hu√†", "Fƒìnli√®", "Y√∫ku√†i",
    "Fƒìnl√≠", "Y√°oyu«én", "G«îl«éo", "BƒìishƒÅng", "Mƒõil√¨",
    "Y«íngh√©ng", "Qƒ´ngl«éng", "Wƒìnr√≥u", "P√≠ngj√¨ng", "D√≤ngd√†ng",
    "KuƒÅn", "Hƒìi'√†n", "N√≠ngj√¨ng", "J√πd√†", "Ch√∫nj√¨ng",
    "S«êw√°ng", "Lƒõng", "Wƒìnnu«én", "ZhƒÅom√¨"
]

nouns_chi = [
    "Y√°nsh√≠", "ShƒÅn", "H√©", "T«îd√¨", "F√°ngzi",
    "Ti√°n", "D√≤ngxu√©", "TiƒÅnk≈çng", "Xƒ´ngxƒ´ng", "Zh«éoz√©",
    "Qu√°n", "Sƒìnl√≠n", "H√∫", "ShƒÅ", "T«îr«éng",
    "Fƒìng", "Y«î", "Xu√°ny√°", "Pƒìnqu√°n", "Shu«ê",
    "N√°nr√©n", "Xi«éosh√πl√≠n", "K≈çngq√¨", "Hu«í", "Y√®",
    "Xi«éol√π", "Y√®", "Shu«êgu«í", "Ni«éo", "Sh√©",
    "Xi«éozh√®n", "Qi≈´", "Xƒ´", "Xi«éow≈´", "C«éod√¨",
    "L√°ng", "L√≠ng", "GuƒÅng", "P≈ç", "Sh√¨bƒ´ng",
    "ShƒÅng«î", "T«îqi≈´", "Ch√©ngzh√®n",
    "Sh√πl√≠n", "ShƒÅnj«ê", "TiƒÅn", "Fƒìng",
    "B√¨n√†n Su«í", "BiƒÅozh√¨", "Gu√†nm√π",
    "Ch√≠t√°ng", "L√π", "Xi«éo ji√†ot√°ng", "Ch√©ngsh√¨",
    "Qi√°o", "M√πshƒ´", "F√©nm√π", "Z«îzh√≤u",
    "D√¨mi√†n", "J«êngs√®", "C«éo"
]

# ==========================   NOMES DAS PROV√çNCIAS EM WU   ==========================#

adj_wu = [
    "Hao", "Baek", "Shensheng", "Posui", "Yincang",
    "Long", "Xiao", "Lao", "Tiantang De", "Da",
    "Gao", "Xiao", "Da", "Yuanshi", "Huai",
    "Hong", "Lan", "L«ú", "Huang", "Hei",
    "Jin", "Anjing", "Ganzao", "Mishi", "Yonggan",
    "Shen", "Liang", "Zhong", "Kuaile", "Shenmi",
    "Shihua", "Fenlie", "Yukuai", "Shuangshuang", "Falling",
    "Ji", "Yuan", "Gulao", "Beishang", "Meili",
    "Yongheng", "Jingya", "Wenxin", "Pingjing", "Dongdang",
    "Guang", "Hei'an", "Ningjing", "Juda", "Chunjing",
    "Si", "Leng", "Wennuan", "Zhaomi"
]

nouns_wu = [
    "Yan", "Shan", "He", "Di", "Fangzi",
    "Tian", "Dong", "Tian", "Xing", "Zhaoze",
    "Quan", "Senlin", "Hu", "Sha", "Turang",
    "Feng", "Yu", "Xuanya", "Penquan", "Shui",
    "Nan", "Xiaoshulin", "Kongqi", "Huo", "Ye",
    "Xiaolu", "Ye", "Shuiguo", "Niao", "She",
    "Zhen", "Qiu", "Xi", "Wu", "Caodi",
    "Lang", "Ling", "Guang", "Po", "Shibing",
    "Gu", "Qiu", "Zhen",
    "Ling", "Tian", "Feng",
    "Binan", "Biaozhi", "Guanmu",
    "Chitang", "L√π", "Jiaotang", "Cheng",
    "Qiao", "Mushi", "Fen", "Zuzhou",
    "Dimian", "Jingse", "Cao"
]

# ==========================   NOMES DAS PROV√çNCIAS EM YUE   ==========================#

adj_yue = [
    "H√≥u", "Baahk", "SƒÅn", "KƒÅp", "Ch√≤ih",
    "Cheung", "Sai", "Louh", "Tin", "Daih",
    "H√≤hng", "Sai", "Daaih", "Chƒ´ng", "WƒÅi",
    "H√πhng", "L√†ahm", "Luhk", "W√≤hng", "HƒÅak",
    "GƒÅm", "Ngaan", "Gaan", "SƒÅt", "Y√πhng",
    "SƒÅm", "Mihng", "Jung", "F√πhng", "SƒÅm",
    "SƒÅam", "FƒÅan", "FƒÅan", "Sƒ´k", "Lohk",
    "Kƒìui", "Y√∫hn", "G√∫", "SƒÅam", "Meih",
    "Y√∫hn", "Meih", "T√¨ng", "L√†ahng", "Ging",
    "WƒÅn", "F√®ihng", "S≈´ng", "Sƒ´k", "F√∫",
    "DƒÅk", "Gw√°n", "Bihn", "A√†m", "WƒÅn",
    "N√¨hng", "Gin", "K√©uhng"
]

nouns_yue = [
    "S√©k", "SƒÅan", "H√≤h", "Dih", "Uk",
    "T√¨hn", "Duhng", "Tin", "Sƒ´ng", "J√≥u",
    "Chƒìun", "SƒÅan", "Wuht", "SƒÅ", "T√≥",
    "F≈´ng", "Y√∫h", "Nga", "BƒÅan", "Sƒìui",
    "N√†ahm", "L√†ahm", "Hƒìung", "F√≥", "Yihp",
    "Jƒ´ng", "Yeh", "Gw√≥", "Jƒ´u", "S√©h",
    "Ch√©ng", "KƒÅ", "Hƒìung", "W≈´", "Tƒ´n",
    "L√≤hng", "L√¨hng", "G≈çng", "B≈çu", "Sih",
    "G≈´k", "F≈´ng", "MƒÅhng",
    "L√≠ng", "Yaht", "F≈´ng",
    "BƒÅk", "Bƒ´u", "ChƒÅan",
    "Ch√¨h", "L√≥uh", "Sƒ´u", "Sihng",
    "Kiu", "Sƒ´n", "Fan", "Joek",
    "Deih", "J√≠ng", "Chou"
]

# ==========================   NOMES DAS PROV√çNCIAS EM MIN   ==========================#

adj_min = [
    "H√≥", "PeÃçh", "SiƒÅn-t√®", "P≈ç", "Bih",
    "Ti√¥", "Si√≥", "L≈ç", "Thian-t√¢ng √™", "T≈ça",
    "K√≤Õò", "Si√≥", "T≈ça", "Chheng-chhi≈´‚Åø", "PhƒÅi",
    "√Çng-sek √™", "L√°n-sek √™", "L≈´-sek √™", "NÃÇg-sek √™", "Hƒìi-sek √™",
    "Kim-sek √™", "B√™ng-an", "Kan", "L√≤Õò", "Y√∫ng",
    "Kh√¢m", "B√™ng", "Ch√≤ng", "Khoai-loÃçh", "Sƒ´m-jiÃçt",
    "P√™", "Pun-liƒÅu", "Kho√¢n-h√≤a‚Åø", "ChhiaÃçt-liƒÅu", "T√≤-loÃçh",
    "Siam", "T≈´", "K√≥Õò", "Phainn", "Bi√∫",
    "√ç‚Åø-chi√≥ng", "Tƒ´n-hiong", "Thinn-sia‚Åø", "Kang", "S√∫",
    "L√™ng", "Kh√¨a‚Åø", "L√≥ng", "S«πg", "O√¢n",
    "Chhi≈´‚Åø", "Kh√≠-√°", "Ch√™ng"
]

nouns_min = [
    "Chioh", "Suann", "H√¥", "T≈ç", "Ti√°m",
    "Chh√¢n", "T≈çng", "Thinn", "Chhi‚Åø", "Chh√°u",
    "Chh√ªn", "Sng-l√Æm", "Oh", "S√≤a‚Åø", "Th√¥",
    "H√ªi‚Åø", "H≈çÕò", "Ki√°m", "Pun", "Ch√∫i",
    "L√¢ng", "Si√¢u", "Khong-kh√¨", "H√≥e", "H√¢",
    "L≈çÕò-chh√π", "IÃça‚Åø", "K√∫i", "Chhui", "Ch√¥a",
    "Chi√¢‚Åø", "Kio", "K√®", "Koe", "Chh√°u-l√≠",
    "L√¢ng-kƒ´", "Seng", "Chh√¨ng", "P√≤", "Ch√ª",
    "Kheh", "Ki√¥‚Åø", "Chhng",
    "L√™ng", "Jat", "Hiong"
    "Pi-bƒÅng", "Pi√≥", "Chhe-b√≤",
    "Chh√™", "L≈çÕò", "Chha", "Chhƒ´‚Åø",
    "Ki√¥", "S≈´n", "B≈´n", "Ch√≤e",
    "Toƒì", "Chhƒ´ng", "Chh√°u"
]

# ==========================   NOMES DAS PROV√çNCIAS EM ESPANHOL   ==========================#

nouns_esp_mas = ["R√≠o", "Hombre", "Viento", "Fuego", "Sendero",
                 "Campo", "Pueblo", "Lobo", "Soldado", "Arroyo",
                 "Mont√≠culo", "D√≠a", "Bosque", "Rancho", "Pantano",
                 "Parque", "Se√±al", "Estanque", "Camino", "Puente",
                 "Cielo", "Manantial", "Bosque", "Lago", "Suelo",
                 "Acantilado", "P√°jaro", "Sitio", "Valle", "Pozo",
                 "Refugio", "Arbusto", "Nacimiento", "Terreno", "Esp√≠ritu"]

nouns_esp_fem = ["Roca", "Monta√±a", "Tierra", "Casa", "Fruta",
                 "Caverna", "Estrella", "Arena", "Cima",
                 "Lluvia", "Fuente", "Agua", "Arboleda", "Hoja",
                 "Noche", "Serpiente", "Colina", "Caba√±a", "Pradera",
                 "Luz", "Ladera", "Margem", "Ciudad", "Cresta",
                 "Hada", "Capilla", "Tumba", "Maldici√≥n", "Vista",
                 "Hierba", "Cruz"]

adj_esp_mas = ["Bueno", "Blanco", "Sagrado", "Roto", "Oculto",
               "Peque√±o", "Peque√±o", "Viejo", "Celestial", "Grande",
               "Alto", "Peque√±o", "Grande", "Pr√≠stino", "Malo",
               "Rojo", "Azul", "Verde", "Amarillo", "Negro",
               "Dorado", "Calmado", "Ruidoso", "Seco", "Perdido",
               "Profundo", "Brillante", "Pesado", "Alegre", "Misterioso",
               "M√≥vil", "Dividido", "Agradable", "Refrigerante", "Cayente",
               "Afilado", "Distante", "Antiguo", "Triste", "Hermoso",
               "Rasgado", "Majestuoso", "Soleado", "Sombr√≠o", "Empinado",
               "Suave", "Pac√≠fico", "Turbulento", "√Åspero", "Ancho",
               "Abierto", "Cerrado", "Plano", "Oscuro", "Infinito",
               "Sereno", "Gigante", "Fino", "Largo", "Ruidoso",
               "Fr√≠o", "C√°lido", "Peligroso", "Encantado", "Carvado",
               "Puro", "Valiente", "Eterno", "Petrificado", "Muerto"]

adj_esp_fem = ["Buena", "Blanca", "Sacra", "Rota", "Oculta",
               "Peque√±a", "Peque√±a", "Vieja", "Celestial", "Grande",
               "Alta", "Peque√±a", "Grande", "Pr√≠stina", "Mala",
               "Roja", "Azul", "Verde", "Amarilla", "Negra",
               "Dorada", "Calmada", "Ruidosa", "Seca", "Perdida",
               "Profunda", "Brillante", "Pesada", "Alegre", "Misteriosa",
               "M√≥vil", "Dividida", "Agradable", "Refrigerante", "Cayente",
               "Afilada", "Distante", "Antigua", "Triste", "Hermosa",
               "Rasgada", "Majestuosa", "Soleada", "Sombr√≠a", "Empinada",
               "Suave", "Pac√≠fica", "Turbulenta", "√Åspera", "Ancha",
               "Abierta", "Cerrada", "Plana", "Oscura", "Infinita",
               "Serena", "Gigante", "Fina", "Larga", "Ruidosa",
               "Fr√≠a", "C√°lida", "Peligrosa", "Encantada", "Carvada",
               "Pura", "Valiente", "Eterna", "Petrificada", "Muerta"]

# ==========================   NOMES DAS PROV√çNCIAS EM FRANC√äS   ==========================#

adj_fra_mas = ["Bon", "Blanc", "Sacr√©", "Cass√©", "Cach√©",
               "Petit", "Mort", "Vieux", "C√©leste", "Grand",
               "Haut", "P√©trifi√©", "√âternel", "Pristin", "Mauvais",
               "Rouge", "Bleu", "Vert", "Jaune", "Noir",
               "Dor√©", "Calme", "Bruyant", "Sec", "Perdu",
               "Profond", "Brillant", "Lourd", "Joyeux", "Myst√©rieux",
               "Mouvant", "Divis√©", "Agr√©able", "Rafra√Æchissant", "Tombant",
               "Tranchant", "Lointain", "Ancien", "Triste", "Beau",
               "D√©chir√©", "Majestueux", "Ensoleill√©", "Sombre", "Escarp√©",
               "Douc", "Paisible", "Turbulent", "Dur", "Large",
               "Ouvert", "Ferm√©", "Pur", "Sombre", "Infini",
               "Serein", "G√©ant", "Fin", "Long", "Courageux",
               "Froid", "Chaud", "P√©rilleux", "Enchant√©", "Taill√©"]

adj_fra_fem = ["Bonne", "Blanche", "Sacr√©e", "Cass√©e", "Cach√©e",
               "Petite", "Morte", "Vieille", "C√©leste", "Grande",
               "Haute", "P√©trifi√©e", "√âternelle", "Pristine", "Mauvaise",
               "Rouge", "Bleue", "Verte", "Jaune", "Noire",
               "Dor√©e", "Calme", "Bruyante", "S√®che", "Perdue",
               "Profonde", "Brillante", "Lourde", "Joyeuse", "Myst√©rieuse",
               "Mouvante", "Divis√©e", "Agr√©able", "Rafra√Æchissante", "Tombante",
               "Tranchante", "Lointaine", "Ancienne", "Triste", "Belle",
               "D√©chir√©e", "Majestueuse", "Ensoleill√©e", "Sombre", "Escarp√©e",
               "Douce", "Paisible", "Turbulente", "Dure", "Large",
               "Ouverte", "Ferm√©e", "Pure", "Sombre", "Infinie",
               "Sereine", "G√©ante", "Fine", "Longue", "Courageuse",
               "Froide", "Chaude", "P√©rilleuse", "Enchant√©e", "Taill√©e"]

bags = ["Bon", "Petit", "Vieux", "Grand", "Haut",
        "Ancien", "Beau", "Large", "Long", "Bonne",
        "Petite", "Vieille", "Grande", "Haute", "Ancienne",
        "Belle", "Large", "Longue"]

nouns_fra_mas = ["Champ", "Ciel", "Marais", "Site", "Lac",
                 "Sable", "Sol", "Vent", "Homme", "Bosquet",
                 "Air", "Feu", "Sentier", "Oiseau", "Ruisseau",
                 "Pr√©", "Loup", "Esprit", "Soldat", "Puits",
                 "Tertre", "Bois", "Jour", "Pic", "Parc",
                 "Refuge", "Signe", "Buisson", "√âtang", "Pont",
                 "Pr√™tre", "Sol"]

nouns_fra_fem = ["Roche", "Montagne", "Rivi√®re", "Terre", "Maison",
                 "Caverne", "√âtoile", "For√™t", "Pluie",
                 "Falaise", "Fontaine", "Eau", "Feuille",
                 "Nuit", "Fruit", "Serpent", "Ville", "Colline",
                 "Cabane", "Lumi√®re", "Pente", "Vall√©e", "Rive",
                 "Ville", "Cr√™te", "Croix", "Ligne", "F√©e",
                 "Route", "Chapelle", "Ville", "Tombe", "Mal√©diction",
                 "Naissance", "Vue", "Herbe"]

# ==========================   NOMES DAS PROV√çNCIAS EM HINDI   ==========================#

adj_hin_mas = ["Achchha", "Safed", "Pavitr", "Toota Hua", "Chhipa Hua",
               "Chhota", "Thoda", "Puraana", "Swargiy", "Bada",
               "Ucch", "Chhota", "Bada", "Nirmal", "Bura",
               "Laal", "Neela", "Hara", "Peela", "Kaala",
               "Svarnim", "Shaant", "Sookha", "Kho Gaya", "Bahadur",
               "Gahra", "Chamkeela", "Bhaari", "Aanandmay", "Rahasyamay",
               "Shilajit", "Vibhaajit", "Sukhad", "Sheetal", "Girta",
               "Tez", "Door", "Praacheen", "Dukhii", "Sundar",
               "Shaashvat", "Mantramugdh", "Sooryamay", "Thanda", "Dhalwaan",
               "Naram", "Shaantipoorn", "Ashaant", "Mara Hua",
               "Chaudaa", "Khula", "Band", "Lamba", "Andhera",
               "Garam", "Shaant", "Vishaalkaay", "Shuddh"]

adj_hin_fem = ["Achchhi", "Safed", "Pavitr", "Tooti Hui", "Chhupi Hui",
               "Chhoti", "Thodi", "Puraani", "Swargiy", "Badi",
               "Ucchi", "Chhoti", "Badi", "Nirmal", "Buri",
               "Laal", "Neeli", "Hari", "Peeli", "Kaali",
               "Svarn", "Shaant", "Sookhi", "Kho Gayi", "Bahadur",
               "Gahri", "Chamkeeli", "Bhaari", "Aanandmay", "Rahasyamay",
               "Shilajit", "Vibhaajit", "Sukhad", "Sheetal", "Girti",
               "Tez", "Door", "Praacheen", "Dukhii", "Sundar",
               "Shaashvat", "Mantramugdh", "Sooryamay", "Thandi", "Dhalwaan",
               "Naram", "Shaantipoorn", "Ashaant", "Mari", "Chaudii",
               "Khulii", "Band", "Andherii", "Garam",
               "Shaant", "Vishaal", "Shuddh", "Lambii"]

nouns_hin_mas = ["Pahaad", "Parvat", "Ghar", "Khet", "Guha",
                 "Aakash", "Tara", "Aadmi", "Vriksh", "Vayu",
                 "Aag", "Gaon", "Pahaadi", "Jhupri", "Maidaan",
                 "Prakash", "Dhalan", "Sainik", "Teela", "Din",
                 "Shikhar", "Aashray", "Sanket", "Talab", "Sadak",
                 "Pul", "Pujari", "Shaap"]

nouns_hin_fem = ["Nadi", "Bhoomi", "Daldal", "Junglai", "Jheel",
                 "Ret", "Mitti", "Hawa", "Baarish", "Khaai",
                 "Fawara", "Paani", "Patta", "Raat",
                 "Pakshi", "Saanp", "Nadiya", "Bheriya", "Aatma",
                 "Ghaati", "Nagari", "Chotee", "Jangal", "Jhaadi",
                 "Ghaas", "Nagar", "Kabar", "Zameen", "Drishya"]

# ==========================   NOMES DAS PROV√çNCIAS EM RUSSO   ==========================#

adj_rus_mas = ["Khoroshiy", "Belyy", "Svyatoy", "Slomannyy", "Skrytyy",
               "Malen'kiy", "Staryy", "Nebesnyy", "Bol'shoy", "Vysokiy",
               "Gigantskiy", "Dlinnyy", "Chistyy", "Netronutyy", "Plokhoy",
               "Krasnyy", "Siniy", "Zelenyy", "Zheltyy", "Chernyy",
               "Zolotoy", "Spokoinyy", "Sukhoy", "Poteryannyy", "Smelyy",
               "Glubokiy", "Yarkiy", "Tyazhelyy", "Radostnyy", "Zagadochnyy",
               "Okamenelyy", "Raskolotyy", "Priyatnyy", "Okhlazhdayushchiy", "Padayushchiy",
               "Ostryy", "Dalekiy", "Drevniy", "Grustnyy", "Prekrasnyy",
               "Vechnyy", "Ocharovannyy", "Solnechnyy", "Kholodnyy", "Krutoy",
               "Nezhnyy", "Spokoinyy", "Burnyy", "Mertvyy", "Shirokiy",
               "Otkrytyy", "Zakrytyy", "Ploskiy", "Temnyy", "Teplyy",
               "Bezmyatezhnyy"]

adj_rus_fem = ["Khoroshaya", "Belaya", "Svyataya", "Slomannaya", "Skrytaya",
               "Malen'kaya", "Chistaya", "Staraya", "Nebesnaya", "Bol'shaya",
               "Vysokaya", "Malen'kaya", "Dlinnaya", "Netronutaya", "Plohaya",
               "Krasnaya", "Sinyaya", "Zelenaya", "Zhel'taya", "Chernaya",
               "Zolotaya", "Spokojnaya", "Sukhaya", "Poteryannaya", "Smelaya",
               "Glubokaya", "Yarkaya", "Tyazhelaya", "Radostnaya", "Zagadochnaya",
               "Okamenelaya", "Raskolotaya", "Priyatnaya", "Okhlazhdayushchaya", "Padayushchaya",
               "Ostraya", "Dalekaya", "Drevnyaya", "Grustnaya", "Prekrasnaya",
               "Vechnaya", "Ocharovannaya", "Solnechnaya", "Kholodnaya", "Krutaya",
               "Nezhnaya", "Spokojnaya", "Burnaya", "Mertvaya", "Shirokaya",
               "Otkrytaya", "Zakrytaya", "Ploskaya", "Temnaya", "Teplaya",
               "Bezmyatezhnaya", "Gigantskaya"]

adj_rus_neu = ["Khoroshee", "Beloe", "Svyatoe", "Slomannoe", "Skrytoe",
               "Malen'koe", "Chistoe", "Staroe", "Nebesnoe", "Bol'shoe",
               "Vysokoe", "Gigantskoe", "Dlinnoe", "Netronutoe", "Plokho–µ",
               "Krasnoe", "Sinee", "Zelenoe", "Zhelt–æe", "Chernoe",
               "Zolotoe", "Spokoynoe", "Sukhoe", "Poteryannoe", "Smeloe",
               "Glubokoe", "Yarkoe", "Tyazheloe", "Radostnoe", "Zagadochnoe",
               "Okameneloe", "Raskolotoe", "Priyatnoe", "Okhlazhdayushchee", "Padayushchee",
               "Ostro–µ", "Dalekoe", "Drevnee", "Grustnoe", "Prekrasnoe",
               "Vechnoe", "Ocharovannoe", "Solnechnoe", "Kholodnoe", "Krutoe",
               "Nezhnoe", "Spokoynoe", "Burnoe", "Mertvoe", "Shirokoe",
               "Otkrytoe", "Zakrytoe", "Ploskoe", "Temnoe", "Teploe",
               "Bezmyatezhnoe"]

nouns_rus_mas = ["Dom", "Rodnik", "Les", "Pesok", "Vetry",
                 "Dozhd'", "Utes", "Fontan", "Chelovek", "Vozdukh",
                 "Ogon'", "List", "Frukt", "Kholm", "Ruchey",
                 "Lug", "Volk", "Dukh", "Svet", "Sklon",
                 "Soldat", "Valun", "Gorod", "Lesa", "Greben'",
                 "Den'", "Pik", "Znak", "Kust", "Prud",
                 "Most", "Svyashchennik", "Vid"]

nouns_rus_fem = ["Skala", "Gora", "Reka", "Zemlya", "Peshchera",
                 "Zvezda", "Pochva", "Voda", "Rosha", "Tropa",
                 "Noch'", "Ptitsa", "Zmeya", "Derevnya", "Khizhina",
                 "Dolina", "Doroga", "Chasovnya", "Mogila", "Zemlya",
                 "Trava"]

nouns_rus_neu = ["Pole", "Nebo", "Boloto", "Ozero", "Ubezhishche",
                 "Proklyatie"]

# ==========================   NOMES DAS PROV√çNCIAS EM VIETNAMITA   ==========================#

nouns_viet = ["ƒê√°", "N√∫i", "S√¥ng", "ƒê·∫•t", "Nh√†",
              "Ru·ªông", "Hang ƒê·ªông", "B·∫ßu Tr·ªùi", "Sao", "ƒê·∫ßm L·∫ßy",
              "Su·ªëi", "R·ª´ng", "H·ªì", "C√°t", "ƒê·∫•t",
              "Gi√≥", "M∆∞a", "V√°ch ƒê√°", "Su·ªëi", "N∆∞·ªõc",
              "Ng∆∞·ªùi", "R·ª´ng", "Kh√¥ng Kh√≠", "L·ª≠a", "L√°",
              "ƒê∆∞·ªùng M√≤n", "ƒê√™m", "Tr√°i C√¢y", "Chim", "R·∫Øn",
              "L√†ng", "ƒê·ªìi", "R√£nh", "Nh√† G·ªó", "ƒê·ªìng C·ªè",
              "S√≥i", "H·ªìn", "√Ånh S√°ng", "D·ªëc", "Ng∆∞·ªùi L√≠nh",
              "Thung L≈©ng", "G√≤ ƒê·∫•t", "Th·ªã Tr·∫•n",
              "R·ª´ng", "D√£y N√∫i", "Ng√†y", "ƒê·ªânh",
              "N∆°i Tr√∫ ·∫®n", "D·∫•u Hi·ªáu", "C√¢y B·ª•i",
              "Ao", "ƒê∆∞·ªùng", "Nh√† Th·ªù Nh·ªè", "Th√†nh Ph·ªë",
              "C√¢y C·∫ßu", "Th·∫ßy Tu", "Nghƒ©a Trang", "L·ªùi Nguy·ªÅn",
              "M·∫∑t ƒê·∫•t", "Quang C·∫£nh", "C·ªè"]

adj_viet = ["T·ªët", "Tr·∫Øng", "Th√°nh Thi√™ng", "V·ª°", "·∫®n",
            "Nh·ªè", "Nh·ªè", "C≈©", "Thi√™n Th·∫ßn", "L·ªõn",
            "Cao", "Nh·ªè", "L·ªõn", "Nguy√™n S∆°", "X·∫•u",
            "ƒê·ªè", "Xanh D∆∞∆°ng", "Xanh L√°", "V√†ng", "ƒêen",
            "V√†ng", "B√¨nh Tƒ©nh", "Kh√¥", "L·∫°c", "D≈©ng C·∫£m",
            "S√¢u", "S√°ng", "N·∫∑ng", "Vui V·∫ª", "B√≠ ·∫®n",
            "H√≥a Th·∫°ch", "Chia", "D·ªÖ Ch·ªãu", "L√†m M√°t", "R∆°i",
            "S·∫Øc", "Xa X√¥i", "C·ªï X∆∞a", "Bu·ªìn", "Xinh ƒê·∫πp",
            "Vƒ©nh C·ª≠u", "Ph√π Th·ªßy", "N·∫Øng", "L·∫°nh", "D·ªëc",
            "Nh·∫π Nh√†ng", "Thanh B√¨nh", "H·ªón Lo·∫°n", "Ch·∫øt", "R·ªông",
            "M·ªü", "ƒê√≥ng", "B·∫±ng Ph·∫≥ng", "T·ªëi", "·∫§m √Åp",
            "Y√™n B√¨nh", "Kh·ªïng L·ªì", "Trong Tr·∫Øng", "D√†i"]

# ==========================   NOMES DAS PROV√çNCIAS EM TURCO   ==========================#

adj_tur = ["ƒ∞yi", "Beyaz", "Kutsal", "Kƒ±rƒ±k", "Gizli",
           "Minik", "K√º√ß√ºk", "Eski", "Cennetsel", "B√ºy√ºk",
           "Y√ºksek", "K√º√ß√ºk", "B√ºy√ºk", "El deƒümemi≈ü", "K√∂t√º",
           "Kƒ±rmƒ±zƒ±", "Mavi", "Ye≈üil", "Sarƒ±", "Siyah",
           "Altƒ±n", "Sakin", "Kuru", "Kayƒ±p", "Cesur",
           "Derin", "Parlak", "Aƒüƒ±r", "Sevin√ßli", "Gizemli",
           "Ta≈üla≈ümƒ±≈ü", "B√∂l√ºnm√º≈ü", "Ho≈ü", "Serinletici", "D√º≈üen",
           "Keskin", "Uzak", "Antik", "√úzg√ºn", "G√ºzel",
           "Ebedi", "B√ºy√ºlenmi≈ü", "G√ºne≈üli", "Soƒüuk", "Dik",
           "Nazik", "Huzurlu", "Turbulanslƒ±", "√ñl√º", "Geni≈ü",
           "A√ßƒ±k", "Kapalƒ±", "D√ºz", "Karanlƒ±k", "Sƒ±cak",
           "Sakin", "Dev", "Saf", "Uzun"]

nouns_tur = ["Kaya", "Daƒü", "Nehir", "Toprak", "Ev",
             "Tarla", "Maƒüara", "G√∂ky√ºz√º", "Yƒ±ldƒ±z", "Bataklƒ±k",
             "Pƒ±nar", "Orman", "G√∂l", "Kum", "Toprak",
             "R√ºzgarlar", "Yaƒümur", "U√ßurum", "Fƒ±skiye", "Su",
             "Adam", "Aƒüa√ßlƒ±k", "Hava", "Ate≈ü", "Yaprak",
             "Yol", "Gece", "Meyve", "Ku≈ü", "Yƒ±lan",
             "K√∂y", "Tepelik", "K√∂y", "K√ºmes", "√áayƒ±r",
             "Kurt", "Ruh", "I≈üƒ±k", "Yama√ß", "Asker",
             "Vadi", "Tepenin", "≈ûehir",
             "Orman", "Sƒ±rt", "G√ºn", "Zirve",
             "Sƒ±ƒüƒ±nak", "ƒ∞≈üaret", "√áalƒ±",
             "G√∂let", "Yol", "Kapalƒ± Mekan", "≈ûehir",
             "K√∂pr√º", "Rahip", "Mezar", "Lanet",
             "Toprak", "Manzara", "√áim"]

# ==========================   NOMES DAS PROV√çNCIAS EM √ÅRABE   ==========================#

nouns_ara_mas = ["Jabal", "Nahr", "Ard", "Bayt", "Haql",
                 "Kahf", "Najm", "Naba", "Ramal", "Turab",
                 "Riyah", "Matar", "Jurf", "Maa", "Rajul",
                 "Bustan", "Hawa", "Nar", "Mamar", "Layl",
                 "Tair", "Tal", "Jadwal", "Koukh", "Dhi'b",
                 "Ruh", "Daw'", "Munhadar", "Jundi", "Wadi",
                 "Tal", "Balda", "Yawm", "Qimma", "Malja'",
                 "Alama", "Shujaira", "Birka", "Tariq", "Jisr",
                 "Kahin", "Qabr", "Manzar"]

nouns_ara_fem = ["Sakhra", "Samaa", "Mustanqaa", "Ghaabah", "Buhayrah",
                 "Nafura", "Waraqa", "Fakihah", "Thu'ban", "Madina",
                 "Marj", "La'na", "Ard", "Ushb"]

adj_ara_mas = ["Jayyid", "Abyad", "Muqaddas", "Maksur", "Makhfi",
               "Saghir", "Qadeem", "Samaawi", "Kabir",
               "Aali", "Naqi", "Sayyi'", "Hadi'",
               "Ahmar", "Azraq", "Akhdar", "Asfar", "Aswad",
               "Dhahabi", "Haade", "Jaa'if", "Mafqood",
               "Ameek", "Mashriq", "Thaqeel", "Mufrih", "Ghaamid",
               "Mutaharrik", "Mashquq", "Latif'", "Mubarrid", "Suqut",
               "Had", "Ba'id", "Qadeem", "Hazeen", "Jameel",
               "Mumazziq", "Muhib", "Mashmis", "Ka'ib", "Shadid",
               "Salem", "Mutadarrib", "Qaas", "Wasi'",
               "Muftuh", "Maghluq", "Mustah", "Dakn", "Lanha'i",
               "Amlaq", "Twil", "Sakhb",
               "Baarid", "Daa'if", "Khaatir",
               "Naqi", "Shaji'", "Abedi", "Mutahjar", "Mayyit"]

adj_ara_fem = ["Jayyidah", "Abyadah", "Muqaddasah", "Maksurah", "Makhfiyah",
               "Saghirah", "Qadeemah", "Samaawiyah", "Kabirah", "Aaliyah",
               "Naqiyah", "Sayyi'ah", "Hadi'ah", "Ahmarah", "Azraqah",
               "Akhdarah", "Asfarah", "Aswadah", "Dhahabiyah", "Haadeh",
               "Jaa'ifah", "Mafqoodah", "Ameekah", "Mashriqah", "Thaqeelah",
               "Mufrihah", "Ghaamidah", "Mutaharrikah", "Mashquqah", "Latif'ah",
               "Mubarridah", "Suqutah", "Hadh", "Baidah", "Qadeemah",
               "Hazeenah", "Jameelah", "Mumazziqah", "Muhibah", "Mashmisah",
               "Salemah", "Mutadarribah", "Qaasah", "Wasi'ah", "Muftuhah",
               "Maghluqah", "Mustahah", "Daknah", "Lanha'iah", "Amlaqah",
               "Twilah", "Sakhbah", "Baaridah", "Daa'ifah", "Khaatirah",
               "Naqiyah", "Shaji'ah", "Abediyah", "Mutahjarah", "Mayyitah"]

# ==========================   NOMES DAS PROV√çNCIAS EM INDON√âSIO   ==========================#

nouns_ind = ["Batu", "Gunung", "Sungai", "Tanah", "Rumah",
             "Lapangan", "Gua", "Langit", "Bintang", "Lembah",
             "Mata Air", "Hutan", "Danau", "Pasir", "Angin",
             "Hujan", "Tebing", "Air", "Pria", "Udara",
             "Api", "Daun", "Jejak", "Malam", "Buah",
             "Burung", "Ular", "Desa", "Bukit",
             "Gubuk", "Padang", "Serigala", "Roh", "Cahaya",
             "Kemiringan", "Prajurit", "Bank", "Sumur", "Gundukan",
             "Kota", "Punggung", "Ranch", "Hari", "Puncak",
             "Garis", "Taman", "Tempat Perlindungan", "Tanda", "Semak",
             "Kolam", "Peri", "Jalan", "Gereja", "Jembatan",
             "Imam", "Kuburan", "Kutukan", "Kelahiran", "Pemandangan",
             "Rumput", "Tempat"]

adj_ind = ["Baik", "Putih", "Suci", "Patah", "Tersembunyi",
           "Kecil", "Tua", "Ilahi", "Besar",
           "Tinggi", "Besar", "Buruk",
           "Merah", "Biru", "Hijau", "Kuning", "Hitam",
           "Emas", "Tenang", "Bising", "Kering", "Hilang",
           "Dalam", "Terang", "Berat", "Gembira", "Misterius",
           "Bergerak", "Terbelah", "Menyenangkan", "Pendinginan", "Jatuh",
           "Tajam", "Jauh", "Kuno", "Sedih", "Indah",
           "Robek", "Mewah", "Cerah", "Suram", "Curam",
           "Lembut", "Damai", "Berombak", "Kasar", "Lebar",
           "Terbuka", "Tertutup", "Dat", "Gelap", "Tak Terbatas",
           "Tenang", "Raksasa", "Bagus", "Panjang", "Loud",
           "Dingin", "Hangat", "Berbahaya", "Bertih", "Diukir",
           "Murni", "Berani", "Abadi", "Membeku", "Mati"]

# ==========================   NOMES DAS PROV√çNCIAS EM FARSI   ==========================#

nouns_far = [
    "Sang", "K≈´h", "RudkhƒÅneh", "Zamƒ´n", "KhƒÅneh",
    "KeshƒÅvarzƒ´", "Ghar", "ƒÄsemƒÅn", "SetƒÅreh", "BatlƒÅgh",
    "Cheshmeh", "Jangal", "DaryƒÅcheh", "Shen", "Khat",
    "BƒÅd", "BƒÅrƒÅn", "Sakhreh", "Cheshmeh", "ƒÄb",
    "Mard", "BƒÅgh", "HavƒÅ", "ƒÄtash", "Barg",
    "RƒÅh", "Shab", "Miveh", "Parandeh", "MƒÅr",
    "Shahrak", "Tappeh", "JuybƒÅr", "Kolbeh", "MarghzƒÅr",
    "Gorg", "R≈´h", "N≈´r", "Sarak", "Sarbaaz",
    "Dara", "Tappey", "Shahr",
    "Kamar", "Ruz", "Qolleh",
    "PanƒÅh", "NeshƒÅn", "Booteh",
    "Hawz", "JƒÅdeh", "Kelƒ´sƒÅ", "Shahr",
    "Pol", "Keshƒ´sh", "Ghabr", "Lanat",
    "Zamƒ´n", "Manzareh", "Alaf"
]

adj_far = [
    "Khoob", "Sefid", "Moghaddas", "Shekasteh", "Penhan",
    "Toolani", "Koochak", "Pir", "Asemani", "Bozorg",
    "Boland", "Koochak", "Bozorg", "PƒÅk", "Bad",
    "Ghermez", "ƒÄbi", "Sabz", "Zard", "Siah",
    "TalƒÅyi", "ƒÄrƒÅm", "Khoshk", "Gomshodeh", "Shoja",
    "Amigh", "Roshan", "Sangin", "Shad", "AsrƒÅrƒÅmiz",
    "Sang Shodeh", "Taghseem Shodeh", "KhoshƒÅyand", "Sard Konandeh", "Soghut Konandeh",
    "Tez", "Door", "BƒÅstƒÅn", "Ghamgin", "Ziba",
    "Abadi", "Gonjunje", "AftƒÅbi", "Sard", "Sakht",
    "Lotf", "ƒÄram", "Ashofteh", "Morde", "Pahn",
    "BƒÅz", "Basteh", "HamvƒÅr", "TƒÅrik", "Garm",
    "ArƒÅm", "Azim", "Pak"
]


# ==========================   NOMES DAS PROV√çNCIAS EM HAUSA   ==========================#

nouns_hau = ["Dutse", "Kogi", "Kasa", "Gida", "Fili",
             "Sama", "Tauraro", "Fadama", "Bazara", "Daji",
             "Tafkin", "Yashi", "Iska", "Ruwan Sama", "Hayi",
             "Ruwa", "Mutum", "Wuta", "Ganye", "Hanya",
             "Dare", "Ya'yan Itace", "Tsuntsu", "Maciji", "Kauye",
             "Tudu", "Daki", "Ruhu", "Fitila", "Soja",
             "Kwari", "Gari", "Katako", "Rana", "Hanya",
             "Birni", "Gada", "Firist", "Kabari", "Tsinewa",
             "Haihuwa", "Ciyawa"]

adj_hau = ["Mai Kyau", "Fari", "Mai Tsarki", "Boye", "Karami",
           "Tsoho", "Babba", "Mugu", "Ja", "Shudi"
            "Kore", "Rawaya", "Baki", "Jarumi", "Mai Zurfi"
            "Mai Haske", "Mai Nauyi", "Mai Kaifi",
            "Mai Nisa", "Mai Fadi",
            "Mai Duhu", "Dogo", "Mai Sanyi", "Mai Dumi"]

# ==========================   NOMES DAS PROV√çNCIAS EM SWAHILI   ==========================#

nouns_sua_c1 = ["Mwanajeshi", "Mchungaji"]

nouns_sua_c3 = ["Mlima", "Mto", "Msitu", "Mchanga", "Mwamba",
                "Moto", "Mwanga", "Mteremko", "Mji", "Mwitu",
                "Mgongo", "Mwatuko", "Mzizi", "Msalaba"]

nouns_sua_c5 = ["Jiwe", "Pango", "Anga", "Bwawa", "Ziwa",
                "Hori", "Bwana", "Jani", "Tunda", "Shamba",
                "Bonde", "Kimbilio", "Daraja", "Jini", "Kanisa",
                "Jiji"]

nouns_sua_c7 = ["Kisima", "Kichaka", "Kijiji", "Kilima", "Kibanda",
                "Kilele"]

nouns_sua_c9 = ["Nchi", "Nyumba", "Nyota", "Mvua", "Chemchem",
                "Hewa", "Njia", "Ndege", "Nyoka", "Mbwa Mwito",
                "Roho", "Kando", "Siku", "Ishara", "Barabara",
                "Kaburi", "Ardhi"]

nouns_sua_c11 = ["Uwanja", "Udongo", "Upepo", "Unyasi"]

adj_sua_c1 = ["Mwema", "Mweupe", "Mtakatifu", "Mvunjika", "Mfichwa",
              "Mdogo", "Mdogo", "Mzee", "Mbinguni", "Mkubwa",
              "Mrefu", "Mdogo", "Mkubwa", "Msafi", "Mbaya",
              "Mwekundu", "Mbuluu", "Mkijani", "Mnjano", "Mweusi",
              "Mdhahabu", "Mtulivu", "Mkelele", "Mkavu", "Mpotea",
              "Mkina", "Mangavu", "Mzito", "Mfuraha", "Msiri",
              "Msonga", "Mgawanyika", "Mpendeza", "Mburudisha", "Manguka",
              "Mkali", "Mbali", "Mkale", "Mhuzuni", "Mzuri",
              "Mraruka", "Madhimu", "Mjua", "Mgiza", "Mwima",
              "Mpole", "Mamani", "Mvurugu", "Mkali", "Mpana",
              "Mwazi", "Mfungwa", "Mbapa", "Mgiza", "Milele",
              "Mtulivu", "Mkubwa", "Mzuri", "Mrefu", "Mkelele",
              "Mbaridi", "Mjoto", "Mhatari", "Mpumbaza", "Mchonga",
              "Msafi", "Mjasiri", "Milele", "Mganda", "Mkufa"]

adj_sua_c3 = ["Mwema", "Mweupe", "Mtakatifu", "Mvunjika", "Mfichwa",
              "Mdogo", "Mdogo", "Mzee", "Mbinguni", "Mkubwa",
              "Mrefu", "Mdogo", "Mkubwa", "Msafi", "Mbaya",
              "Mwekundu", "Mbuluu", "Mkjani", "Mnjano", "Mweusi",
              "Mdhahabu", "Mtulivu", "Mkelele", "Mkavu", "Mpotea",
              "Mkina", "Mangavu", "Mzito", "Mfuraha", "Msiri",
              "Msonga", "Mgawanyika", "Mpendeza", "Mburudisha", "Manguka",
              "Mkali", "Mbali", "Mkale", "Mhuzuni", "Mzuri",
              "Mraruka", "Madhimu", "Mjua", "Mgiza", "Mwima",
              "Mpole", "Mmani", "Mvurugu", "Mkali", "Mpana",
              "Mwazi", "Mfungwa", "Mbapa", "Mgiza", "Milele",
              "Mtulivu", "Mkubwa", "Mzuri", "Mrefu", "Mkelele",
              "Mbaridi", "Mjoto", "Mhatari", "Mpumbaza", "Mchonga",
              "Msafi", "Mjasiri", "Milele", "Mganda", "Mkufa"]

adj_sua_c5 = ["Jema", "Jeupe", "Takatifu", "Vunjika", "Fichwa",
              "Dogo", "Dogo", "Zee", "Mbinguni", "Kubwa",
              "Refu", "Dogo", "Kubwa", "Safi", "Baya",
              "Jekundu", "Buluu", "Kijani", "Njano", "Jeusi",
              "Dhahabu", "Tulivu", "Kelele", "Kavu", "Potea",
              "Refu", "Angavu", "Zito", "Furaha", "Siri",
              "Songa", "Gawanyika", "Pendeza", "Burudisha", "Anguka",
              "Kali", "Mbali", "Kale", "Huzuni", "Zuri",
              "Raruka", "Adhimu", "Jua", "Giza", "Wima",
              "Mpole", "Amani", "Vurugu", "Kali", "Pana",
              "Wazi", "Fungwa", "Bapa", "Giza", "Milele",
              "Tulivu", "Kubwa", "Zuri", "Refu", "Kelele",
              "Baridi", "Joto", "Hatari", "Pumbaza", "Chonga",
              "Safi", "Jasiri", "Milele", "Ganda", "Kufa"]

adj_sua_c7 = ["Kizuri", "Kyeupe", "Kitakatifu", "Kivunjika", "Kifichika",
              "Kidogo", "Kidogo", "Kikongwe", "Kimbingu", "Kikubwa",
              "Kirefu", "Kidogo", "Kikubwa", "Kisafi", "Kibaya",
              "Kikundu", "Kibuluu", "Kijani", "Kinanjano", "Kyeusi",
              "Kidhahabu", "Kitulivu", "Kelele", "Kavu", "Kipotea",
              "Kina", "Kangavu", "Kizito", "Kifuraha", "Kiujabu",
              "Kisonga", "Kigawanyika", "Kipendeza", "Kipooza", "Kianguka",
              "Kikali", "Kimbali", "Kikale", "Kihuzuni", "Kizuri",
              "Kiraruka", "Kifalme", "Kijua", "Kigiza", "Kishuka",
              "Kipole", "Kiamani", "Kiturbulent", "Kikali", "Kipan",
              "Ki wazi", "Kifungwa", "Kibapa", "Kigiza", "Kisicho Na Mwisho",
              "Kitulivu", "Kijitu", "Kizuri", "Kirefu", "Kenye Sauti Kubwa",
              "Kibaridi", "Kijoto", "Kihatari", "Kivutia", "Kichongwa",
              "Kisafi", "Kijasiri", "Kidaima", "Kikamilifu", "Kimfu"]

adj_sua_c9 = ["Nzuri", "Nyeupe", "Takatifu", "Vunjika", "Fichwa",
              "Ndogo", "Ndogo", "Nzee", "Nbinguni", "Nkubwa",
              "Nrefu", "Ndogo", "Nkubwa", "Nsafi", "Nbaya",
              "Nyekundu", "Nbuluu", "Nkijani", "Nnjano", "Njeusi",
              "Ndahabu", "Ntulivu", "Nkelele", "Nkavu", "Npotea",
              "Nrefu", "Nangavu", "Nzito", "Nfuraha", "Nsiri",
              "Nsonga", "Ngawanyika", "Npendeza", "Nburudisha", "Nanguka",
              "Nkali", "Nmbali", "Nkale", "Nhuzuni", "Nzuri",
              "Nraruka", "Nadhimu", "Njua", "Ngiza", "Nwima",
              "Nmpole", "Namani", "Nvurugu", "Nkali", "Npana",
              "Nwazi", "Nfungwa", "Nbapa", "Ngiza", "Nmilele",
              "Ntulivu", "Nkubwa", "Nzuri", "Nrefu", "Nkelele",
              "Nbaridi", "Njoto", "Nhatari", "Npumbaza", "Nchonga",
              "Nsafi", "Njasiri", "Nmilele", "Nganda", "Nkufa"]

adj_sua_c11 = ["Uzuri", "Ueupe", "Utakatifu", "Unywele", "Uficho",
               "Udogo", "Udogo", "Uzee", "Ubinguni", "Ukubwa",
               "Urefu", "Udogo", "Ukubwa", "Usafi", "Ubayo",
               "Uekundu", "Ubuluu", "Ukijani", "Unjano", "Ueusi",
               "Udhahabu", "Utulivu", "Ukelele", "Ukavu", "Upotea",
               "Urefu", "Uangavu", "Uzito", "Ufuraha", "Usiri",
               "Usonga", "Ugawanyika", "Upendeza", "Uburudisha", "Uanguka",
               "Ukali", "Umbali", "Ukale", "Uhuzuni", "Uzuri",
               "Uraruka", "Uadhimu", "Ujua", "Ugiza", "Uwima",
               "Upole", "Uamani", "Uvurugu", "Ukali", "Upana",
               "Uwazi", "Ufungwa", "Ubapa", "Ugiza", "Umilele",
               "Utulivu", "Ukubwa", "Uzuri", "Urefu", "Ukelele",
               "Ubaridi", "Ujoto", "Uhatari", "Upumbaza", "Uchonga",
               "Usafi", "Ujasiri", "Umilele", "Uganda", "Ukufa"]

# ==========================   NOMES DAS PROV√çNCIAS EM PORTUGU√äS   ==========================#

nouns_por_mas = ["Rio", "Campo", "C√©u", "P√¢ntano", "lago", "Solo",
                 "Vento", "Penhasco", "Homem", "Ar", "Fogo", "P√°ssaro",
                 "Morro", "Riacho", "Lobo", "Esp√≠rito", "Soldado",
                 "Vale", "Monte", "Dia", "Pico", "Ref√∫gio",
                 "Sinal", "Arbusto", "Sacerdote", "Terreno", "Gramado",
                 "Feiti√ßo", "Jardim"]

nouns_por_fem = ["Pedra", "Montanha", "Terra", "Casa", "Caverna",
                 "Estrela", "Nascente", "Floresta", "Areia",
                 "Chuva", "Escarpa", "Fonte", "√Ågua", "Gruta",
                 "Folha", "Trilha", "Noite", "Fruta", "Serpente",
                 "Vila", "Cabana", "Campina", "Luz", "Barra",
                 "Serra", "Cidade", "Mata", "Lagoa", "Estrada",
                 "Capela", "Ponte", "Cova", "Vista"]

adj_por_mas = ["Bom", "Branco", "Sagrado", "Quebrado", "Escondido",
               "Longo", "Pequeno", "Velho", "Paradis√≠aco", "Grande",
               "Alto", "Pristino", "Mau",
               "Vermelho", "Azul", "Verde", "Amarelo", "Preto",
               "Dourado", "Calmo", "Seco", "Perdido", "Bravio",
               "Profundo", "Brilhante", "Pesado", "Alegre", "Misterioso",
               "Petrificado", "Dividido", "Agrad√°vel", "Cadente",
               "Afiado", "Distante", "Antigo", "Triste", "Bonito",
               "Eterno", "Encantado", "Ensolarado", "Frio", "√çngrime",
               "Gentil", "Pac√≠fico", "Turbulento", "Morto", "Amplo",
               "Aberto", "Fechado", "Plano", "Escuro", "Quente",
               "Sereno", "Gigante", "Puro"]

adj_por_fem = ["Boa", "Branca", "Sagrada", "Quebrada", "Escondida",
               "Longa", "Pequena", "Velha", "Paradis√≠aca", "Grande",
               "Alta", "Pristina", "M√°",
               "Vermelha", "Azul", "Verde", "Amarela", "Preta",
               "Dourada", "Calma", "Seca", "Perdida", "Bravia",
               "Profunda", "Brilhante", "Pesada", "Alegre", "Misteriosa",
               "Petrificada", "Dividida", "Agrad√°vel", "Cadente",
               "Afiada", "Distante", "Antiga", "Triste", "Bonita",
               "Eterna", "Encantada", "Ensolarada", "Fria", "√çngrime",
               "Gentil", "Pac√≠fica", "Turbulenta", "Morta", "Ampla",
               "Aberta", "Fechada", "Plana", "Escura", "Quente",
               "Serena", "Gigante", "Pura"]

# ==========================   NOMES DAS PROV√çNCIAS EM TELUGU   ==========================#

adj_tel = ["Manchi", "Telupu", "PavitraMaina", "Virigina", "Dachina",
           "Podavaine", "Chinna", "Pata", "Devatal", "Pedda",
           "Ettaina", "Pristine", "Chedu",
           "Erupu", "Neelam", "Aakupacha", "Pasupu", "Nalupu",
           "Bangaru", "Uppika", "Poyina", "Dhairyanga",
           "Lothaina", "Prakasince", "Bharinga", "AnandakarMaina", "RahasyaMaina",
           "Oragina", "VibhajinchaBadina", "AahladaKaramaina", "Kooling", "Pade",
           "Padunaine", "Dooramaina", "Praachina", "Vipulu", "Andamaina",
           "ShashvataMaina", "MantramugdhaMaina", "EndaKaala", "Challani", "Nitaaaruga",
           "Susaadyam", "Shantamaina", "KuduPulaaga", "Chanipoina", "VistaraMaina",
           "Terichina", "Moochina", "SamataTa", "Cheekati", "VechaNani",
           "Telikapaatia", "Daitamt", "Parishuddha"]

nouns_tel = ["Parvatam", "Nakshatram", "Vasanta", "Sarassu",
             "Varsham", "Uuta", "Paadam", "Phalam",
             "Pakshi", "Grama", "Konda", "Vaagu", "Cheruvu",
             "Meda", "Metta", "EluguBanti",
             "Vampu", "Sainikudu", "Gutta", "Pattanam", "Agni",
             "Shikharam", "Chenulo", "Puli", "Poojari",
             "Raayi", "Nadi", "Guha", "Isuka", "Matti",
             "Raatri", "Paamu", "Loya", "Adavi",
             "Poda", "Thota", "Kaanti",
             "Bhumi", "Drushti", "Gali",
             "Illu", "Aakasham", "Neeru", "Dinam", "Kunta",
             "Pullu", "Aaka", "Ashrayam", "Suchakam", "Palakame",
             "Shaapam", "Podavu", "Nagaram", "Atma"]

# ==========================   NOMES DAS PROV√çNCIAS EM BENGALI   ==========================#

adj_ben = ["Bhalo", "Shada", "Pabitra", "Bhanga", "Lukiye",
               "Lomba", "Puraono", "Swargiya", "Boro",
               "Ucca", "Chhoto", "Nirmal", "Kharaap",
               "Lal", "Neel", "Shobuj", "Holud", "Kalo",
               "Swarna", "Shanto", "Shukna", "Hariye", "Sahasik",
               "Gahiro", "Ujjwal", "Bhari", "Anandomoy", "Rahasyojano",
               "Kothin", "Bhenge", "Sundor", "Shitala",
               "Tikto", "Duro", "Prachin", "Dukho",
               "Chironton", "Mohaishwarya", "Roudro", "Thanda", "Khar",
               "Komal", "Shanti", "Ashanto", "Mrito", "Chowra",
               "Khola", "Bondho", "Andhakar", "Garam",
               "Santo", "Bipul"]

nouns_ben = ["Pahar", "Nodi", "Bhumi", "Bari",
                 "Math", "Guhar", "Akash", "Tara", "Jheel",
                 "Jhorna", "Bon", "Hrida", "Balu", "Mati",
                 "Hawa", "Brishti", "Ku", "Fowara", "Jol",
                 "Manush", "Udyan", "Bayu", "Agun", "Pata",
                 "Potht", "Raat", "Fol", "Pakhi", "Saanp",
                 "Gram", "Tila", "Chhara", "Jhupi",
                 "Atma", "Aalo", "Shar",
                 "Upoth", "Tapaswi",
                 "Upottok", "Teerthashala", "Nagor",
                 "Raka", "Din", "Parbat",
                 "Chinho", "Jhop",
                 "Pukure", "Rasta", "Palakame", "Nagar",
                 "Setu", "Pujari", "Shoshan", "Shopath",
                 "Drishti", "Ghass"]

# ==========================   NOMES DAS PROV√çNCIAS EM JAPON√äS   ==========================#

adj_jap = [
    "Yoi", "Shiroi", "Shinseina", "Kowareta", "Kakushita",
    "Nagai", "Chiisana", "Furui", "Ten no", "Ookii",
    "Takai", "Chiisana", "Ookii", "Kiyoi", "Warui",
    "Akai", "Aoi", "Midori no", "Kiiroi", "Kuroi",
    "Kin'iro no", "Odayaka na", "Kawaita", "Ushinawareta", "Yuukan na",
    "Fukai", "Akarui", "Omoi", "Ureshii", "Nazo no",
    "Ishika shita", "Wakareta", "Tanoshii", "Reitou shita", "Ochiru",
    "Surudoi", "Tooi", "Kodai no", "Kanashii", "Utsukushii",
    "Eien no", "Maho ni kakerareta", "Hareta", "Samui", "Kyu",
    "Yasashii", "Heiwa na", "Arasoi no", "Shinda", "Hiroi",
    "Akeru", "Shimeru", "Taira na", "Kurai", "Atatakai",
    "Shizuka na", "Kyo na", "Junsei"
]

nouns_jap = [
    "Iwa", "Yama", "Kawa", "Chi", "Ie",
    "Hatake", "Horaana", "Sora", "Hoshi", "Numachi",
    "Izumi", "Mori", "Mizuumi", "Suna", "Tsuchi",
    "Kaze", "Ame", "Gake", "Izumi", "Mizu",
    "Otoko", "Hayashi", "Kuki", "Hi", "Ha",
    "Michi", "Yoru", "Kudamono", "Tori", "Hebi",
    "Machi", "Oka", "Kawa", "Koya", "No",
    "Ookami", "Seirei", "Hikari", "Saka", "Heishi",
    "Tani", "Tsuka", "Machi",
    "Hayashi", "Mine", "Hi", "Takane",
    "Hinansho", "Hyoushiki", "Shigeru",
    "Ike", "Michi", "Kyokai", "Toshi",
    "Hashi", "Shisai", "Haka", "Noroi",
    "Ji", "Keshiki", "Shiba"
]

# ==========================   NOMES DAS PROV√çNCIAS EM MARATHI   ==========================#

adj_mar_mas = [
    "Changla", "Pandhra", "Pavitra", "Tuta", "Laplele",
    "Lamb", "Chhota", "Juna", "Swargiya", "Motha",
    "Uccha", "Chhota", "Motha", "Nirmal", "Vait",
    "Lal", "Neela", "Hirva", "Pivla", "Kala",
    "Soneri", "Shanta", "Sukha", "Haravlela", "Shur",
    "Khola", "Tej", "Jadh", "Anandi", "Gudh",
    "Shila", "Vibhag", "Sukhada", "Shital", "Padnara",
    "Tikshna", "Durcha", "Prachin", "Dukhi", "Sundar",
    "Anadi", "Jadui", "Divasli", "Thanda", "Kadar",
    "Mild", "Shanta", "Gunj", "Mela", "Vishal",
    "Ughad", "Band", "Sad", "Andhara", "Garam",
    "Sthir", "Bhim", "Shuddha"
]

adj_mar_fem = [
    "Changli", "Pandhri", "Pavitra", "Tuti", "Lapleleli",
    "Lambi", "Chhoti", "Juni", "Swargiya", "Mothi",
    "Ucchi", "Chhoti", "Mothi", "Nirmal", "Vait",
    "Lali", "Neeli", "Hiravi", "Pivli", "Kali",
    "Soneri", "Shanti", "Sukhi", "Haravleli", "Shur",
    "Khola", "Tej", "Jadhi", "Anandi", "Gudh",
    "Shila", "Vibhag", "Sukhada", "Shital", "Padnari",
    "Tikshni", "Durchi", "Prachin", "Dukhi", "Sundar",
    "Anadi", "Jadui", "Divasli", "Thandi", "Kadak",
    "Mild", "Shanti", "Gunji", "Meli", "Vishal",
    "Ughadi", "Band", "Sad", "Andhari", "Garam",
    "Sthir", "Bhim", "Shuddha"
]

adj_mar_neu = [
    "Changle", "Pandhre", "Pavitra", "Tute", "Laplelele",
    "Lambe", "Chhote", "June", "Swargiya", "Mothe",
    "Ucche", "Chhote", "Mothe", "Nirmal", "Vait",
    "Lale", "Neel", "Hirve", "Pivle", "Kale",
    "Soneri", "Shant", "Sukhe", "Haravlele", "Shur",
    "Khol", "Tej", "Jadh", "Anand", "Gudh",
    "Shil", "Vibhag", "Sukhada", "Shital", "Padnar",
    "Tikshne", "Durcha", "Prachin", "Dukh", "Sundar",
    "Anad", "Jadui", "Divasle", "Thand", "Kadak",
    "Mild", "Shant", "Gunje", "Mel", "Vishal",
    "Ughad", "Band", "Sad", "Andhar", "Garam",
    "Sthir", "Bhim", "Shuddha"
]

nouns_mar_mas = [
    "Khadak", "Parvat", "Ghar", "Shet", "Aakash",
    "Jangal", "Vara", "Paus", "Kada", "Purush",
    "Van", "Pan", "Phal", "Pakshi", "Saap",
    "Gav", "Dongar", "Landga", "Atma", "Sainik",
    "Khor", "Shahar", "Pul", "Pujari", "Shap",
    "Drushya", "Gavat"
]

nouns_mar_fem = [
    "Nadi", "Zamin", "Guha", "Tara", "Chikhal",
    "Jhara", "Valu", "Mati", "Hawa", "Aag",
    "Paulwat", "Ratra", "Zhopdi", "Kuran",
    "Dhig", "Chinha", "Zhudup"
]

nouns_mar_neu = [
    "Karanje", "Pani", "Talav", "Shikhar", "Aashray"
]

# ==========================   NOMES DAS PROV√çNCIAS EM COREANO   ==========================#

adj_cor = [
    "Joeun", "Hayan", "Shinseonghan", "Buseojin", "Sumgyeojin",
    "Gin", "Jageun", "Oraedoen", "Cheonsang-ui", "Keun",
    "Nop-eun", "Jageun", "Keun", "Wonsh-ui", "Nappeun",
    "Ppalgan", "Paran", "Chorok-ui", "Noran", "Geom-eun",
    "Geumsaeg-ui", "Pyeong-onhan", "Geonjohan", "Il-eobeolin", "Yong-gamhan",
    "Gip-eun", "Balgeun", "Mugeoun", "Jeulgeoun", "Shinbihan",
    "Seoghwadwin", "Bunyeol-dwin", "Jeulgeoun", "Siwonhan", "Tteoreojineun",
    "Nalkaroun", "Meolli Inneun", "Godae-ui", "Seulpeun", "Areumdaun",
    "Yeong-wonhan", "Mabeob-e Geollin", "Malgeun", "Chuun", "Gapareun",
    "Budeureoun", "Pyeonghwaro-un", "Gyeokdongjeogin", "Jukeun", "Neolbeun",
    "Yeollin", "Dat-eun", "Pyeongpyeonghan", "Eoduun", "Ttatteushan",
    "Goyohan", "Geodaehan", "Sunsuhan"
]

nouns_cor = [
    "Bawi", "San", "Gang", "Jigu", "Jip",
    "Bat", "Donggul", "Haneul", "Byeol", "Neup",
    "Saem", "Sup", "Ho", "Morae", "To",
    "Baram", "Bi", "Jeolbyeok", "Sup", "Mul",
    "Namja", "Sogeum", "Gonggi", "Bul", "Ip",
    "Gil", "Bam", "Gwail", "Sae", "Baem",
    "Ma-eul", "Eondeok", "Cheon", "Jjokbang", "Pyeongan",
    "Neukdae", "Yeonghon", "Bit", "Gyeon", "Gundae",
    "Gok", "Hwasal", "Doshi",
    "Sanrim", "Gogae", "Nal", "Jeomjeong",
    "Bigae", "Pyo", "Namuguri",
    "Mot", "Gildo", "Seongdang", "Dosi",
    "Dari", "Seongnyun", "Myoji", "Ju",
    "Bam", "Gyeong", "Pul"
]

# ==========================   NOMES DAS PROV√çNCIAS EM ITALIANO   ==========================#

adj_ita_mas = [
    "Buono", "Bianco", "Sacro", "Rotto", "Nascosto",
    "Lungo", "Vecchio", "Celeste", "Grande",
    "Alto", "Piccolo", "Puro", "Cattivo",
    "Rosso", "Blu", "Verde", "Giallo", "Nero",
    "Dorato", "Calmo", "Secco", "Perso", "Coraggioso",
    "Profondo", "Luminoso", "Pesante", "Gioioso", "Misterioso",
    "Pietrificato", "Diviso", "Piacevole", "Rinfrescante", "Cadente",
    "Affilato", "Distante", "Antico", "Triste", "Bello",
    "Eterno", "Incantato", "Soleggiato", "Freddo", "Ripido",
    "Gentile", "Pacifico", "Turbulento", "Morto", "Ampio",
    "Aperto", "Chiuso", "Piatto", "Scuro", "Caldo",
    "Sereno", "Gigantesco", "Puro"
]

adj_ita_fem = [
    "Buona", "Bianca", "Sacra", "Rotta", "Nascosta",
    "Lunga", "Piccola", "Vecchia", "Celeste",
    "Alta", "Grande", "Pura", "Cattiva",
    "Rossa", "Blu", "Verde", "Gialla", "Nera",
    "Dorata", "Calma", "Secca", "Persa", "Coraggiosa",
    "Profonda", "Luminosa", "Pesante", "Gioiosa", "Misteriosa",
    "Pietrificata", "Divisa", "Piacevole", "Rinfrescante", "Cadente",
    "Affilata", "Distante", "Antica", "Triste", "Bella",
    "Eterna", "Incantata", "Soleggiata", "Fredda", "Ripida",
    "Gentile", "Pacifica", "Turbulenta", "Morta", "Ampia",
    "Aperta", "Chiusa", "Piatta", "Scura", "Calda",
    "Serena", "Gigantesca", "Pura"
]

nouns_ita_mas = [
    "Fiume", "Campo", "Cielo", "Lago", "Vento",
    "Uomo", "Boschetto", "Fuoco", "Sentiero", "Uccello",
    "Ruscello", "Prato", "Lupo", "Spirito",
    "Pendio", "Soldato", "Tumulo", "Bosco", "Giorno",
    "Rifugio", "Segno", "Cespuglio", "Stagno",
    "Sacerdote", "Terreno"
]

nouns_ita_fem = [
    "Roccia", "Montagna", "Terra", "Casa",
    "Caverna", "Stella", "Palude", "Sorgente",
    "Foresta", "Sabbia", "Pioggia", "Scogliera",
    "Fontana", "Acqua", "Aria", "Foglia", "Ponte",
    "Notte", "Frutta", "Cittadina", "Collina",
    "Capanna", "Luce", "Valle", "Citt√†", "Serpente",
    "Cresta", "Cima", "Strada", "Cappella",
    "Tomba", "Maledizione", "Vista", "Erba"
]

ita_bags = [
    "Buono", "Grande", "Piccolo", "Vecchio", "Bello",
    "Buona", "Piccola", "Vecchia", "Bella"
]

# ==========================   NOMES DAS PROV√çNCIAS EM ALEM√ÉO   ==========================#

adj_ale_mas = [
    "Guter", "Wei√üer", "Heiliger", "Gebrochener", "Versteckter",
    "Langer", "Kleiner", "Alter", "Himmlischer", "Gro√üer",
    "Hoher", "Kleiner", "Gro√üer", "Makelloser", "Schlechter",
    "Roter", "Blauer", "Gr√ºner", "Gelber", "Schwarzer",
    "Goldener", "Ruhiger", "Trockener", "Verlorener", "Tapferer",
    "Tiefer", "Heller", "Schwerer", "Fr√∂hlicher", "Geheimnisvoller",
    "Versteinerter", "Geteilter", "Angenehmer", "Erfrischender", "Fallender",
    "Scharfer", "Ferns", "Alter", "Trauriger", "Sch√∂ner",
    "Ewiger", "Verzauberter", "Sonniger", "Kalter", "Steiler",
    "Sanfter", "Friedlicher", "St√ºrmischer", "Toter", "Weiter",
    "Offener", "Geschlossener", "Flacher", "Dunkler", "Warmer",
    "Heiterer", "Gigantischer", "Reiner"
]

adj_ale_fem = [
    "Gute", "Wei√üe", "Heilige", "Gebrochene", "Versteckte",
    "Lange", "Kleine", "Alte", "Himmlische", "Gro√üe",
    "Hohe", "Kleine", "Gro√üe", "Makellose", "Schlechte",
    "Rote", "Blaue", "Gr√ºne", "Gelbe", "Schwarze",
    "Goldene", "Ruhige", "Trockene", "Verlorene", "Tapfere",
    "Tiefe", "Helle", "Schwere", "Fr√∂hliche", "Geheimnisvolle",
    "Versteinerte", "Geteilte", "Angenehme", "Erfrischende", "Fallende",
    "Scharfe", "Ferne", "Alte", "Traurige", "Sch√∂ne",
    "Ewige", "Verzauberte", "Sonnige", "Kalte", "Steile",
    "Sanfte", "Friedliche", "St√ºrmische", "Tote", "Weite",
    "Offene", "Geschlossene", "Flache", "Dunkle", "Warme",
    "Heitere", "Gigantische", "Reine"
]

adj_ale_neu = [
    "Gutes", "Wei√ües", "Heiliges", "Gebrochenes", "Verstecktes",
    "Langes", "Kleines", "Altes", "Himmlisches", "Gro√ües",
    "Hohes", "Kleines", "Gro√ües", "Makelloses", "Schlechtes",
    "Rotes", "Blaues", "Gr√ºnes", "Gelbes", "Schwarzes",
    "Goldenes", "Ruhiges", "Trockenes", "Verlorenes", "Tapferes",
    "Tiefes", "Helles", "Schweres", "Fr√∂hliches", "Geheimnisvolles",
    "Versteinertes", "Geteiltes", "Angenehmes", "Erfrischendes", "Fallendes",
    "Scharfes", "Fernes", "Altes", "Trauriges", "Sch√∂nes",
    "Ewiges", "Verzaubertes", "Sonniges", "Kaltes", "Steiles",
    "Sanftes", "Friedliches", "St√ºrmisches", "Totes", "Weites",
    "Offenes", "Geschlossenes", "Flaches", "Dunkles", "Warmes",
    "Heiteres", "Gigantisches", "Reines"
]

nouns_ale_mas = [
    "Felsen", "Berg", "Fluss", "Wind", "Regen",
    "Brunnen", "Mann", "Hain", "Feuer", "Pfad",
    "Vogel", "Bach", "Wolf", "Geist",
    "Hang", "Soldat", "Grat", "Tag",
    "Gipfel", "Busch", "Teich", "Priester",
    "Fluch", "Boden"
]

nouns_ale_fem = [
    "H√∂hle", "Klippe", "Quelle", "Wiese", "Luft",
    "Nacht", "Frucht", "Schlange", "Stadt", "Stra√üe",
    "Kapelle", "Br√ºcke", "Zuflucht", "Aussicht",
    "Erde"
]

nouns_ale_neu = [
    "Land", "Haus", "Feld", "Himmel", "Stern",
    "Sumpf", "See", "Sand", "Wasser", "Blatt",
    "Licht", "Tal", "Zeichen",
    "Grab", "Gras"
]

# ==========================   CONSTRUIR FUN√á√ïES DOS NOMES DAS CAPITAIS E PROV√çNCIAS   ==========================#

def formar_nome_chines(adj_chi, nouns_chi):
    adj = random.choice(adj_chi)
    noun = random.choice(nouns_chi)
    nome = adj + " " + noun
    return nome


def formar_nome_indonesio(nouns_ind, adj_ind):
    noun = random.choice(nouns_ind)
    adj = random.choice(adj_ind)
    nome = noun + " " + adj
    return nome


def formar_nome_vietnamita(nouns_viet, adj_viet):
    noun = random.choice(nouns_viet)
    adj = random.choice(adj_viet)
    nome = noun + " " + adj
    return nome


def formar_nome_hindi(adj_hin_mas, adj_hin_fem, nouns_hin_mas, nouns_hin_fem):
    lista_combinada = nouns_hin_mas + nouns_hin_fem
    noun = random.choice(lista_combinada)
    if noun in nouns_hin_mas:
        adj = random.choice(adj_hin_mas)
    else:
        adj = random.choice(adj_hin_fem)
    nome = adj + " " + noun
    return nome


def formar_nome_farsi(nouns_far, adj_far):
    noun = random.choice(nouns_far)
    adj = random.choice(adj_far)
    nome = noun + " " + adj
    return nome


def formar_nome_arabe(nouns_ara_mas, nouns_ara_fem, adj_ara_mas, adj_ara_fem):
    lista_combinada = nouns_ara_mas + nouns_ara_fem
    noun = random.choice(lista_combinada)
    if noun in nouns_ara_mas:
        adj = random.choice(adj_ara_mas)
    else:
        adj = random.choice(adj_ara_fem)
    nome = noun + " " + adj
    return nome


def formar_nome_russo(adj_rus_mas, adj_rus_fem, adj_rus_neu, nouns_rus_mas, nouns_rus_fem, nouns_rus_neu):
    lista_combinada = nouns_rus_mas + nouns_rus_fem + nouns_rus_neu
    noun = random.choice(lista_combinada)
    if noun in nouns_rus_mas:
        adj = random.choice(adj_rus_mas)
    elif noun in nouns_rus_fem:
        adj = random.choice(adj_rus_fem)
    else:
        adj = random.choice(adj_rus_neu)
    nome = adj + " " + noun
    return nome


def formar_nome_suaili(nouns_sua_c1, nouns_sua_c3, nouns_sua_c5, nouns_sua_c7, nouns_sua_c9, nouns_sua_c11, adj_sua_c1,
                       adj_sua_c3, adj_sua_c5, adj_sua_c7, adj_sua_c9, adj_sua_c11):
    lista_combinada = nouns_sua_c1 + nouns_sua_c3 + nouns_sua_c5 + nouns_sua_c7 + nouns_sua_c9 + nouns_sua_c11
    noun = random.choice(lista_combinada)
    if noun in nouns_sua_c1:
        adj = random.choice(adj_sua_c1)
    elif noun in nouns_sua_c3:
        adj = random.choice(adj_sua_c3)
    elif noun in nouns_sua_c5:
        adj = random.choice(adj_sua_c5)
    elif noun in nouns_sua_c7:
        adj = random.choice(adj_sua_c7)
    elif noun in nouns_sua_c9:
        adj = random.choice(adj_sua_c9)
    else:
        adj = random.choice(adj_sua_c11)
    nome = noun + " " + adj
    return nome


def formar_nome_turco(adj_tur, nouns_tur):
    adj = random.choice(adj_tur)
    noun = random.choice(nouns_tur)
    nome = adj + " " + noun
    return nome


def formar_nome_frances(adj_fra_mas, adj_fra_fem, bags, nouns_fra_mas, nouns_fra_fem):
    lista_combinada = nouns_fra_mas + nouns_fra_fem
    noun = random.choice(lista_combinada)
    if noun in nouns_fra_mas:
        adj = random.choice(adj_fra_mas)
    else:
        adj = random.choice(adj_fra_fem)
    if adj in bags:
        nome = adj + " " + noun
    else:
        nome = noun + " " + adj
    return nome


def formar_nome_hausa(nouns_hau, adj_hau):
    noun = random.choice(nouns_hau)
    adj = random.choice(adj_hau)
    nome = noun + " " + adj
    return nome


def formar_nome_ingles(adj_ing, nouns_ing):
    adj = random.choice(adj_ing)
    noun = random.choice(nouns_ing)
    nome = adj + " " + noun
    return nome


def formar_nome_espanhol(nouns_esp_mas, nouns_esp_fem, adj_esp_mas, adj_esp_fem):
    lista_combinada = nouns_esp_mas + nouns_esp_fem
    noun = random.choice(lista_combinada)
    if noun in nouns_esp_mas:
        adj = random.choice(adj_esp_mas)
    else:
        adj = random.choice(adj_esp_fem)
    nome = noun + " " + adj
    return nome

def formar_nome_portugues(nouns_por_mas, nouns_por_fem, adj_por_mas, adj_por_fem):
    lista_combinada = nouns_por_mas + nouns_por_fem
    noun = random.choice(lista_combinada)
    if noun in nouns_por_mas:
        adj = random.choice(adj_por_mas)
    else:
        adj = random.choice(adj_por_fem)
    nome = noun + " " + adj
    return nome

def formar_nome_telugu(adj_tel, nouns_tel):
    adj = random.choice(adj_tel)
    noun = random.choice(nouns_tel)
    nome = adj + " " + noun
    return nome

def formar_nome_bengali(adj_ben, nouns_ben):
    adj = random.choice(adj_ben)
    noun = random.choice(nouns_ben)
    nome = adj + " " + noun
    return nome

def formar_nome_japones(adj_jap, nouns_jap):
    adj = random.choice(adj_jap)
    noun = random.choice(nouns_jap)
    nome = adj + " " + noun
    return nome

def formar_nome_marathi(adj_mar_mas, adj_mar_fem, adj_mar_neu, nouns_mar_mas, nouns_mar_fem, nouns_mar_neu):
    lista_combinada = nouns_mar_mas + nouns_mar_fem + nouns_mar_neu
    noun = random.choice(lista_combinada)
    if noun in nouns_mar_mas:
        adj = random.choice(adj_mar_mas)
    elif noun in nouns_mar_fem:
        adj = random.choice(adj_mar_fem)
    else:
        adj = random.choice(adj_mar_neu)
    nome = adj + " " + noun
    return nome

def formar_nome_coreano(adj_cor, nouns_cor):
    adj = random.choice(adj_cor)
    noun = random.choice(nouns_cor)
    nome = adj + " " + noun
    return nome

def formar_nome_italiano(nouns_ita_mas, nouns_ita_fem, adj_ita_mas, adj_ita_fem):
    lista_combinada = nouns_ita_mas + nouns_ita_fem
    noun = random.choice(lista_combinada)
    if noun in nouns_ita_mas:
        adj = random.choice(adj_ita_mas)
    else:
        adj = random.choice(adj_ita_fem)
    if adj in ita_bags:
        nome = adj + " " + noun
    else:
        nome = noun + " " + adj
    return nome

def formar_nome_alemao(adj_ale_mas, adj_ale_fem, adj_ale_neu, nouns_ale_mas, nouns_ale_fem, nouns_ale_neu):
    lista_combinada = nouns_ale_mas + nouns_ale_fem + nouns_ale_neu
    noun = random.choice(lista_combinada)
    if noun in nouns_ale_mas:
        adj = random.choice(adj_ale_mas)
    elif noun in nouns_ale_fem:
        adj = random.choice(adj_ale_fem)
    else:
        adj = random.choice(adj_ale_neu)
    nome = adj + " " + noun
    return nome

def formar_nome_wu(adj_wu, nouns_wu):
    adj = random.choice(adj_wu)
    noun = random.choice(nouns_wu)
    nome = adj + " " + noun
    return nome

######################################################################################################################

def formar_nome(cultura):
    if cultura == "Chinese":
        return formar_nome_chines(adj_chi, nouns_chi)
    elif cultura == "Indonesian":
        return formar_nome_indonesio(nouns_ind, adj_ind)
    elif cultura == "Vietnamese":
        return formar_nome_vietnamita(nouns_viet, adj_viet)
    elif cultura == "Indian":
        return formar_nome_hindi(adj_hin_mas, adj_hin_fem, nouns_hin_mas, nouns_hin_fem)
    elif cultura == "Persian":
        return formar_nome_farsi(nouns_far, adj_far)
    elif cultura == "Arabic":
        return formar_nome_arabe(nouns_ara_mas, nouns_ara_fem, adj_ara_mas, adj_ara_fem)
    elif cultura == "Russian":
        return formar_nome_russo(adj_rus_mas, adj_rus_fem, adj_rus_neu, nouns_rus_mas, nouns_rus_fem, nouns_rus_neu)
    elif cultura == "Swahili":
        return formar_nome_suaili(
            nouns_sua_c1, nouns_sua_c3, nouns_sua_c5,
            nouns_sua_c7, nouns_sua_c9, nouns_sua_c11,
            adj_sua_c1, adj_sua_c3, adj_sua_c5,
            adj_sua_c7, adj_sua_c9, adj_sua_c11
        )
    elif cultura == "Turkish":
        return formar_nome_turco(adj_tur, nouns_tur)
    elif cultura == "French":
        return formar_nome_frances(adj_fra_mas, adj_fra_fem, bags, nouns_fra_mas, nouns_fra_fem)
    elif cultura == "Hausa":
        return formar_nome_hausa(nouns_hau, adj_hau)
    elif cultura == "English":
        return formar_nome_ingles(adj_ing, nouns_ing)
    elif cultura == "Portuguese":
        return formar_nome_portugues(nouns_por_mas, nouns_por_fem, adj_por_mas, adj_por_fem)
    elif cultura == "Telugu":
        return formar_nome_telugu(adj_tel, nouns_tel)
    elif cultura == "Bengali":
        return formar_nome_bengali(adj_ben, nouns_ben)
    elif cultura == "Japanese":
        return formar_nome_japones(adj_jap, nouns_jap)
    elif cultura == "Marathi":
        return formar_nome_marathi(adj_mar_mas, adj_mar_fem, adj_mar_neu, nouns_mar_mas, nouns_mar_fem, nouns_mar_neu)
    elif cultura == "Korean":
        return formar_nome_coreano(adj_cor, nouns_cor)
    elif cultura == "Italian":
        return formar_nome_italiano(nouns_ita_mas, nouns_ita_fem, adj_ita_mas, adj_ita_fem)
    elif cultura == "German":
        return formar_nome_alemao(adj_ale_mas, adj_ale_fem, adj_ale_neu, nouns_ale_mas, nouns_ale_fem, nouns_ale_neu)
    elif cultura == "Wu":
        return formar_nome_wu(adj_wu, nouns_wu)
    elif cultura == "Yue":
        return formar_nome_wu(adj_yue, nouns_yue)
    elif cultura == "Min":
        return formar_nome_wu(adj_min, nouns_min)
    else:
        return formar_nome_espanhol(nouns_esp_mas, nouns_esp_fem, adj_esp_mas, adj_esp_fem)


================================================================================
üìÑ shared/civilization.py
================================================================================
import random
from shared.flags import bandeira

class Civilizacao:
    def __init__(self, ref, indice, nome, player=False, ponto_inicial=None):
        self.player = player
        self.nome = nome
        self.cultura = ref.culturas[indice % len(ref.culturas)]
        self.cor = ref.civs_cores[self.nome]
        self.modalidade_bandeira = random.randint(0, 82)
        self.cores_bandeira = bandeira(self.nome, self.modalidade_bandeira)
        self.ponto_inicial = ponto_inicial
        self.provincias = []
        self.unidades = []

================================================================================
üìÑ shared/province.py
================================================================================
from shared.naming import formar_nome

class Provincia:
    def __init__(self, civilizacao, coordenadas):
        self.civilizacao = civilizacao
        self.coordenadas = coordenadas
        self.nome = formar_nome(civilizacao.cultura)

================================================================================
üìÑ shared/world.py
================================================================================
# shared/world.py
import random
from uuid import uuid4
from shared.references import Referencias
from shared.planet import Planeta
from shared.civilization import Civilizacao
from shared.province import Provincia


class Mundo:
    def __init__(self, fator=4, bioma='Meadow'):
        self.id_mundo = str(uuid4())
        ref = Referencias()
        random.shuffle(ref.culturas)
        lista_de_cores = list(ref.civs_cores.keys())
        random.shuffle(lista_de_cores)
        self.planeta = Planeta(fator=fator, bioma=bioma)
        self.civs = []

        # Criar civiliza√ß√µes com capitais corretas
        for i, capital in enumerate(self.planeta.capitais_players):
            nome = lista_de_cores[i % len(lista_de_cores)]
            civ = Civilizacao(ref, i, nome, True, capital)
            self.civs.append(civ)

        for i, capital in enumerate(self.planeta.capitais_neutros):
            indice = i + len(self.planeta.capitais_players)
            nome = lista_de_cores[indice % len(lista_de_cores)]
            civ = Civilizacao(ref, indice, nome, False, capital)
            self.civs.append(civ)

        # Atribuir prov√≠ncia inicial usando o ponto_inicial de cada civ
        for civ in self.civs:
            provincia = Provincia(civ, civ.ponto_inicial)
            civ.provincias.append(provincia)

================================================================================
üìÑ shared/references.py
================================================================================
class Referencias:
    def __init__(self):
        self.culturas = [
            'English', 'Chinese', 'Spanish',
            'French', 'Indian', 'Russian',
            'Vietnamese', 'Turkish', 'Arabic',
            'Indonesian', 'Persian', 'Hausa',
            'Swahili', 'Portuguese', 'Telugu',
            'Bengali', 'Japanese', 'Marathi',
            'Wu', 'Yue', 'Min',
            'Korean', 'Italian', 'German'
        ]
        self.civs_cores = {
            'Black': (16, 16, 16), 'Midnight Blue': (0, 0, 127), 'Blue': (0, 0, 255),
            'Dark Green': (0, 127, 0), 'Teal': (0, 127, 127), 'Sky Blue': (32, 127, 223),
            'Green': (0, 255, 0), 'Spring Green': (0, 255, 127), 'Cyan': (0, 223, 223),
            'Maroon': (127, 0, 0), 'Purple': (127, 0, 127), 'Violet': (127, 0, 255),
            'Olive': (127, 127, 0), 'Gray': (127, 127, 127), 'Lavender': (127, 127, 255),
            'Chartreuse': (127, 255, 0), 'Light Green': (127, 223, 127), 'Pale Cyan': (127, 255, 255),
            'Red': (234, 33, 37), 'Rose': (255, 0, 127), 'Magenta': (255, 0, 255),
            'Orange': (223, 127, 32), 'Salmon': (255, 127, 127), 'Orchid': (255, 127, 255),
            'Yellow': (255, 255, 0), 'Light Yellow': (255, 255, 127), 'White': (250, 255, 253)
        }

        self.tons_de_pele = [(245, 212, 205), (212, 160, 147), (163, 106, 95), (101, 61, 53)]
        self.tons_de_cabelo = [(209, 195, 2), (140, 106, 0), (99, 55, 26), (52, 48, 47)]

================================================================================
‚úÖ Total de 17 arquivos inclu√≠dos.
================================================================================