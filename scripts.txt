ARQUIVO DE C√ìDIGO CONSOLIDADO
Gerado em: 2025-08-18 17:58:25
Diret√≥rio: /home/mariagoreti/quan_qiu_wu_tai
Conte√∫do dos scripts principais reunidos.

================================================================================

================================================================================
üìÅ ESTRUTURA DO PROJETO
================================================================================

üìÅ .
‚îú‚îÄ‚îÄ client
‚îÇ   ‚îú‚îÄ‚îÄ components
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ icon_manager.py
‚îÇ   ‚îú‚îÄ‚îÄ resources
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ arrow-left.png
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ log-in.png
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ play.png
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ smile.png
‚îÇ   ‚îú‚îÄ‚îÄ states
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ __init__.py
‚îÇ   ‚îî‚îÄ‚îÄ main.py

================================================================================
üìÑ CONTE√öDO DOS ARQUIVOS
================================================================================

================================================================================
üìÑ client/main.py
================================================================================
# client/main.py

import sys
import os  # Para verificar o arquivo de sess√£o
import OpenGL.GL as gl
import ctypes
from PyQt6.QtWidgets import (
    QApplication, QMainWindow, QWidget, QVBoxLayout, QLabel, QPushButton, QHBoxLayout, QSizePolicy, QFrame
)
from PyQt6.QtOpenGLWidgets import QOpenGLWidget
from PyQt6.QtCore import QTimer, Qt
from PyQt6.QtGui import QSurfaceFormat, QFont

# --- Importa√ß√£o do componente modularizado ---
# Assumindo a estrutura client/components/gerenciador_icones.py
# O caminho correto, considerando a execu√ß√£o de client/main.py, √© relativo a client/
from components.icon_manager import GerenciadorIconesEsquerda


# --- Componente OpenGL ---
class MeuOpenGLWidget(QOpenGLWidget):
    """
    Widget respons√°vel pela renderiza√ß√£o OpenGL Moderna.
    """

    def __init__(self):
        super().__init__()
        self.shader_program = None
        self.VAO = None
        self.VBO = None
        # Permitir que o widget receba foco de teclado
        self.setFocusPolicy(Qt.FocusPolicy.StrongFocus)
        # Estado de login (exemplo simples)
        self.usuario_logado = self._verificar_login()

    def _verificar_login(self):
        """Verifica se o usu√°rio est√° logado (exemplo: arquivo session.txt existe)."""
        # Esta √© uma l√≥gica de placeholder. Substitua pela sua l√≥gica real.
        return os.path.exists("session.txt")  # True se existir, False caso contr√°rio

    def initializeGL(self):
        """
        Inicializado uma vez quando o contexto OpenGL √© criado.
        Aqui compilamos shaders, criamos VAOs, VBOs etc.
        """
        print("Inicializando contexto OpenGL...")
        # Define a cor de fundo padr√£o como PRETO PURO
        gl.glClearColor(0.0, 0.0, 0.0, 1.0)

        # --- Compilar Shaders para o Tri√¢ngulo ---
        vertex_shader_source = """
        #version 330 core
        layout (location = 0) in vec3 aPos;
        layout (location = 1) in vec3 aColor;
        out vec3 ourColor;
        void main()
        {
            gl_Position = vec4(aPos, 1.0);
            ourColor = aColor;
        }
        """

        fragment_shader_source = """
        #version 330 core
        in vec3 ourColor;
        out vec4 FragColor;
        void main()
        {
            FragColor = vec4(ourColor, 1.0f);
        }
        """

        # --- Compila√ß√£o e Linkagem de Shaders ---
        try:
            # Compila√ß√£o do Vertex Shader
            vertex_shader = gl.glCreateShader(gl.GL_VERTEX_SHADER)
            gl.glShaderSource(vertex_shader, vertex_shader_source)
            gl.glCompileShader(vertex_shader)
            # Verifica√ß√£o de erros no vertex shader
            success = gl.glGetShaderiv(vertex_shader, gl.GL_COMPILE_STATUS)
            if not success:
                info_log = gl.glGetShaderInfoLog(vertex_shader)
                raise RuntimeError(f"Erro ao compilar Vertex Shader:\n{info_log.decode('utf-8')}")

            # Compila√ß√£o do Fragment Shader
            fragment_shader = gl.glCreateShader(gl.GL_FRAGMENT_SHADER)
            gl.glShaderSource(fragment_shader, fragment_shader_source)
            gl.glCompileShader(fragment_shader)
            # Verifica√ß√£o de erros no fragment shader
            success = gl.glGetShaderiv(fragment_shader, gl.GL_COMPILE_STATUS)
            if not success:
                info_log = gl.glGetShaderInfoLog(fragment_shader)
                raise RuntimeError(f"Erro ao compilar Fragment Shader:\n{info_log.decode('utf-8')}")

            # Linkagem do Programa Shader
            self.shader_program = gl.glCreateProgram()
            gl.glAttachShader(self.shader_program, vertex_shader)
            gl.glAttachShader(self.shader_program, fragment_shader)
            gl.glLinkProgram(self.shader_program)
            # Verifica√ß√£o de erros no link
            success = gl.glGetProgramiv(self.shader_program, gl.GL_LINK_STATUS)
            if not success:
                info_log = gl.glGetProgramInfoLog(self.shader_program)
                raise RuntimeError(f"Erro ao linkar Programa Shader:\n{info_log.decode('utf-8')}")

            # Deletar os shaders j√° linkados
            gl.glDeleteShader(vertex_shader)
            gl.glDeleteShader(fragment_shader)

        except RuntimeError as e:
            print(f"‚ùå Erro na inicializa√ß√£o dos shaders: {e}")
            self.shader_program = None  # Indica falha
            return  # Aborta a inicializa√ß√£o da geometria se shaders falharem

        # --- Configurar VAO e VBO para um tri√¢ngulo ---
        try:
            # Dados do tri√¢ngulo (Posi√ß√£o XYZ + Cor RGB)
            triangle_data = [
                0.0, 0.5, 0.0, 1.0, 0.0, 0.0,  # V√©rtice 0: Topo (Vermelho)
                -0.5, -0.5, 0.0, 0.0, 1.0, 0.0,  # V√©rtice 1: Esquerda (Verde)
                0.5, -0.5, 0.0, 0.0, 0.0, 1.0  # V√©rtice 2: Direita (Azul)
            ]
            triangle_data = (gl.GLfloat * len(triangle_data))(*triangle_data)

            # Gerar e vincular VAO
            self.VAO = gl.glGenVertexArrays(1)
            gl.glBindVertexArray(self.VAO)

            # Gerar e vincular VBO
            self.VBO = gl.glGenBuffers(1)
            gl.glBindBuffer(gl.GL_ARRAY_BUFFER, self.VBO)
            gl.glBufferData(gl.GL_ARRAY_BUFFER, ctypes.sizeof(triangle_data), triangle_data, gl.GL_STATIC_DRAW)

            # Definir atributos de v√©rtice
            stride = 6 * ctypes.sizeof(gl.GLfloat)
            # Posi√ß√£o (location = 0)
            gl.glVertexAttribPointer(0, 3, gl.GL_FLOAT, gl.GL_FALSE, stride, ctypes.c_void_p(0))
            gl.glEnableVertexAttribArray(0)
            # Cor (location = 1)
            gl.glVertexAttribPointer(1, 3, gl.GL_FLOAT, gl.GL_FALSE, stride,
                                     ctypes.c_void_p(3 * ctypes.sizeof(gl.GLfloat)))
            gl.glEnableVertexAttribArray(1)

            # Desvincular VAO/VBO
            gl.glBindBuffer(gl.GL_ARRAY_BUFFER, 0)
            gl.glBindVertexArray(0)

            print("‚úÖ Shaders compilados e geometria do tri√¢ngulo configurada.")

        except Exception as e:
            print(f"‚ùå Erro ao configurar geometria do tri√¢ngulo: {e}")
            # Limpar shaders em caso de falha na geometria
            if self.shader_program:
                gl.glDeleteProgram(self.shader_program)
                self.shader_program = None
            self.VAO = None
            self.VBO = None

    def resizeGL(self, w, h):
        """
        Chamado sempre que o widget √© redimensionado.
        """
        print(f"Redimensionando OpenGL para {w}x{h}")
        gl.glViewport(0, 0, w, h)
        # TODO: Atualizar matriz de proje√ß√£o se necess√°rio

    def paintGL(self):
        """
        Chamado sempre que a cena OpenGL precisa ser redesenhada.
        """
        # Limpa o buffer com a cor definida em initializeGL
        gl.glClear(gl.GL_COLOR_BUFFER_BIT | gl.GL_DEPTH_BUFFER_BIT)

        # --- Desenhar o Tri√¢ngulo ---
        # Verifica se tudo foi inicializado corretamente
        if self.shader_program and self.VAO:
            try:
                gl.glUseProgram(self.shader_program)
                gl.glBindVertexArray(self.VAO)
                gl.glDrawArrays(gl.GL_TRIANGLES, 0, 3)  # Desenha 3 v√©rtices
                gl.glBindVertexArray(0)
                gl.glUseProgram(0)
            except Exception as e:
                print(f"‚ùå Erro durante a renderiza√ß√£o: {e}")
        # else:
        #     # Opcional: Desenhar algo simples se shaders/VAO falharem
        #     # Por exemplo, um fundo ligeiramente diferente ou uma mensagem de erro
        #     pass

        # TODO: Usar shaders, vincular VAOs, desenhar geometria (texto)
        # Exemplo:
        # if self.shader_program_texto and self.VAO_texto:
        #     gl.glUseProgram(self.shader_program_texto)
        #     gl.glBindVertexArray(self.VAO_texto)
        #     # ... comandos de desenho para texto ...
        #     gl.glBindVertexArray(0)
        #     gl.glUseProgram(0)


# --- Componente Janela Principal ---
class JanelaPrincipal(QMainWindow):
    """
    Janela principal da aplica√ß√£o, contendo a UI 2D e o widget OpenGL.
    Layout: Barras Superior/Inferior (5% da altura),
            Laterais (max(320px, 15% da largura)),
            √Årea Central para o conte√∫do OpenGL.
    """

    def __init__(self):
        super().__init__()
        self.setWindowTitle("Global Arena - Cliente PyQt6")

        # --- Obter dimens√µes da tela para c√°lculos ---
        screen_geometry = self.screen().availableGeometry()
        screen_width = screen_geometry.width()
        screen_height = screen_geometry.height()

        # --- Calcular dimens√µes das barras ---
        bar_height = int(screen_height * 0.05)
        sidebar_width = max(320, int(screen_width * 0.15))

        print(f"üéÆ Janela PyQt6 criada. Tela: {screen_width}x{screen_height}. "
              f"Barras H: {bar_height}px, Barras V: {sidebar_width}px")

        # --- Configura√ß√£o do Layout Central ---
        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        main_window_layout = QVBoxLayout(central_widget)
        main_window_layout.setContentsMargins(0, 0, 0, 0)
        main_window_layout.setSpacing(0)

        # --- Barra Superior ---
        self.barra_superior = self._criar_barra(bar_height, is_horizontal=True, object_name="BarraSuperior")
        layout_barra_superior = QHBoxLayout(self.barra_superior)
        layout_barra_superior.setContentsMargins(10, 5, 10, 5)
        label_status = QLabel("Status: Aguardando...")
        layout_barra_superior.addWidget(label_status)
        layout_barra_superior.addStretch()
        # --- BOT√ÉO SAIR REMOVIDO DA BARRA SUPERIOR ---

        # --- Conte√∫do Principal ---
        conteudo_principal_widget = QWidget()
        conteudo_principal_layout = QHBoxLayout(conteudo_principal_widget)
        conteudo_principal_layout.setContentsMargins(0, 0, 0, 0)
        conteudo_principal_layout.setSpacing(0)

        # --- Barra Esquerda com √çcones Interativos ---
        self.barra_esquerda = self._criar_barra(sidebar_width, is_horizontal=False, object_name="BarraEsquerda")
        self.gerenciador_icones = GerenciadorIconesEsquerda(caminho_recursos="client/resources")
        self.gerenciador_icones.icone_clicado.connect(self._ao_clicar_icone_lateral)
        layout_esquerda = QVBoxLayout(self.barra_esquerda)
        layout_esquerda.setContentsMargins(0, 0, 0, 0)
        layout_esquerda.addWidget(self.gerenciador_icones)

        # --- √Årea Central (OpenGL + Barra Direita) ---
        area_central_widget = QWidget()
        area_central_layout = QHBoxLayout(area_central_widget)
        area_central_layout.setContentsMargins(0, 0, 0, 0)
        area_central_layout.setSpacing(0)

        # --- Criar o Container para OpenGL e Overlay do T√≠tulo ---
        self.opengl_container = QWidget()
        container_layout = QVBoxLayout(self.opengl_container)
        container_layout.setContentsMargins(0, 0, 0, 0)
        container_layout.setSpacing(0)

        # --- Widget OpenGL ---
        self.opengl_widget = MeuOpenGLWidget()
        self.opengl_widget.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)

        # --- Criar o Overlay Widget para o T√≠tulo ---
        self.overlay_widget = QWidget(self.opengl_container)
        self.overlay_widget.setWindowFlags(Qt.WindowType.Widget)
        self.overlay_widget.setAttribute(Qt.WidgetAttribute.WA_TranslucentBackground)
        self.overlay_widget.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents)
        self.overlay_widget.setStyleSheet("background: transparent; border: none;")
        # Conectar o resize para manter o overlay cobrindo o container
        self.opengl_container.resizeEvent = self._on_opengl_container_resized

        # --- Layout do Overlay para o T√≠tulo e Subt√≠tulo ---
        overlay_layout = QVBoxLayout(self.overlay_widget)
        overlay_layout.setContentsMargins(0, 0, 0, 0)
        overlay_layout.setSpacing(20) # Espa√ßo entre t√≠tulo e subt√≠tulo
        overlay_layout.setAlignment(Qt.AlignmentFlag.AlignCenter)

        # --- Criar e Configurar o Label do T√≠tulo ---
        self.label_titulo = QLabel("Welcome to Global Arena")
        font_titulo = QFont()
        font_titulo.setPointSize(28)
        font_titulo.setBold(True)
        self.label_titulo.setFont(font_titulo)
        self.label_titulo.setStyleSheet("""
            color: white;
            background-color: transparent;
            border: none;
            qproperty-alignment: AlignCenter;
        """)
        self.label_titulo.setAlignment(Qt.AlignmentFlag.AlignCenter)

        # --- Criar e Configurar o Label do Subt√≠tulo ---
        self.label_subtitulo = QLabel("The Only One for non-flat-earthers")
        font_subtitulo = QFont()
        font_subtitulo.setPointSize(16)
        # font_subtitulo.setItalic(True) # Opcional
        self.label_subtitulo.setFont(font_subtitulo)
        self.label_subtitulo.setStyleSheet("""
            color: #cccccc; /* Cinza claro */
            background-color: transparent;
            border: none;
            qproperty-alignment: AlignCenter;
        """)
        self.label_subtitulo.setAlignment(Qt.AlignmentFlag.AlignCenter)

        # --- Adicionar os Labels ao Layout do Overlay ---
        overlay_layout.addWidget(self.label_titulo)
        overlay_layout.addWidget(self.label_subtitulo)

        # --- Adicionar Widgets ao Container OpenGL ---
        container_layout.addWidget(self.opengl_widget) # OpenGL no fundo
        # self.overlay_widget √© posicionado absolutamente

        # --- Barra Direita ---
        self.barra_direita = self._criar_barra(sidebar_width, is_horizontal=False, object_name="BarraDireita")
        layout_direita = QVBoxLayout(self.barra_direita)
        layout_direita.addStretch()
        banner_placeholder = QLabel("Banner\n300x600")
        banner_placeholder.setFixedSize(300, 600)
        banner_placeholder.setStyleSheet("background-color: #333; color: white; border: 1px solid gray;")
        banner_placeholder.setAlignment(Qt.AlignmentFlag.AlignCenter)
        layout_direita.addWidget(banner_placeholder, alignment=Qt.AlignmentFlag.AlignCenter)
        layout_direita.addStretch()

        # --- Adicionar widgets √† √°rea central ---
        area_central_layout.addWidget(self.opengl_container) # Adiciona o CONTAINER
        area_central_layout.addWidget(self.barra_direita)

        # --- Adicionar widgets ao conte√∫do principal ---
        conteudo_principal_layout.addWidget(self.barra_esquerda)
        conteudo_principal_layout.addWidget(area_central_widget)

        # --- Barra Inferior ---
        self.barra_inferior = self._criar_barra(bar_height, is_horizontal=True, object_name="BarraInferior")
        layout_barra_inferior = QHBoxLayout(self.barra_inferior)
        layout_barra_inferior.addWidget(QLabel("Barra Inferior"))

        # --- Adicionar todos os componentes ao layout da janela ---
        main_window_layout.addWidget(self.barra_superior)
        main_window_layout.addWidget(conteudo_principal_widget)
        main_window_layout.addWidget(self.barra_inferior)

        # --- Timer para o Loop Principal ---
        self.timer = QTimer(self)
        self.timer.timeout.connect(self.atualizar_logica)
        self.timer.start(16)  # Aproximadamente 60 FPS

        # --- Mostrar e aplicar fullscreen ---
        self.show()
        self.setWindowState(Qt.WindowState.WindowFullScreen)

    def _on_opengl_container_resized(self, event):
        """Ajusta o tamanho do overlay para cobrir o container."""
        self.overlay_widget.setGeometry(self.opengl_container.rect())
        if event:
            QWidget.resizeEvent(self.opengl_container, event)

    def _criar_barra(self, tamanho, is_horizontal, object_name="Barra"):
        """Cria um widget para representar uma barra, com estilo b√°sico."""
        barra = QFrame()
        barra.setObjectName(object_name)
        if is_horizontal:
            barra.setFixedHeight(tamanho)
        else:
            barra.setFixedWidth(tamanho)
        barra.setStyleSheet(f"""
            #{object_name} {{
                background-color: #2c3e50;
                border: 1px solid #34495e;
            }}
        """)
        return barra

    def atualizar_logica(self):
        """
        Atualiza a l√≥gica do jogo e solicita redesenho do OpenGL.
        """
        self.opengl_widget.update()

    def _ao_clicar_icone_lateral(self, identificador):
        """Lida com os cliques nos √≠cones da barra lateral esquerda."""
        print(f"üñ±Ô∏è JanelaPrincipal recebeu clique no √≠cone: {identificador}")
        if identificador == "login":
            self.on_icone_login()
        elif identificador == "play":
            self.on_icone_play()
        elif identificador == "sair":
            self.on_icone_sair()

    def on_icone_login(self):
        """A√ß√£o acionada pelo √≠cone de login."""
        print("A√ß√£o: √çcone 'Login' clicado.")

    def on_icone_play(self):
        """A√ß√£o acionada pelo √≠cone de play."""
        print("A√ß√£o: √çcone 'Play' clicado.")

    def on_icone_sair(self):
        """A√ß√£o acionada pelo √≠cone de sair."""
        print("A√ß√£o: √çcone 'Sair' clicado. Fechando aplica√ß√£o...")
        self.close()


# --- Ponto de Entrada da Aplica√ß√£o ---
def main():
    print("üéÆ Inicializando cliente gr√°fico com PyQt6...")
    app = QApplication(sys.argv)

    # Configurar o formato OpenGL padr√£o globalmente
    fmt = QSurfaceFormat()
    fmt.setVersion(3, 3)
    fmt.setProfile(QSurfaceFormat.OpenGLContextProfile.CoreProfile)
    # fmt.setDepthBufferSize(24)
    # fmt.setSamples(4)
    QSurfaceFormat.setDefaultFormat(fmt)

    try:
        janela = JanelaPrincipal()
        # janela.show() # show() j√° √© chamado dentro de __init__
        print("‚úÖ Janela principal exibida em fullscreen.")
        sys.exit(app.exec())
    except Exception as e:
        print(f"‚ùå Erro ao criar/iniciar a janela: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)


if __name__ == "__main__":
    # Cria um arquivo session.txt de placeholder para testar o √≠cone "logado"
    # with open("session.txt", "w") as f:
    #     f.write("usuario_teste_logado")
    main()

================================================================================
üìÑ client/states/__init__.py
================================================================================


================================================================================
üìÑ client/components/icon_manager.py
================================================================================
# client/components/icon_manager.py
"""Componentes para gerenciar √≠cones interativos na barra lateral esquerda."""

import os
from PyQt6.QtWidgets import QLabel, QVBoxLayout, QWidget
from PyQt6.QtCore import Qt, pyqtSignal
from PyQt6.QtGui import QPixmap, QCursor
import traceback


class IconeInterativo(QLabel):
    """
    Um QLabel que exibe uma imagem e emite um sinal quando clicado.
    """
    clicado = pyqtSignal(str)  # Sinal emitido ao ser clicado, passando um identificador

    def __init__(self, icone_path, identificador, tamanho=(64, 64), parent=None):
        """
        :param icone_path: Caminho para o arquivo PNG do √≠cone.
        :param identificador: String √∫nica para identificar este √≠cone ("login", "play", "sair").
        :param tamanho: Tupla (largura, altura) para redimensionar o √≠cone.
        :param parent: Widget pai.
        """
        super().__init__(parent)
        self.identificador = identificador
        self.tamanho = tamanho
        self.setAlignment(Qt.AlignmentFlag.AlignCenter)

        # Estilo para feedback visual (opcional)
        self.setStyleSheet("""
            IconeInterativo {
                border: 2px solid transparent; /* Borda invis√≠vel por padr√£o */
                border-radius: 5px; /* Bordas arredondadas */
            }
            IconeInterativo:hover {
                border: 2px solid #3498db; /* Borda azul ao passar o mouse */
                background-color: rgba(52, 152, 219, 30); /* Fundo azul claro transparente */
            }
        """)
        self.setCursor(QCursor(Qt.CursorShape.PointingHandCursor))  # Muda o cursor para m√£ozinha

        self.carregar_icone(icone_path)
        # Redimensionar o QLabel para o tamanho desejado
        self.setFixedSize(*self.tamanho)

    def carregar_icone(self, caminho):
        """
        Carrega e define a imagem do √≠cone.
        Inclui verifica√ß√µes detalhadas e logs para facilitar depura√ß√£o.
        """
        print(f"[DEBUG] [IconeInterativo] Tentando carregar √≠cone '{self.identificador}' de: '{caminho}'")

        # --- Verifica√ß√µes detalhadas do caminho ---
        caminho_absoluto = os.path.abspath(caminho)
        existe = os.path.exists(caminho)
        eh_arquivo = os.path.isfile(caminho) if existe else False

        print(f"[DEBUG] [IconeInterativo] Caminho absoluto resolvido: '{caminho_absoluto}'")
        print(f"[DEBUG] [IconeInterativo] os.path.exists('{caminho}') = {existe}")
        print(f"[DEBUG] [IconeInterativo] os.path.isfile('{caminho}') = {eh_arquivo}")

        # --- Determinar se o carregamento pode prosseguir ---
        pixmap = None
        if not existe:
            print(
                f"‚ö†Ô∏è [IconeInterativo] O caminho '{caminho}' N√ÉO EXISTE. Diret√≥rio de execu√ß√£o pode estar incorreto. Usando placeholder.")
        elif not eh_arquivo:
            print(
                f"‚ö†Ô∏è [IconeInterativo] O caminho '{caminho}' EXISTE, mas N√ÉO √â um arquivo (pode ser um diret√≥rio). Usando placeholder.")
        else:
            # Caminho existe e √© um arquivo, tentar carregar com QPixmap
            print(f"[DEBUG] [IconeInterativo] Caminho v√°lido, tentando QPixmap('{caminho}')...")
            try:
                pixmap = QPixmap(caminho)

                # Verificar se o carregamento foi bem-sucedido
                if pixmap.isNull():
                    print(f"‚ö†Ô∏è [IconeInterativo] QPixmap falhou ao carregar o arquivo '{caminho}'. "
                          f"O arquivo pode estar corrompido ou n√£o ser uma imagem v√°lida. Usando placeholder.")
                    pixmap = None  # For√ßar uso do placeholder
                else:
                    print(
                        f"[DEBUG] [IconeInterativo] QPixmap carregou com sucesso. Tamanho original: {pixmap.width()}x{pixmap.height()}")

            except Exception as e:
                print(f"‚ùå [IconeInterativo] Erro inesperado ao carregar QPixmap de '{caminho}': {e}")
                import traceback
                traceback.print_exc()  # Imprime o stack trace completo
                pixmap = None  # For√ßar uso do placeholder

        # --- Criar pixmap final (carregada ou placeholder) ---
        if pixmap is None:
            # Criar um pixmap de placeholder se a imagem n√£o for carregada
            pixmap = QPixmap(self.tamanho[0], self.tamanho[1])
            pixmap.fill(Qt.GlobalColor.gray)  # Cor cinza para placeholder
            print(f"[DEBUG] [IconeInterativo] Placeholder cinza criado para '{self.identificador}'.")
        else:
            # Redimensionar a pixmap carregada para o tamanho desejado
            pixmap = pixmap.scaled(
                self.tamanho[0],
                self.tamanho[1],
                Qt.AspectRatioMode.KeepAspectRatio,
                Qt.TransformationMode.SmoothTransformation
            )
            print(
                f"[DEBUG] [IconeInterativo] Pixmap (carregada) redimensionada para {self.tamanho[0]}x{self.tamanho[1]}.")

        # --- Definir a pixmap (carregada ou placeholder) no QLabel ---
        self.setPixmap(pixmap)
        print(f"[DEBUG] [IconeInterativo] Pixmap definida para o √≠cone '{self.identificador}'.")

    def mousePressEvent(self, event):
        """Sobrescreve para emitir o sinal ao ser clicado."""
        if event.button() == Qt.MouseButton.LeftButton:
            print(f"üñ±Ô∏è √çcone '{self.identificador}' clicado.")
            self.clicado.emit(self.identificador)  # Emite o sinal com o identificador
        super().mousePressEvent(event)  # Chama o m√©todo da classe base


class GerenciadorIconesEsquerda(QWidget):
    """
    Widget que cont√©m e organiza os √≠cones interativos na barra esquerda.
    """
    icone_clicado = pyqtSignal(str)  # Re-emite o sinal dos √≠cones filhos

    def __init__(self, caminho_recursos="client/resources", parent=None):
        """
        :param caminho_recursos: Caminho para a pasta com os √≠cones PNG.
        :param parent: Widget pai.
        """
        super().__init__(parent)
        self.caminho_recursos = caminho_recursos
        self.icones = {}  # Dicion√°rio para armazenar refer√™ncias aos √≠cones {identificador: IconeInterativo}
        self.TAMANHO_ICONE = (48, 48)

        # Layout vertical para os √≠cones
        layout = QVBoxLayout(self)
        layout.setContentsMargins(10, 10, 10, 10)  # Margens internas
        layout.setSpacing(20)  # Espa√ßo entre os √≠cones
        layout.setAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft)

        # --- Criar e adicionar √≠cones ---
        # √çcone de Login (Superior Esquerdo)
        icone_login_path = os.path.join(self.caminho_recursos, "log-in.png")
        self.icone_login = IconeInterativo(icone_login_path, "login", tamanho=self.TAMANHO_ICONE)
        self.icone_login.clicado.connect(self._ao_clicar_icone)
        layout.addWidget(self.icone_login)
        self.icones["login"] = self.icone_login

        # √çcone de Play (Mais abaixo)
        icone_play_path = os.path.join(self.caminho_recursos, "play.png")
        self.icone_play = IconeInterativo(icone_play_path, "play", tamanho=self.TAMANHO_ICONE)
        self.icone_play.clicado.connect(self._ao_clicar_icone)
        layout.addWidget(self.icone_play)
        self.icones["play"] = self.icone_play

        # Espa√ßo el√°stico para empurrar o √≠cone de sair para baixo
        layout.addStretch()

        # √çcone de Sair (Inferior Esquerdo)
        icone_sair_path = os.path.join(self.caminho_recursos, "arrow-left.png")
        self.icone_sair = IconeInterativo(icone_sair_path, "sair", tamanho=self.TAMANHO_ICONE)
        self.icone_sair.clicado.connect(self._ao_clicar_icone)
        layout.addWidget(self.icone_sair)
        self.icones["sair"] = self.icone_sair

    def _ao_clicar_icone(self, identificador):
        """Slot interno para reemitir o sinal do √≠cone clicado."""
        print(f"üì° GerenciadorIconesEsquerda: √çcone '{identificador}' acionado.")
        self.icone_clicado.emit(identificador)  # Re-emite o sinal para o consumidor (JanelaPrincipal)

    # M√©todos para atualizar √≠cones, se necess√°rio (ex: login/logout)
    def atualizar_icone(self, identificador, novo_caminho):
        """Atualiza a imagem de um √≠cone existente."""
        if identificador in self.icones:
            self.icones[identificador].carregar_icone(novo_caminho)
        else:
            print(f"‚ö†Ô∏è GerenciadorIconesEsquerda: √çcone '{identificador}' n√£o encontrado para atualizar.")


================================================================================
üìÑ client/components/__init__.py
================================================================================


================================================================================
‚úÖ Total de 4 arquivos inclu√≠dos.
================================================================================