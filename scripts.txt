ARQUIVO DE CÓDIGO CONSOLIDADO
Gerado em: 2025-08-19 18:24:25
Diretório: /home/mariagoreti/quan_qiu_wu_tai
Conteúdo dos scripts principais reunidos.

================================================================================

================================================================================
📁 ESTRUTURA DO PROJETO
================================================================================

📁 .
├── server
│   ├── routes
│   │   ├── auth.py
│   │   └── game.py
│   ├── saves
│   │   └── mundo_5e946bdf-961d-43dd-8b5b-6284733ef02b.json
│   ├── services
│   │   ├── queue_service.py
│   │   └── user_service.py
│   ├── __init__.py
│   ├── app.py
│   ├── aws_loader.py
│   ├── commander.py
│   ├── config.py
│   ├── extensions.py
│   ├── initializer.py
│   ├── interface.py
│   ├── manager.py
│   ├── sei_la_o_que.py
│   ├── serialization.py
│   ├── signals.py
│   └── simulador_players.py
├── client
│   ├── components
│   │   ├── __init__.py
│   │   └── icon_manager.py
│   ├── dialogs
│   │   └── auth_dialog.py
│   ├── resources
│   │   ├── arrow-left.png
│   │   ├── log-in.png
│   │   ├── play.png
│   │   └── smile.png
│   ├── states
│   │   └── __init__.py
│   └── main.py
├── shared
│   ├── civilization.py
│   ├── geography.py
│   ├── planet.py
│   ├── polygons.py
│   ├── province.py
│   ├── references.py
│   └── world.py

================================================================================
📄 CONTEÚDO DOS ARQUIVOS
================================================================================

================================================================================
📄 server/commander.py
================================================================================
# server/commander.py
import queue
import threading
import time
import uuid
from typing import Callable, Optional, Tuple

# --- Importações PyQt6 e sinais ---
from PyQt6.QtCore import QObject
from server.signals import WorkerSignals

# --- Suas importações existentes ---
from shared.world import Mundo
from server.manager import Gerenciador
from server.initializer import InicializadorAWS


class Comando:
    def __init__(
        self,
        nome: str,
        callback: Callable,
        args=None,
        kwargs=None,
        on_success: Callable = None,
        on_error: Callable = None,
        signals: Optional[WorkerSignals] = None  # ✅ Novo: sinais PyQt6
    ):
        self.id = str(uuid.uuid4())[:8]
        self.nome = nome
        self.callback = callback
        self.args = args or ()
        self.kwargs = kwargs or {}
        self.on_success = on_success  # ⚠️ Evite UI aqui
        self.on_error = on_error      # ⚠️ Evite UI aqui
        self.signals = signals        # ✅ Use para UI segura
        self.timestamp = time.time()

    def __repr__(self):
        return f"<Comando(id={self.id}, nome='{self.nome}')>"


class Comandante:
    """
    Orquestrador de operações de domínio.
    Deve ser usado pela interface gráfica para disparar ações assíncronas.
    Nunca deve conter lógica de UI.
    """
    def __init__(self, gerenciador: Gerenciador, aws_loader):
        self.gerenciador = gerenciador
        self.aws_loader = aws_loader
        self.fila = queue.Queue()
        self.ativo = True
        self.thread = threading.Thread(target=self._loop, daemon=True)

    def iniciar(self):
        """Inicia a thread de processamento de comandos."""
        self.thread.start()
        print("✅ Comandante iniciado. Pronto para executar comandos.")

    def parar(self, timeout: float = 2.0):
        """Para o loop de comandos de forma segura."""
        self.ativo = False
        while not self.fila.empty():
            try:
                self.fila.get_nowait()
            except queue.Empty:
                break
        self.thread.join(timeout=timeout)
        if self.thread.is_alive():
            print("⚠️ Thread do Comandante não encerrou a tempo.")
        else:
            print("🛑 Comandante parado com sucesso.")

    def _loop(self):
        """Loop principal: executa comandos da fila."""
        while self.ativo:
            try:
                comando = self.fila.get(timeout=0.2)
                print(f"⚙️ Executando [{comando.id}]: {comando.nome}")
                try:
                    resultado = comando.callback(*comando.args, **comando.kwargs)
                    print(f"✅ [{comando.id}] {comando.nome} concluído.")

                    # ✅ Primeiro: emitir sinais (seguro para UI)
                    if comando.signals:
                        comando.signals.success.emit(resultado)
                        comando.signals.finished.emit()

                    # ⚠️ Segundo: callbacks (cuidado! estão na thread secundária)
                    if comando.on_success:
                        try:
                            comando.on_success(resultado)
                        except Exception as cb_e:
                            print(f"⚠️ Erro no callback on_success: {cb_e}")

                except Exception as e:
                    print(f"❌ [{comando.id}] Erro em '{comando.nome}': {e}")

                    # ✅ Sinais de erro
                    if comando.signals:
                        comando.signals.error.emit(str(e))
                        comando.signals.finished.emit()

                    # ⚠️ Callbacks de erro
                    if comando.on_error:
                        try:
                            comando.on_error(str(e))
                        except Exception as cb_e:
                            print(f"⚠️ Erro no callback on_error: {cb_e}")

                finally:
                    self.fila.task_done()

            except queue.Empty:
                continue

    def _enviar_comando(self, nome: str, callback: Callable, *args, **kwargs):
        """
        Método auxiliar para criar e enviar um comando.
        Aceita on_success, on_error e signals nos kwargs.
        """
        on_success = kwargs.pop('on_success', None)
        on_error = kwargs.pop('on_error', None)
        signals = kwargs.pop('signals', None)  # ✅ Extrai os sinais

        comando = Comando(
            nome=nome,
            callback=callback,
            args=args,
            kwargs=kwargs,
            on_success=on_success,
            on_error=on_error,
            signals=signals  # ✅ Passa os sinais
        )
        self.fila.put(comando)

    # ————————————————————————————
    # Comandos de Domínio
    # ————————————————————————————

    def criar_e_upload_mundo(
        self,
        fator: int,
        bioma: str,
        bucket_name: str = "global-arena-tiles",
        s3_prefix: str = "planetas/",
        dynamodb_table_name: str = "GlobalArena",
        on_success: Callable = None,
        on_error: Callable = None,
        signals: Optional[WorkerSignals] = None  # ✅ Novo parâmetro
    ):
        """Comando: cria e faz upload de um novo mundo."""
        def task():
            sucesso, mundo = self.gerenciador.criar_e_upload_mundo_com_retorno(
                fator=fator,
                bioma=bioma,
                bucket_name=bucket_name,
                s3_prefix=s3_prefix,
                dynamodb_table_name=dynamodb_table_name
            )
            return sucesso, mundo

        self._enviar_comando(
            nome=f"Criar e Upload Mundo (fator={fator}, bioma={bioma})",
            callback=task,
            on_success=on_success,
            on_error=on_error,
            signals=signals  # ✅ Passa os sinais
        )

    def reinicializar_infra(
        self,
        confirmar: bool = False,
        on_success: Callable = None,
        on_error: Callable = None,
        signals: Optional[WorkerSignals] = None  # ✅ Novo parâmetro
    ):
        """Comando: reinicializa a infra AWS (S3 + DynamoDB)."""
        def task():
            inicializador = InicializadorAWS(self.aws_loader)
            sucesso = inicializador.inicializar(confirmar=confirmar)
            return sucesso

        self._enviar_comando(
            nome="Reinicializar Infra AWS",
            callback=task,
            on_success=on_success,
            on_error=on_error,
            signals=signals  # ✅ Passa os sinais
        )

    def testar_conexao_aws(
        self,
        on_success: Callable = None,
        on_error: Callable = None,
        signals: Optional[WorkerSignals] = None  # ✅ Novo parâmetro
    ):
        """Comando: testa conexão com AWS (conta, S3, DynamoDB)."""
        def task():
            try:
                account = self.aws_loader.get_account_info()
                buckets = self.aws_loader.list_s3_buckets()
                tables = self.aws_loader.list_dynamodb_tables()
                return {
                    'success': True,
                    'account': account,
                    'buckets': buckets,
                    'tables': tables
                }
            except Exception as e:
                raise e

        self._enviar_comando(
            nome="Testar Conexão AWS",
            callback=task,
            on_success=on_success,
            on_error=on_error,
            signals=signals  # ✅ Passa os sinais
        )

================================================================================
📄 server/initializer.py
================================================================================
# server/initializer.py
"""
Módulo para inicializar ou reinicializar a infraestrutura AWS:
- Cria/recria a tabela DynamoDB 'GlobalArena' com PK/SK.
- Limpa os dados no S3 nos prefixos usados.
- Garante que o bucket S3 exista.

Pode ser executado como script: python server/inicializador.py
"""

import boto3
from botocore.exceptions import ClientError
from typing import Dict
from server.aws_loader import AWSLoader


class InicializadorAWS:
    def __init__(self, aws_loader: AWSLoader):
        self.aws_loader = aws_loader
        self.dynamodb = self.aws_loader.get_client('dynamodb')
        self.s3 = self.aws_loader.get_client('s3')
        self.bucket_name = "global-arena-tiles"
        self.region = aws_loader.region_name

    def inicializar(self, confirmar: bool = True):
        """
        Inicializa ou reinicializa toda a infraestrutura.
        :param confirmar: Se True, pede confirmação antes de apagar dados.
        """
        if confirmar:
            resposta = input(
                "⚠️  Isso apagará todos os mundos e metadados no S3 e DynamoDB.\n"
                "Deseja continuar? (s/N): "
            )
            if resposta.lower() not in ['s', 'sim', 'y', 'yes']:
                print("❌ Operação cancelada.")
                return False

        print("🔄 Inicializando infraestrutura AWS...")

        try:
            # 1. Garantir que o bucket S3 existe
            self._criar_bucket_se_nao_existir()

            # 2. Limpar dados no S3
            prefixos = ["planetas/", "saves/"]
            for prefix in prefixos:
                self._limpar_prefixo_s3(prefix)

            # 3. Recriar tabela DynamoDB (única: GlobalArena)
            self._recriar_tabela_globalarena()

            print("✅ Infraestrutura AWS reinicializada com sucesso!")
            return True

        except Exception as e:
            print(f"❌ Erro ao inicializar infraestrutura: {e}")
            return False

    def _criar_bucket_se_nao_existir(self):
        """Cria o bucket S3 se ele não existir."""
        try:
            self.s3.head_bucket(Bucket=self.bucket_name)
            print(f"ℹ️  Bucket S3 '{self.bucket_name}' já existe.")
        except ClientError:
            print(f"📦 Criando bucket S3 '{self.bucket_name}'...")
            try:
                if self.region == "us-east-1":
                    self.s3.create_bucket(Bucket=self.bucket_name)
                else:
                    self.s3.create_bucket(
                        Bucket=self.bucket_name,
                        CreateBucketConfiguration={'LocationConstraint': self.region}
                    )
                print(f"✅ Bucket '{self.bucket_name}' criado com sucesso.")
            except ClientError as e:
                print(f"❌ Falha ao criar bucket: {e}")
                raise

    def _limpar_prefixo_s3(self, prefix: str):
        """Remove todos os objetos com o prefixo dado no S3."""
        print(f"🧹 Limpando S3: s3://{self.bucket_name}/{prefix}")
        paginator = self.s3.get_paginator('list_objects_v2')
        apagados = 0

        try:
            pages = paginator.paginate(Bucket=self.bucket_name, Prefix=prefix)
            for page in pages:
                if 'Contents' not in page:
                    continue
                keys = [{'Key': obj['Key']} for obj in page['Contents']]
                if keys:
                    self.s3.delete_objects(Bucket=self.bucket_name, Delete={'Objects': keys})
                    apagados += len(keys)
            print(f"✅ {apagados} objetos apagados no prefixo '{prefix}'.")
        except ClientError as e:
            print(f"❌ Erro ao limpar S3 no prefixo '{prefix}': {e}")

    def _recriar_tabela_globalarena(self):
        """Deleta e recria a tabela GlobalArena com PK/SK."""
        table_name = "GlobalArena"
        try:
            print(f"🔍 Verificando tabela '{table_name}'...")
            self.dynamodb.describe_table(TableName=table_name)
            print(f"🗑️  Tabela '{table_name}' encontrada. Deletando...")
            self.dynamodb.delete_table(TableName=table_name)

            # Aguardar exclusão
            waiter = self.dynamodb.get_waiter('table_not_exists')
            waiter.wait(TableName=table_name, WaiterConfig={'Delay': 2, 'MaxAttempts': 30})
            print(f"✅ Tabela '{table_name}' deletada.")
        except ClientError as e:
            if e.response['Error']['Code'] != 'ResourceNotFoundException':
                raise e
            print(f"ℹ️  Tabela '{table_name}' não existe. Será criada.")

        # Criar tabela com PK/SK
        print(f"🆕 Criando tabela '{table_name}' com PK/SK...")
        try:
            self.dynamodb.create_table(
                TableName=table_name,
                AttributeDefinitions=[
                    {'AttributeName': 'PK', 'AttributeType': 'S'},
                    {'AttributeName': 'SK', 'AttributeType': 'S'}
                ],
                KeySchema=[
                    {'AttributeName': 'PK', 'KeyType': 'HASH'},
                    {'AttributeName': 'SK', 'KeyType': 'RANGE'}
                ],
                BillingMode='PAY_PER_REQUEST'
            )

            # Aguardar ativação
            waiter = self.dynamodb.get_waiter('table_exists')
            waiter.wait(TableName=table_name, WaiterConfig={'Delay': 2, 'MaxAttempts': 30})
            print(f"✅ Tabela '{table_name}' criada e ativa.")
        except ClientError as e:
            print(f"❌ Falha ao criar tabela '{table_name}': {e}")
            raise


# ========================== CLI ==========================
if __name__ == "__main__":
    """
    Execução direta do módulo:
    $ python server/inicializador.py
    """
    print("🔧 Inicializador AWS - Reinicialização de Infraestrutura\n")

    # Cria o loader AWS
    try:
        aws_loader = AWSLoader()
        print(f"✅ Conectado à AWS (região: {aws_loader.region_name})")
    except Exception as e:
        print(f"❌ Falha ao conectar à AWS: {e}")
        exit(1)

    # Inicializa
    inicializador = InicializadorAWS(aws_loader)
    inicializador.inicializar(confirmar=True)

================================================================================
📄 server/extensions.py
================================================================================
# server/extensions.py
from server.aws_loader import AWSLoader

class Extensions:
    def __init__(self):
        self.dynamodb = None
        # self.redis = None # Futuro

    def init_app(self, app):
        """Inicializa as extensões com base na configuração da app Flask."""
        try:
            aws_loader = AWSLoader(
                profile_name=app.config['AWS_PROFILE_NAME'],
                region_name=app.config['AWS_REGION_NAME']
            )
            self.dynamodb = aws_loader.get_client('dynamodb')
            print("✅ Cliente DynamoDB conectado via Extensions.")
        except Exception as e:
            print(f"❌ Falha ao conectar ao DynamoDB na inicialização: {e}")
            self.dynamodb = None # Ou lançar exceção, dependendo da política de falhas

# Instância global
ext = Extensions()

================================================================================
📄 server/sei_la_o_que.py
================================================================================
# sei_la_o_que.py

from aws_loader import AWSLoader  # ou from server.aws_loader import AWSLoader

def main():
    print("🚀 Iniciando aplicação...\n")

    # --- Configuração ---
    loader = AWSLoader(
        region_name='us-east-2',
        # profile_name='seu-perfil'  # opcional
    )

    # --- 1. Informações da conta ---
    try:
        account = loader.get_account_info()
        print(f"✅ Logado na conta AWS: {account['account_id']}")
        print(f"👤 Usuário/Role: {account['arn']}\n")
    except Exception as e:
        print(f"❌ Falha ao obter conta: {e}")
        return

    # --- 2. Listar buckets S3 ---
    try:
        buckets = loader.list_s3_buckets()
        print(f"📦 Buckets S3 encontrados ({len(buckets)}):")
        for bucket in buckets:
            print(f"  - {bucket}")
    except Exception as e:
        print(f"❌ Erro ao listar buckets S3: {e}")

    # --- 3. Listar tabelas DynamoDB ---
    try:
        tables = loader.list_dynamodb_tables()
        print(f"\n📊 Tabelas DynamoDB encontradas ({len(tables)}):")
        for table in tables:
            print(f"  - {table}")
    except Exception as e:
        print(f"❌ Erro ao listar tabelas DynamoDB: {e}")

    # --- 4. Exemplo: usar cliente S3 ---
    try:
        s3 = loader.get_client('s3')
        response = s3.list_buckets()
        print(f"\n🌍 Conexão S3 bem-sucedida. Total de buckets: {len(response['Buckets'])}")
    except Exception as e:
        print(f"❌ Falha ao usar cliente S3: {e}")


if __name__ == "__main__":
    main()

================================================================================
📄 server/simulador_players.py
================================================================================
# simulador_players.py
import requests
import random
import time
import threading

# Lista de usuários simulados (você pode gerar ou registrar previamente)
USUARIOS_SIMULADOS = [
    {"username": "player1", "password": "senha123"},
    {"username": "player2", "password": "senha123"},
    {"username": "player3", "password": "senha123"},
    {"username": "player4", "password": "senha123"},
    {"username": "player5", "password": "senha123"},
]

URL_BASE = "http://localhost:5000"

def login_usuario(usuario):
    try:
        response = requests.post(f"{URL_BASE}/auth/login", json=usuario)
        data = response.json()
        if data.get("success"):
            print(f"✅ {usuario['username']} logou com sucesso.")
            return data.get("token")  # se você implementar tokens no futuro
        else:
            print(f"❌ {usuario['username']} falhou: {data.get('message')}")
            return None
    except Exception as e:
        print(f"⚠️  Erro ao conectar para {usuario['username']}: {e}")
        return None

def entrar_na_fila(usuario):
    token = login_usuario(usuario)
    if not token:
        return

    headers = {"Authorization": f"Bearer {token}"} if token else {}
    try:
        response = requests.post(f"{URL_BASE}/jogo/entrar", json={"modo": "online"}, headers=headers)
        data = response.json()
        print(f"🎮 {usuario['username']} {data.get('message')}")
    except Exception as e:
        print(f"⚠️  Falha ao entrar na fila: {e}")

def simular_entrada_periodica(intervalo_min=2, intervalo_max=5):
    """Simula entrada aleatória de players no sistema."""
    while True:
        usuario = random.choice(USUARIOS_SIMULADOS)
        thread = threading.Thread(target=entrar_na_fila, args=(usuario,), daemon=True)
        thread.start()
        time.sleep(random.randint(intervalo_min, intervalo_max))

if __name__ == "__main__":
    print("🚀 Iniciando simulador de players...")
    simular_entrada_periodica()

================================================================================
📄 server/__init__.py
================================================================================


================================================================================
📄 server/aws_loader.py
================================================================================
# aws_loader.py

import boto3
from botocore.exceptions import NoCredentialsError, PartialCredentialsError


class AWSLoader:
    def __init__(self, profile_name=None, region_name='us-east-2'):
        """
        Inicializa o loader de credenciais AWS.

        :param profile_name: Nome do perfil no arquivo ~/.aws/credentials (opcional)
        :param region_name: Região AWS padrão
        """
        self.profile_name = profile_name
        self.region_name = region_name
        self.session = None
        self._create_session()

    def _create_session(self):
        """Cria uma sessão boto3 com base no perfil ou nas credenciais padrão."""
        try:
            if self.profile_name:
                self.session = boto3.Session(profile_name=self.profile_name, region_name=self.region_name)
            else:
                self.session = boto3.Session(region_name=self.region_name)

            # Testa credenciais
            sts = self.session.client('sts')
            sts.get_caller_identity()
            print("✅ Credenciais AWS carregadas com sucesso.")

        except NoCredentialsError:
            raise Exception("❌ Credenciais AWS não encontradas. Configure AWS_ACCESS_KEY_ID e AWS_SECRET_ACCESS_KEY.")
        except PartialCredentialsError:
            raise Exception("❌ Credenciais incompletas. Verifique AWS_ACCESS_KEY_ID e AWS_SECRET_ACCESS_KEY.")
        except Exception as e:
            raise Exception(f"❌ Erro ao carregar credenciais: {e}")

    def get_credentials(self):
        """
        Retorna as credenciais (access key, secret key, token).
        """
        credentials = self.session.get_credentials()
        frozen_creds = credentials.get_frozen_credentials()
        return {
            'access_key': frozen_creds.access_key,
            'secret_key': frozen_creds.secret_key,
            'token': frozen_creds.token
        }

    def get_client(self, service_name):
        """Retorna um cliente boto3 para o serviço especificado."""
        return self.session.client(service_name)

    def get_resource(self, service_name):
        """Retorna um recurso boto3 (ex: S3 resource)."""
        return self.session.resource(service_name)

    # --- 🔧 Novos métodos adicionados ---
    def get_account_info(self):
        """Retorna informações da conta AWS: ID, ARN, usuário, região."""
        sts = self.session.client('sts')
        identity = sts.get_caller_identity()
        return {
            'account_id': identity['Account'],
            'user_id': identity['UserId'],
            'arn': identity['Arn'],
            'region': self.region_name
        }

    def list_s3_buckets(self):
        """Lista todos os buckets S3 da conta."""
        s3 = self.get_client('s3')
        response = s3.list_buckets()
        return [bucket['Name'] for bucket in response['Buckets']]

    def list_dynamodb_tables(self):
        """Lista todas as tabelas DynamoDB da conta."""
        dynamodb = self.get_client('dynamodb')
        response = dynamodb.list_tables()
        return response['TableNames']

================================================================================
📄 server/manager.py
================================================================================
# server/manager.py
import json
import time
from pathlib import Path
from typing import Optional, Tuple

from server.serialization import Serializador
from server.aws_loader import AWSLoader
from shared.world import Mundo


class Gerenciador:
    """
    Gerencia operações de mundo: criação, serialização, upload S3 e salvamento de metadados no DynamoDB.
    Nada é salvo localmente.
    """

    def __init__(self, aws_loader: AWSLoader, save_dir: str = "saves"):
        self.aws_loader = aws_loader
        self.save_dir = Path(save_dir)
        self.save_dir.mkdir(exist_ok=True)  # Mantido para compatibilidade futura

    # server/manager.py

    def upload_mundo(self,
                     mundo: Mundo,
                     bucket_name: str = "global-arena-tiles",
                     s3_prefix: str = "planetas/",
                     dynamodb_table_name: str = "GlobalArena") -> bool:
        """
        Faz upload do mundo: dados pesados para S3, metadados leves para DynamoDB.
        Agora com rollback se falhar no DynamoDB.
        """
        try:
            pk = f"PLANET#{mundo.id_mundo}"
            sk = "METADATA"
            s3_key = f"{s3_prefix}{mundo.id_mundo}.json"

            # --- Verificar se já existe no DynamoDB ---
            dynamodb = self.aws_loader.get_client('dynamodb')
            response = dynamodb.get_item(
                TableName=dynamodb_table_name,
                Key={'PK': {'S': pk}, 'SK': {'S': sk}}
            )
            if 'Item' in response:
                print(f"❌ Mundo com ID {mundo.id_mundo} já existe no DynamoDB.")
                return False

            # --- Serializar e enviar para S3 ---
            dados_s3 = Serializador.to_serializable_dict(mundo)
            dados_json = json.dumps(dados_s3, ensure_ascii=False, indent=2)

            s3 = self.aws_loader.get_client('s3')
            s3.put_object(
                Bucket=bucket_name,
                Key=s3_key,
                Body=dados_json,
                ContentType='application/json'
            )
            print(f"✅ Upload para S3 concluído: s3://{bucket_name}/{s3_key}")

            # --- Salvar metadados no DynamoDB ---
            try:
                bioma_inicial = getattr(mundo.planeta, 'bioma_inicial', 'Desconhecido')
                vagas = getattr(mundo.planeta, 'numero_de_jogadores', 0)

                dynamodb.put_item(
                    TableName=dynamodb_table_name,
                    Item={
                        'PK': {'S': pk},
                        'SK': {'S': sk},
                        'entityType': {'S': 'Planet'},
                        'fator': {'N': str(mundo.planeta.fator)},
                        'bioma_inicial': {'S': bioma_inicial},
                        'vagas': {'N': str(vagas)},
                        'timestamp': {'N': str(int(time.time()))}
                    }
                )
                print(f"✅ Metadados do mundo {mundo.id_mundo} salvos no DynamoDB.")
                return True

            except Exception as e:
                print(f"❌ Falha ao salvar no DynamoDB: {e}")
                print(f"🧹 Removendo arquivo órfão do S3: s3://{bucket_name}/{s3_key}")
                try:
                    s3.delete_object(Bucket=bucket_name, Key=s3_key)
                    print("✅ Arquivo órfão removido com sucesso.")
                except Exception as del_e:
                    print(f"⚠️ Falha ao remover arquivo órfão do S3: {del_e}")
                return False

        except Exception as e:
            print(f"❌ Erro inesperado durante upload_mundo: {e}")
            return False

    def criar_e_upload_mundo(
        self,
        fator: int,
        bioma: str,
        bucket_name: str = "global-arena-tiles",
        s3_prefix: str = "planetas/"
    ) -> bool:
        """
        Cria um novo mundo com fator e bioma dados, e faz upload direto para S3 + DynamoDB.

        :param fator: Nível de detalhe da grade geográfica (ex: 4)
        :param bioma: Bioma inicial para escolha de capitais (ex: "Meadow")
        :param bucket_name: Nome do bucket S3
        :param s3_prefix: Prefixo (pasta) no bucket
        :return: True se sucesso, False caso contrário
        """
        try:
            print(f"🌍 Criando mundo com fator={fator}, bioma='{bioma}'...")
            mundo = Mundo(fator=fator, bioma=bioma)
            print(f"✅ Mundo criado: {mundo.id_mundo}")

            sucesso = self.upload_mundo(mundo, bucket_name=bucket_name, s3_prefix=s3_prefix)

            if sucesso:
                print(f"🎉 Mundo {mundo.id_mundo} enviado com sucesso para a nuvem!")
            else:
                print(f"❌ Falha no upload do mundo {mundo.id_mundo}")

            return sucesso

        except Exception as e:
            print(f"❌ Erro ao criar e upload mundo: {e}")
            return False

    def criar_e_upload_mundo_com_retorno(
            self,
            fator: int,
            bioma: str,
            bucket_name: str = "global-arena-tiles",
            s3_prefix: str = "planetas/",
            dynamodb_table_name: str = "GlobalArena"
    ) -> Tuple[bool, Optional[Mundo]]:
        """
        Cria um novo mundo com fator e bioma dados, faz upload para S3 + DynamoDB,
        e retorna sucesso e a instância do mundo.
        """
        try:
            print(f"🌍 Criando mundo com fator={fator}, bioma='{bioma}'...")
            mundo = Mundo(fator=fator, bioma=bioma)
            print(f"✅ Mundo criado: {mundo.id_mundo}")

            sucesso = self.upload_mundo(
                mundo,
                bucket_name=bucket_name,
                s3_prefix=s3_prefix,
                dynamodb_table_name=dynamodb_table_name
            )

            if sucesso:
                print(f"🎉 Mundo {mundo.id_mundo} enviado com sucesso para a nuvem!")
            else:
                print(f"❌ Falha no upload do mundo {mundo.id_mundo}")

            return sucesso, mundo

        except Exception as e:
            print(f"❌ Erro ao criar e upload mundo: {e}")
            import traceback
            traceback.print_exc()
            return False, None

    def criar_mundo(self, fator: int, bioma: str) -> Mundo:
        """Cria e retorna um novo mundo."""
        return Mundo(fator=fator, bioma=bioma)

================================================================================
📄 server/signals.py
================================================================================
# server/signals.py
from PyQt6.QtCore import QObject, pyqtSignal

class WorkerSignals(QObject):
    """
    Define sinais para comunicação segura com a thread da UI.
    Usado pelo Comandante para enviar feedback.
    """
    success = pyqtSignal(object)   # resultado
    error = pyqtSignal(str)        # mensagem de erro
    finished = pyqtSignal()        # operação concluída

================================================================================
📄 server/app.py
================================================================================
# server/app.py
from flask import Flask
from server.config import config
from server.extensions import ext
from server.services.user_service import UserService
from server.routes.auth import auth_bp, register_routes
from server.routes.game import jogo_bp, register_jogo_routes

def create_app(config_name='default'):
    """Factory function para criar a aplicação Flask."""
    app = Flask(__name__)

    # 1. Carrega a configuração
    app.config.from_object(config[config_name])

    # 2. Inicializa as extensões
    ext.init_app(app)

    # 3. Cria instâncias de serviços, injetando dependências
    user_service = UserService(ext.dynamodb, app.config['DYNAMODB_TABLE_NAME'])

    # 4. Registra os Blueprints e injeta dependências

    # --- 🔹 Auth ---
    register_routes(user_service)
    app.register_blueprint(auth_bp)

    # --- 🔹 Jogo Online (NOVO) ---
    register_jogo_routes(user_service)  # Pode injetar outros serviços depois
    app.register_blueprint(jogo_bp)    # Registra o blueprint

    # 5. Rotas principais (opcional)
    @app.route('/')
    def home():
        return "🚀 Servidor Global Arena - API (Refatorado com Classes)", 200

    return app

# Para execução direta (ex: python server/app.py)
if __name__ == '__main__':
    app = create_app('development')  # Ou 'production'
    print("🚀 Iniciando Servidor Global Arena (Flask - Refatorado)...")
    print("📄 Endpoints disponíveis:")
    print("   GET  /                        - Status do servidor")
    print("   GET  /auth/teste_dynamodb     - Teste de conexão com DynamoDB")
    print("   POST /jogo/entrar             - Entrar na fila de jogo online (novo)")
    print("-" * 40)
    app.run(host='127.0.0.1', port=5000, debug=app.config['DEBUG'])

================================================================================
📄 server/config.py
================================================================================
# server/config.py
import os


class Config:
    # Flask
    SECRET_KEY = os.environ.get(
        'SECRET_KEY') or 'chave_secreta_dev_super_segura'  # Em produção, use variável de ambiente

    # AWS
    AWS_PROFILE_NAME = os.environ.get('AWS_PROFILE_NAME') or None
    AWS_REGION_NAME = os.environ.get('AWS_REGION_NAME') or 'us-east-2'  # Certifique-se de usar a mesma região

    # DynamoDB
    DYNAMODB_TABLE_NAME = os.environ.get(
        'DYNAMODB_TABLE_NAME') or 'GlobalArena'  # Ou 'UsuariosGlobalArena' se criar uma nova

    # Futuras configurações (ex: Redis, Logging)
    # REDIS_URL = os.environ.get('REDIS_URL') or 'redis://localhost:6379/0'


class DevelopmentConfig(Config):
    DEBUG = True


class ProductionConfig(Config):
    DEBUG = False
    # SECRET_KEY = os.environ.get('SECRET_KEY') # Obrigatório em produção


config = {
    'development': DevelopmentConfig,
    'production': ProductionConfig,
    'default': DevelopmentConfig
}

================================================================================
📄 server/serialization.py
================================================================================
# server/serialization.py
import json
import networkx as nx
import numpy as np
from pathlib import Path
from typing import Any, Dict, Optional
from shared.world import Mundo
from shared.references import Referencias


class Serializador:
    """
    Classe responsável por serializar e desserializar o estado completo de um Mundo.
    Converte para dict serializável em JSON, salva em disco e recarrega.
    """

    @staticmethod
    def _convert(value: Any) -> Any:
        """
        Converte valores não serializáveis em tipos compatíveis com JSON.
        """
        if isinstance(value, np.integer):
            return int(value)
        if isinstance(value, np.floating):
            return float(value)
        if isinstance(value, np.ndarray):
            return value.tolist()
        if isinstance(value, tuple):
            return list(value)
        if hasattr(value, '__dict__'):
            return {k: Serializador._convert(v) for k, v in value.__dict__.items() if not k.startswith('_')}
        return value

    @classmethod
    def to_serializable_dict(cls, mundo: Mundo) -> Dict[str, Any]:
        """
        Converte um objeto Mundo em um dicionário compatível com JSON.
        Remove atributos deriváveis para reduzir tamanho.
        """
        if not hasattr(mundo, 'planeta') or not hasattr(mundo, 'civs'):
            raise ValueError("Objeto mundo inválido: falta atributos 'planeta' ou 'civs'")

        G = mundo.planeta.geografia.copy()

        # Atributos que podem ser recalculados, então não precisam ser salvos
        node_attrs_to_remove = {
            'cor_placa', 'cor_bioma', 'letra_grega', 'cust_mob', 'tipo', 'altitude', 'umidade', 'temperatura',
        }
        for node in G.nodes:
            for attr in node_attrs_to_remove:
                G.nodes[node].pop(attr, None)  # Remove silenciosamente

        # Remover arestas (serão recalculadas com custo de mobilidade)
        G.remove_edges_from(list(G.edges))

        # Converter atributos dos nós
        for node in G.nodes:
            attrs = G.nodes[node]
            for key in list(attrs.keys()):
                attrs[key] = cls._convert(attrs[key])

        # Usa 'edges="links"' para manter compatibilidade com o formato antigo
        # O padrão futuro será 'edges="edges"', mas queremos evitar mudanças inesperadas
        G_data = nx.node_link_data(G, edges="links")
        G_data.pop("directed", None)
        G_data.pop("multigraph", None)
        G_data.pop("graph", None)

        # Serializar civilizações
        civilizacoes_data = []
        for civ in mundo.civs:
            civ_data = {
                'nome': civ.nome,
                'cultura': civ.cultura,
                'cor': cls._convert(civ.cor),
                'modalidade_bandeira': civ.modalidade_bandeira,
                'cores_bandeira': cls._convert(civ.cores_bandeira),
                'player': civ.player,
                'provincias': [
                    {
                        'coordenadas': cls._convert(p.coordenadas),
                        'nome': p.nome
                    }
                    for p in civ.provincias
                ]
            }
            civilizacoes_data.append(civ_data)

        return {
            "id_mundo": mundo.id_mundo,
            "fator": mundo.planeta.fator,
            "bioma_inicial": mundo.planeta.bioma_inicial,
            "vagas": mundo.planeta.numero_de_jogadores,
            "geografia": G_data,
            "civilizacoes": civilizacoes_data
        }

    @classmethod
    def from_serializable_dict(cls, data: Dict[str, Any], ref: Optional[Referencias] = None):
        """
        Reconstroi um objeto Mundo a partir de um dicionário.
        Requer uma instância de Referencias para inicialização.
        """
        """
        Ainda a ser implementado
        retorna Mundo
        """

    @classmethod
    def save_to_json(cls, mundo: Mundo, filepath: str) -> bool:
        try:
            data = cls.to_serializable_dict(mundo)
            path = Path(filepath)
            path.parent.mkdir(exist_ok=True, parents=True)
            with open(path, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
            print(f"✅ Mundo salvo em JSON: {filepath}")
            return True
        except Exception as e:
            print(f"❌ Falha ao salvar mundo: {e}")
            return False

    @classmethod
    def save_mundo(cls, mundo: Mundo, filepath: str = None) -> str:
        """
        Salva um objeto Mundo em JSON.
        Se filepath não for fornecido, gera um nome automático em 'saves/'.
        :param mundo: Instância de Mundo
        :param filepath: Caminho opcional para salvar
        :return: Caminho final usado, ou string vazia se falhar
        """
        from pathlib import Path

        if filepath is None:
            # Gera caminho padrão: saves/mundo_{id}.json
            saves_dir = Path("saves")
            saves_dir.mkdir(exist_ok=True)
            filepath = saves_dir / f"mundo_{mundo.id_mundo}.json"
        else:
            # Garante que o diretório pai exista
            path = Path(filepath)
            path.parent.mkdir(exist_ok=True, parents=True)

        sucesso = cls.save_to_json(mundo, filepath)
        return str(filepath) if sucesso else ""

================================================================================
📄 server/interface.py
================================================================================
# server/interface.py
import sys
from PyQt6.QtWidgets import (
    QApplication, QMainWindow, QTabWidget, QWidget, QVBoxLayout, QPushButton,
    QComboBox, QSpinBox, QMessageBox, QFormLayout, QGroupBox,
    QFileDialog
)
from server.signals import WorkerSignals
from server.serialization import Serializador
from server.manager import Gerenciador
from server.aws_loader import AWSLoader
from server.commander import Comandante


class Interface(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Gerenciador de Servidor - Global Arena")
        self.setGeometry(100, 100, 700, 500)

        # === Inicialização de dependências ===
        try:
            self.aws_loader = AWSLoader()
            self.gerenciador = Gerenciador(self.aws_loader)
            print("✅ Gerenciador inicializado com AWS.")
        except Exception as e:
            QMessageBox.critical(self, "Erro AWS", f"Não foi possível conectar à AWS:\n{e}")
            self.gerenciador = None

        # ✅ Inicializa o Comandante
        try:
            self.comandante = Comandante(self.gerenciador, self.aws_loader)
            self.comandante.iniciar()
            print("✅ Comandante iniciado.")
        except Exception as e:
            QMessageBox.critical(self, "Erro", f"Falha ao iniciar o Comandante:\n{e}")
            self.comandante = None

        # ✅ Cria e conecta os sinais
        self.setup_signals()

        # ✅ Armazena o último mundo criado
        self.ultimo_mundo = None

        # Configuração do sistema de abas
        self.tabs = QTabWidget()
        self.setCentralWidget(self.tabs)

        # ✅ Cria as abas
        self.backup_tab = self.create_backup_tab()
        self.config_tab = QWidget()
        self.tabs.addTab(self.backup_tab, "Backup & Criação")
        self.tabs.addTab(self.config_tab, "Configurações")

    def closeEvent(self, event):
        if self.comandante:
            self.comandante.parar()
        event.accept()

    def setup_signals(self):
        """Cria e conecta os sinais para comunicação segura."""
        self.signals = WorkerSignals()
        self.signals.success.connect(self.on_success)
        self.signals.error.connect(self.on_error)
        self.signals.finished.connect(self.on_finished)

    def on_success(self, resultado):
        sucesso, mundo = resultado
        if sucesso:
            self.ultimo_mundo = mundo
            QMessageBox.information(
                self, "Sucesso", f"Mundo {mundo.id_mundo} criado e enviado!"
            )
        else:
            QMessageBox.critical(self, "Falha", "Upload falhou.")

    def on_error(self, mensagem: str):
        QMessageBox.critical(self, "Erro", f"Falha: {mensagem}")

    def on_finished(self):
        print("✅ Operação concluída.")

    # ————————————————————————————————
    # Métodos para construção da UI
    # ————————————————————————————————

    def create_backup_tab(self):
        """Cria a aba de operações de backup e criação de mundos"""
        tab = QWidget()
        layout = QVBoxLayout()

        # === Grupo: Criar e Upload de Mundo ===
        group_criar = QGroupBox("Criar e Enviar Novo Mundo")
        form_layout = QFormLayout()

        self.spin_fator = QSpinBox()
        self.spin_fator.setMinimum(2)
        self.spin_fator.setMaximum(8)
        self.spin_fator.setValue(4)
        form_layout.addRow("Fator:", self.spin_fator)

        self.combo_bioma = QComboBox()
        biomas = ["Meadow", "Forest", "Savanna", "Desert", "Hills", "Mountains"]
        self.combo_bioma.addItems(biomas)
        self.combo_bioma.setCurrentText("Meadow")
        form_layout.addRow("Bioma Inicial:", self.combo_bioma)

        group_criar.setLayout(form_layout)
        layout.addWidget(group_criar)

        btn_upload = QPushButton("🌍 Criar e Enviar Mundo para Nuvem")
        btn_upload.clicked.connect(self.handle_criar_e_upload)
        layout.addWidget(btn_upload)

        layout.addSpacing(20)

        # === Grupo: Salvar Localmente ===
        group_local = QGroupBox("Salvar Estado Localmente")
        layout_local = QVBoxLayout()

        btn_save = QPushButton("💾 Salvar Estado como JSON (Local)")
        btn_save.clicked.connect(self.handle_save_json)
        layout_local.addWidget(btn_save)

        group_local.setLayout(layout_local)
        layout.addWidget(group_local)

        layout.addSpacing(20)

        # === Botão: Reinicializar Infraestrutura AWS ===
        btn_reiniciar = QPushButton("⚠️ Reinicializar Infraestrutura AWS")
        btn_reiniciar.setStyleSheet("""
            QPushButton {
                background-color: #a83232;
                color: white;
                font-weight: bold;
                border-radius: 6px;
                padding: 8px;
            }
            QPushButton:hover {
                background-color: #c03939;
            }
        """)
        btn_reiniciar.clicked.connect(self.handle_reinicializar_servidor)
        layout.addWidget(btn_reiniciar)
        layout.addSpacing(10)

        layout.addStretch()
        tab.setLayout(layout)
        return tab

    def handle_save_json(self):
        """Salva o último mundo criado (se existir) como JSON local."""
        if not self.ultimo_mundo:
            QMessageBox.warning(self, "Aviso", "Nenhum mundo foi criado ainda.")
            return

        try:
            mundo = self.ultimo_mundo
            filepath, _ = QFileDialog.getSaveFileName(
                self,
                "Salvar Mundo como JSON",
                f"saves/mundo_{mundo.id_mundo}.json",
                "JSON Files (*.json)"
            )
            if not filepath:
                return  # Cancelado

            caminho_salvo = Serializador.save_mundo(mundo, filepath)
            if caminho_salvo:
                QMessageBox.information(
                    self, "Sucesso", f"Mundo salvo localmente:\n{caminho_salvo}"
                )
            else:
                QMessageBox.critical(self, "Falha", "Erro ao salvar o arquivo.")
        except Exception as e:
            QMessageBox.critical(self, "Erro", f"Falha ao salvar: {str(e)}")

    def handle_criar_e_upload(self):
        if not self.comandante:
            QMessageBox.critical(self, "Erro", "Comandante não está disponível.")
            return

        fator = self.spin_fator.value()
        bioma = self.combo_bioma.currentText()

        self.comandante.criar_e_upload_mundo(
            fator=fator,
            bioma=bioma,
            signals=self.signals
        )

    def handle_reinicializar_servidor(self):
        if not self.comandante:
            QMessageBox.critical(self, "Erro", "Comandante não está disponível.")
            return

        reply = QMessageBox.question(
            self,
            "⚠️ Reinicializar Infraestrutura",
            "Isso apagará TODOS os mundos e metadados no S3 e DynamoDB.\n"
            "Continuar?",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
        )
        if reply != QMessageBox.StandardButton.Yes:
            return

        self.comandante.reinicializar_infra(
            confirmar=False,
            signals=self.signals
        )


# Execução da aplicação
if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = Interface()
    window.show()
    sys.exit(app.exec())

================================================================================
📄 server/services/queue_service.py
================================================================================
# server/services/queue_service.py

class FilaService:
    def __init__(self):
        self.fila = []

    def adicionar_jogador(self, username: str) -> bool:
        if username in self.fila:
            return False
        self.fila.append(username)
        print(f"📥 Jogador '{username}' adicionado à fila. Total: {len(self.fila)}")
        self._tentar_formar_partida()
        return True

    def remover_jogador(self, username: str):
        if username in self.fila:
            self.fila.remove(username)
            print(f"📤 Jogador '{username}' removido da fila.")

    def _tentar_formar_partida(self):
        """Quando tiver 4+ jogadores, inicia uma partida."""
        if len(self.fila) >= 4:
            partida = [self.fila.pop(0) for _ in range(4)]
            print(f"🎉 Partida iniciada com: {partida}")
            # Aqui você pode disparar um evento, sinalizar via WebSocket, etc.

================================================================================
📄 server/services/user_service.py
================================================================================
# server/services/user_service.py
import boto3
from botocore.exceptions import ClientError


class UserService:
    def __init__(self, dynamodb_client, table_name):
        self.dynamodb = dynamodb_client
        self.table_name = table_name

    def _format_user_key(self, username: str) -> dict:
        """Formata a chave primária do usuário no DynamoDB."""
        return {
            'PK': {'S': f'USER#{username}'},
            'SK': {'S': 'PROFILE'}
        }

    def get_user(self, username: str) -> dict:
        """Busca um usuário pelo username."""
        if not self.dynamodb:
            print("⚠️ Cliente DynamoDB não disponível no UserService.")
            return None
        try:
            response = self.dynamodb.get_item(
                TableName=self.table_name,
                Key=self._format_user_key(username)
            )
            return response.get('Item')
        except ClientError as e:
            print(f"❌ Erro do DynamoDB ao buscar usuário '{username}': {e.response['Error']['Message']}")
            return None
        except Exception as e:
            print(f"❌ Erro inesperado ao buscar usuário '{username}': {e}")
            return None

    def create_user_item(self, username: str, **attributes) -> bool:
        """
        Cria um novo item de usuário no DynamoDB.
        `attributes` pode conter {'password_hash': bytes, 'outro_attr': valor, ...}
        """
        if not self.dynamodb:
            print("⚠️ Cliente DynamoDB não disponível no UserService.")
            return False
        try:
            # Inicia o item com a chave primária
            item = self._format_user_key(username)

            # Adiciona outros atributos fornecidos
            for attr_name, attr_value in attributes.items():
                # Trata tipos específicos
                if isinstance(attr_value, bytes):
                    # Para password_hash, salva como tipo binário 'B'
                    item[attr_name] = {'B': attr_value}
                elif isinstance(attr_value, str):
                    # Para strings, salva como tipo string 'S'
                    item[attr_name] = {'S': attr_value}
                elif isinstance(attr_value, (int, float)):
                    # Para números, salva como tipo número 'N' (convertido para string)
                    item[attr_name] = {'N': str(attr_value)}
                else:
                    # Para outros tipos, converte para string e salva como 'S'
                    # (você pode querer ser mais específico aqui dependendo das suas necessidades)
                    print(
                        f"⚠️ Atributo '{attr_name}' tem tipo inesperado ({type(attr_value)}). Convertendo para string.")
                    item[attr_name] = {'S': str(attr_value)}

            self.dynamodb.put_item(
                TableName=self.table_name,
                Item=item
            )
            print(f"✅ Item de usuário '{username}' criado/Atualizado no DynamoDB.")
            return True
        except ClientError as e:
            print(f"❌ Erro do DynamoDB ao criar usuário '{username}': {e.response['Error']['Message']}")
            return False
        except Exception as e:
            print(f"❌ Erro inesperado ao criar usuário '{username}': {e}")
            return False

    def authenticate_user(self, username: str, password: str) -> tuple[bool, str]:
        """
        Autentica um usuário verificando a senha com bcrypt.

        :param username: Nome de usuário.
        :param password: Senha em texto plano.
        :return: (sucesso: bool, mensagem: str)
        """
        if not username or not password:
            return False, "Usuário ou senha ausentes."

        # 1. Buscar usuário
        user = self.get_user(username)
        if not user:
            return False, "Usuário não encontrado."

        # 2. Extrair o hash da senha
        password_hash_attr = user.get('password_hash')
        if not password_hash_attr:
            return False, "Usuário sem senha cadastrada."

        # 3. O hash pode vir como {'B': bytes} do DynamoDB
        if isinstance(password_hash_attr, dict) and 'B' in password_hash_attr:
            stored_hash = password_hash_attr['B']
        elif isinstance(password_hash_attr, bytes):
            stored_hash = password_hash_attr
        else:
            return False, "Formato de hash de senha inválido."

        # 4. Verificar com bcrypt
        try:
            if bcrypt.checkpw(password.encode('utf-8'), stored_hash):
                return True, "Login bem-sucedido."
            else:
                return False, "Senha incorreta."
        except Exception as e:
            print(f"❌ Erro ao verificar senha com bcrypt: {e}")
            return False, "Erro interno ao processar autenticação."


================================================================================
📄 server/routes/game.py
================================================================================
# server/routes/game.py
from flask import Blueprint, jsonify, request
from server.services.user_service import UserService
jogo_bp = Blueprint('jogo', __name__, url_prefix='/jogo')

# Variável para injeção de dependência
_user_service = None

def register_jogo_routes(user_service: UserService):
    """Função para injetar dependências no blueprint jogo."""
    global _user_service
    _user_service = user_service

@jogo_bp.route('/entrar', methods=['POST'])
def entrar_na_fila():
    if not request.is_json:
        return jsonify({"success": False, "message": "JSON esperado"}), 400

    data = request.get_json()
    modo = data.get("modo")

    if modo != "online":
        return jsonify({"success": False, "message": "Modo inválido. Use 'online'."}), 400

    # Aqui você pode validar o usuário via token depois
    username = data.get("username")
    if not username:
        return jsonify({"success": False, "message": "Username necessário."}), 400

    # Simples validação de existência (opcional)
    usuario = _user_service.get_user(username)
    if not usuario:
        return jsonify({"success": False, "message": "Usuário não encontrado."}), 404

    # 🔮 Futuramente: adicionar à fila de matchmaking
    return jsonify({
        "success": True,
        "message": f"{username} entrou na fila de jogo online.",
        "modo": modo
    }), 200

================================================================================
📄 server/routes/auth.py
================================================================================
# server/routes/auth.py
import re
import bcrypt
import unicodedata
from flask import Blueprint, request, jsonify, current_app

# Cria um Blueprint para as rotas de autenticação
auth_bp = Blueprint('auth', __name__, url_prefix='/auth')

def normalizar_username(username: str) -> str:
    # Remove acentos
    username = unicodedata.normalize('NFKD', username)
    username = ''.join(c for c in username if not unicodedata.combining(c))
    # Substitui espaços e caracteres especiais por underscore
    username = re.sub(r'[^a-zA-Z0-9]', '_', username)
    # Converte para minúsculas
    username = username.lower()
    # Remove underscores múltiplos
    username = re.sub(r'_+', '_', username).strip('_')
    return username or None  # Retorna None se vazio


# Esta função será chamada em app.py para registrar as rotas e passar dependências
def register_routes(user_service_instance):
    """Registra as rotas do Blueprint com as dependências injetadas."""

    # --- Endpoint de Teste (já existente) ---
    @auth_bp.route('/teste_dynamodb')
    def teste_dynamodb():
        """Endpoint de teste para verificar a conexão com o DynamoDB."""
        if not user_service_instance.dynamodb:
            return jsonify({"status": "erro", "message": "Cliente DynamoDB não disponível no serviço."}), 500

        try:
            response = user_service_instance.dynamodb.list_tables()
            tabelas = response.get('TableNames', [])
            return jsonify({
                "status": "sucesso",
                "message": "Conexão com DynamoDB bem-sucedida via UserService.",
                "tabelas": tabelas
            }), 200
        except Exception as e:
            return jsonify({"status": "erro", "message": f"Falha ao testar DynamoDB: {str(e)}"}), 500

    # --- Novo Endpoint: Registro de Usuário ---
    @auth_bp.route('/registrar', methods=['POST'])
    def registrar():
        """
        Endpoint para registro de novo usuário.
        Espera um JSON: {"username": "nome", "password": "senha"}
        Retorna um JSON: {"success": true/false, "message": "..."}
        """
        # 1. Validar requisição: deve ser JSON
        if not request.is_json:
            return jsonify({"success": False, "message": "Content-Type deve ser application/json"}), 400

        data = request.get_json()
        username = data.get('username', '').strip()
        password = data.get('password', '')

        # 2. Validar campos obrigatórios
        if not username or not password:
            return jsonify({"success": False, "message": "Username e password são obrigatórios."}), 400

        # 3. Validar comprimento mínimo
        if len(username) < 3:
            return jsonify({"success": False, "message": "Username deve ter pelo menos 3 caracteres."}), 400
        if len(password) < 6:
            return jsonify({"success": False, "message": "Password deve ter pelo menos 6 caracteres."}), 400

        # 4. Normalização opcional: remover acentos e forçar formato seguro
        # Comente ou remova se quiser permitir acentos no username
        def normalizar_username(s):
            s = unicodedata.normalize('NFKD', s)
            return ''.join(c for c in s if not unicodedata.combining(c))

        username_normalizado = normalizar_username(username)

        # 5. Validar formato do username (apenas letras, números, _, -)
        if not re.match(r"^[a-zA-Z0-9_-]+$", username_normalizado):
            return jsonify({"success": False, "message": "Username só pode conter letras, números, _ e -."}), 400

        # 6. Verificar se o usuário já existe (usando o nome original ou normalizado)
        # Aqui você decide: quer unicidade com ou sem acentos?
        # Opção 1: busca pelo nome original (atual)
        usuario_existente = user_service_instance.get_user(username)
        # Opção 2: busca pelo nome normalizado (recomendado para evitar colisões)
        # usuario_existente = user_service_instance.get_user(username_normalizado)

        if usuario_existente:
            return jsonify({"success": False, "message": "Nome de usuário já está em uso."}), 409

        # 7. Hashear a senha
        try:
            salt = bcrypt.gensalt()
            password_hash_bytes = bcrypt.hashpw(password.encode('utf-8'), salt)
        except Exception as e:
            print(f"❌ Erro ao hashear senha para usuário '{username}': {e}")
            return jsonify({"success": False, "message": "Erro interno ao processar a senha."}), 500

        # 8. Preparar atributos para salvar
        atributos_usuario = {
            'password_hash': password_hash_bytes,
            # Campos opcionais para evolução
            # 'display_name': username,  # Nome exibido (com acentos)
            # 'created_at': datetime.utcnow().isoformat() + 'Z'
        }

        # 9. Salvar no DynamoDB
        sucesso_criacao = user_service_instance.create_user_item(username, **atributos_usuario)

        if sucesso_criacao:
            print(f"✅ Usuário '{username}' registrado com sucesso.")
            return jsonify({"success": True, "message": "Usuário registrado com sucesso."}), 201
        else:
            return jsonify({"success": False, "message": "Falha ao registrar usuário no banco de dados."}), 500

    @auth_bp.route('/login', methods=['POST'])
    def login():
        """
        Endpoint para autenticação de usuário.
        Espera: {"username": "nome", "password": "senha"}
        Retorna: {"success": bool, "message": str}
        """
        # 1. Verificar se o corpo é JSON
        if not request.is_json:
            return jsonify({"success": False, "message": "Requisição deve ser JSON."}), 400

        data = request.get_json()

        # 2. Extrair e validar campos
        username = data.get('username', '').strip()
        password = data.get('password', '')

        if not username:
            return jsonify({"success": False, "message": "Nome de usuário é obrigatório."}), 400
        if not password:
            return jsonify({"success": False, "message": "Senha é obrigatória."}), 400

        # 3. Buscar usuário
        try:
            usuario = user_service_instance.get_user(username)
            if not usuario:
                return jsonify({"success": False, "message": "Usuário não encontrado."}), 404
        except Exception as e:
            print(f"❌ Erro ao buscar usuário '{username}': {e}")
            return jsonify({"success": False, "message": "Erro interno ao acessar banco de dados."}), 500

        # 4. Extrair e validar hash da senha
        password_hash_attr = usuario.get('password_hash')
        if not password_hash_attr:
            return jsonify({"success": False, "message": "Usuário sem senha cadastrada."}), 500

        # Extrair bytes do campo 'B' se for um dict (formato DynamoDB)
        if isinstance(password_hash_attr, dict) and 'B' in password_hash_attr:
            stored_hash = password_hash_attr['B']
        elif isinstance(password_hash_attr, bytes):
            stored_hash = password_hash_attr
        else:
            print(f"⚠️ Formato inesperado de password_hash para '{username}': {type(password_hash_attr)}")
            return jsonify({"success": False, "message": "Erro interno de autenticação."}), 500

        # 5. Verificar senha com bcrypt
        try:
            if bcrypt.checkpw(password.encode('utf-8'), stored_hash):
                return jsonify({"success": True, "message": "Login bem-sucedido."}), 200
            else:
                return jsonify({"success": False, "message": "Senha incorreta."}), 401
        except Exception as e:
            print(f"❌ Erro ao verificar senha com bcrypt: {e}")
            return jsonify({"success": False, "message": "Erro interno ao processar autenticação."}), 500


================================================================================
📄 client/main.py
================================================================================
# client/main.py

import sys
import os  # Para verificar o arquivo de sessão
import OpenGL.GL as gl
import ctypes

import requests
from PyQt6.QtWidgets import (
    QApplication, QMainWindow, QWidget, QVBoxLayout, QLabel, QPushButton, QHBoxLayout,
    QSizePolicy, QFrame, QMessageBox, QDialog, QFormLayout, QLineEdit, QDialogButtonBox
)
from PyQt6.QtOpenGLWidgets import QOpenGLWidget
from PyQt6.QtCore import QTimer, Qt
from PyQt6.QtGui import QSurfaceFormat, QFont
from components.icon_manager import GerenciadorIconesEsquerda
from dialogs.auth_dialog import DialogoAutenticacao


# --- Componente OpenGL ---
class MeuOpenGLWidget(QOpenGLWidget):
    """
    Widget responsável pela renderização OpenGL Moderna.
    """

    def __init__(self):
        super().__init__()
        self.shader_program = None
        self.VAO = None
        self.VBO = None
        # Permitir que o widget receba foco de teclado
        self.setFocusPolicy(Qt.FocusPolicy.StrongFocus)

    def initializeGL(self):
        """
        Inicializado uma vez quando o contexto OpenGL é criado.
        Aqui compilamos shaders, criamos VAOs, VBOs etc.
        """
        print("Inicializando contexto OpenGL...")
        # Define a cor de fundo padrão como PRETO PURO
        gl.glClearColor(0.0, 0.0, 0.0, 1.0)

        # --- Compilar Shaders para o Triângulo ---
        vertex_shader_source = """
        #version 330 core
        layout (location = 0) in vec3 aPos;
        layout (location = 1) in vec3 aColor;
        out vec3 ourColor;
        void main()
        {
            gl_Position = vec4(aPos, 1.0);
            ourColor = aColor;
        }
        """

        fragment_shader_source = """
        #version 330 core
        in vec3 ourColor;
        out vec4 FragColor;
        void main()
        {
            FragColor = vec4(ourColor, 1.0f);
        }
        """

        # --- Compilação e Linkagem de Shaders ---
        try:
            # Compilação do Vertex Shader
            vertex_shader = gl.glCreateShader(gl.GL_VERTEX_SHADER)
            gl.glShaderSource(vertex_shader, vertex_shader_source)
            gl.glCompileShader(vertex_shader)
            # Verificação de erros no vertex shader
            success = gl.glGetShaderiv(vertex_shader, gl.GL_COMPILE_STATUS)
            if not success:
                info_log = gl.glGetShaderInfoLog(vertex_shader)
                raise RuntimeError(f"Erro ao compilar Vertex Shader:\n{info_log.decode('utf-8')}")

            # Compilação do Fragment Shader
            fragment_shader = gl.glCreateShader(gl.GL_FRAGMENT_SHADER)
            gl.glShaderSource(fragment_shader, fragment_shader_source)
            gl.glCompileShader(fragment_shader)
            # Verificação de erros no fragment shader
            success = gl.glGetShaderiv(fragment_shader, gl.GL_COMPILE_STATUS)
            if not success:
                info_log = gl.glGetShaderInfoLog(fragment_shader)
                raise RuntimeError(f"Erro ao compilar Fragment Shader:\n{info_log.decode('utf-8')}")

            # Linkagem do Programa Shader
            self.shader_program = gl.glCreateProgram()
            gl.glAttachShader(self.shader_program, vertex_shader)
            gl.glAttachShader(self.shader_program, fragment_shader)
            gl.glLinkProgram(self.shader_program)
            # Verificação de erros no link
            success = gl.glGetProgramiv(self.shader_program, gl.GL_LINK_STATUS)
            if not success:
                info_log = gl.glGetProgramInfoLog(self.shader_program)
                raise RuntimeError(f"Erro ao linkar Programa Shader:\n{info_log.decode('utf-8')}")

            # Deletar os shaders já linkados
            gl.glDeleteShader(vertex_shader)
            gl.glDeleteShader(fragment_shader)

        except RuntimeError as e:
            print(f"❌ Erro na inicialização dos shaders: {e}")
            self.shader_program = None  # Indica falha
            return  # Aborta a inicialização da geometria se shaders falharem

        # --- Configurar VAO e VBO para um triângulo ---
        try:
            # Dados do triângulo (Posição XYZ + Cor RGB)
            triangle_data = [
                0.0, 0.5, 0.0, 1.0, 0.0, 0.0,  # Vértice 0: Topo (Vermelho)
                -0.5, -0.5, 0.0, 0.0, 1.0, 0.0,  # Vértice 1: Esquerda (Verde)
                0.5, -0.5, 0.0, 0.0, 0.0, 1.0  # Vértice 2: Direita (Azul)
            ]
            triangle_data = (gl.GLfloat * len(triangle_data))(*triangle_data)

            # Gerar e vincular VAO
            self.VAO = gl.glGenVertexArrays(1)
            gl.glBindVertexArray(self.VAO)

            # Gerar e vincular VBO
            self.VBO = gl.glGenBuffers(1)
            gl.glBindBuffer(gl.GL_ARRAY_BUFFER, self.VBO)
            gl.glBufferData(gl.GL_ARRAY_BUFFER, ctypes.sizeof(triangle_data), triangle_data, gl.GL_STATIC_DRAW)

            # Definir atributos de vértice
            stride = 6 * ctypes.sizeof(gl.GLfloat)
            # Posição (location = 0)
            gl.glVertexAttribPointer(0, 3, gl.GL_FLOAT, gl.GL_FALSE, stride, ctypes.c_void_p(0))
            gl.glEnableVertexAttribArray(0)
            # Cor (location = 1)
            gl.glVertexAttribPointer(1, 3, gl.GL_FLOAT, gl.GL_FALSE, stride,
                                     ctypes.c_void_p(3 * ctypes.sizeof(gl.GLfloat)))
            gl.glEnableVertexAttribArray(1)

            # Desvincular VAO/VBO
            gl.glBindBuffer(gl.GL_ARRAY_BUFFER, 0)
            gl.glBindVertexArray(0)

            print("✅ Shaders compilados e geometria do triângulo configurada.")

        except Exception as e:
            print(f"❌ Erro ao configurar geometria do triângulo: {e}")
            # Limpar shaders em caso de falha na geometria
            if self.shader_program:
                gl.glDeleteProgram(self.shader_program)
                self.shader_program = None
            self.VAO = None
            self.VBO = None

    def resizeGL(self, w, h):
        """
        Chamado sempre que o widget é redimensionado.
        """
        print(f"Redimensionando OpenGL para {w}x{h}")
        gl.glViewport(0, 0, w, h)
        # TODO: Atualizar matriz de projeção se necessário

    def paintGL(self):
        """
        Chamado sempre que a cena OpenGL precisa ser redesenhada.
        """
        # Limpa o buffer com a cor definida em initializeGL
        gl.glClear(gl.GL_COLOR_BUFFER_BIT | gl.GL_DEPTH_BUFFER_BIT)

# --- Componente Janela Principal ---
class JanelaPrincipal(QMainWindow):
    """
    Janela principal da aplicação, contendo a UI 2D e o widget OpenGL.
    Layout: Barras Superior/Inferior (5% da altura),
            Laterais (max(320px, 15% da largura)),
            Área Central para o conteúdo OpenGL.
    """

    def __init__(self):
        super().__init__()
        self.setWindowTitle("Global Arena - Cliente PyQt6")

        # --- Verificar estado de login ANTES de criar os ícones ---
        self.usuario_logado = self._verificar_login()

        # --- Obter dimensões da tela para cálculos ---
        screen_geometry = self.screen().availableGeometry()
        screen_width = screen_geometry.width()
        screen_height = screen_geometry.height()

        # --- Calcular dimensões das barras ---
        bar_height = int(screen_height * 0.05)
        sidebar_width = max(320, int(screen_width * 0.15))

        print(f"🎮 Janela PyQt6 criada. Tela: {screen_width}x{screen_height}. "
              f"Barras H: {bar_height}px, Barras V: {sidebar_width}px")

        # --- Configuração do Layout Central ---
        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        main_window_layout = QVBoxLayout(central_widget)
        main_window_layout.setContentsMargins(0, 0, 0, 0)
        main_window_layout.setSpacing(0)

        # --- Barra Superior ---
        self.barra_superior = self._criar_barra(bar_height, is_horizontal=True, object_name="BarraSuperior")
        layout_barra_superior = QHBoxLayout(self.barra_superior)
        layout_barra_superior.setContentsMargins(10, 5, 10, 5)
        label_status = QLabel("Status: Aguardando...")
        layout_barra_superior.addWidget(label_status)
        layout_barra_superior.addStretch()

        # --- Conteúdo Principal ---
        conteudo_principal_widget = QWidget()
        conteudo_principal_layout = QHBoxLayout(conteudo_principal_widget)
        conteudo_principal_layout.setContentsMargins(0, 0, 0, 0)
        conteudo_principal_layout.setSpacing(0)

        # --- Barra Esquerda com Ícones Interativos ---
        self.barra_esquerda = self._criar_barra(sidebar_width, is_horizontal=False, object_name="BarraEsquerda")

        # Criar gerenciador de ícones
        self.gerenciador_icones = GerenciadorIconesEsquerda(caminho_recursos="client/resources")

        # Atualizar ícone e nome de login com base no estado
        if self.usuario_logado:
            try:
                with open("session.txt", "r") as f:
                    nome_usuario = f.read().strip()
            except Exception as e:
                print(f"❌ Erro ao ler session.txt: {e}")
                nome_usuario = "Usuário"
            self.gerenciador_icones.atualizar_estado_login(True, nome_usuario)

        # Conectar sinal de clique
        self.gerenciador_icones.icone_clicado.connect(self._ao_clicar_icone_lateral)

        # Layout da barra esquerda
        layout_esquerda = QVBoxLayout(self.barra_esquerda)
        layout_esquerda.setContentsMargins(0, 0, 0, 0)
        layout_esquerda.addWidget(self.gerenciador_icones)

        # --- Área Central (OpenGL + Barra Direita) ---
        area_central_widget = QWidget()
        area_central_layout = QHBoxLayout(area_central_widget)
        area_central_layout.setContentsMargins(0, 0, 0, 0)
        area_central_layout.setSpacing(0)

        # --- Criar o Container para OpenGL e Overlay do Título ---
        self.opengl_container = QWidget()
        container_layout = QVBoxLayout(self.opengl_container)
        container_layout.setContentsMargins(0, 0, 0, 0)
        container_layout.setSpacing(0)

        # --- Widget OpenGL ---
        self.opengl_widget = MeuOpenGLWidget()
        self.opengl_widget.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)

        # --- Criar o Overlay Widget para o Título ---
        self.overlay_widget = QWidget(self.opengl_container)
        self.overlay_widget.setWindowFlags(Qt.WindowType.Widget)
        self.overlay_widget.setAttribute(Qt.WidgetAttribute.WA_TranslucentBackground)
        self.overlay_widget.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents)
        self.overlay_widget.setStyleSheet("background: transparent; border: none;")

        # --- Layout do Overlay para o Título e Subtítulo ---
        overlay_layout = QVBoxLayout(self.overlay_widget)
        overlay_layout.setContentsMargins(0, 0, 0, 0)
        overlay_layout.setSpacing(10)
        overlay_layout.setAlignment(Qt.AlignmentFlag.AlignCenter)

        # --- Label: "Welcome to" ---
        self.label_welcome = QLabel("Welcome to")
        font_welcome = QFont()
        font_welcome.setPointSize(14)
        font_welcome.setItalic(True)
        font_welcome.setWeight(500)
        self.label_welcome.setFont(font_welcome)
        self.label_welcome.setStyleSheet("color: #aaaaaa; background: transparent; border: none;")
        self.label_welcome.setAlignment(Qt.AlignmentFlag.AlignCenter)

        # --- Label: "Global Arena" ---
        self.label_titulo = QLabel("Global Arena")
        font_titulo = QFont()
        font_titulo.setPointSize(48)
        font_titulo.setBold(True)
        font_titulo.setWeight(700)
        self.label_titulo.setFont(font_titulo)
        self.label_titulo.setStyleSheet("""
            color: white;
            background-color: transparent;
            border: none;
            text-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
        """)
        self.label_titulo.setAlignment(Qt.AlignmentFlag.AlignCenter)

        # --- Label: Subtítulo ---
        self.label_subtitulo = QLabel("the only one for non-flat-earthers")
        font_subtitulo = QFont()
        font_subtitulo.setPointSize(16)
        font_subtitulo.setItalic(True)
        self.label_subtitulo.setFont(font_subtitulo)
        self.label_subtitulo.setStyleSheet("""
            color: #cccccc;
            background-color: transparent;
            border: none;
            font-style: italic;
        """)
        self.label_subtitulo.setAlignment(Qt.AlignmentFlag.AlignCenter)

        # --- Adicionar ao layout na ordem correta ---
        overlay_layout.addWidget(self.label_welcome)
        overlay_layout.addWidget(self.label_titulo)
        overlay_layout.addWidget(self.label_subtitulo)

        # --- Adicionar Widgets ao Container OpenGL ---
        container_layout.addWidget(self.opengl_widget)

        # --- Correção robusta do resizeEvent ---
        def _safe_resize_event(event):
            self.overlay_widget.setGeometry(self.opengl_container.rect())
            self.overlay_widget.raise_()
            QWidget.resizeEvent(self.opengl_container, event)

        self.opengl_container.resizeEvent = _safe_resize_event

        # --- FORÇAR O OVERLAY A APARECER IMEDIATAMENTE ---
        self.overlay_widget.setGeometry(self.opengl_container.rect())
        self.overlay_widget.raise_()
        self.overlay_widget.show()

        # --- Fallback pós-show: Garante posicionamento após renderização inicial ---
        QTimer.singleShot(50, lambda: [
            self.overlay_widget.setGeometry(self.opengl_container.rect()),
            self.overlay_widget.raise_(),
            self.overlay_widget.show()
        ])

        # --- Barra Direita ---
        self.barra_direita = self._criar_barra(sidebar_width, is_horizontal=False, object_name="BarraDireita")
        layout_direita = QVBoxLayout(self.barra_direita)
        layout_direita.addStretch()
        banner_placeholder = QLabel("Banner\n300x600")
        banner_placeholder.setFixedSize(300, 600)
        banner_placeholder.setStyleSheet("background-color: #333; color: white; border: 1px solid gray;")
        banner_placeholder.setAlignment(Qt.AlignmentFlag.AlignCenter)
        layout_direita.addWidget(banner_placeholder, alignment=Qt.AlignmentFlag.AlignCenter)
        layout_direita.addStretch()

        # --- Adicionar widgets à área central ---
        area_central_layout.addWidget(self.opengl_container)
        area_central_layout.addWidget(self.barra_direita)

        # --- Adicionar widgets ao conteúdo principal ---
        conteudo_principal_layout.addWidget(self.barra_esquerda)
        conteudo_principal_layout.addWidget(area_central_widget)

        # --- Barra Inferior ---
        self.barra_inferior = self._criar_barra(bar_height, is_horizontal=True, object_name="BarraInferior")
        layout_barra_inferior = QHBoxLayout(self.barra_inferior)
        layout_barra_inferior.addWidget(QLabel("Barra Inferior"))

        # --- Adicionar todos os componentes ao layout da janela ---
        main_window_layout.addWidget(self.barra_superior)
        main_window_layout.addWidget(conteudo_principal_widget)
        main_window_layout.addWidget(self.barra_inferior)

        # --- Timer para o Loop Principal ---
        self.timer = QTimer(self)
        self.timer.timeout.connect(self.atualizar_logica)
        self.timer.start(16)  # ~60 FPS

        # --- Mostrar e aplicar fullscreen ---
        self.show()
        self.setWindowState(Qt.WindowState.WindowFullScreen)

        # --- Debug final ---
        print("✅ Janela exibida. Overlay forçado a aparecer.")
        print("🔍 Geometria do container:", self.opengl_container.geometry())
        print("🔍 Geometria do overlay:", self.overlay_widget.geometry())
        print("🔍 Overlay visível?", self.overlay_widget.isVisible())

    def _verificar_login(self):
        """Verifica se o usuário está logado (exemplo: arquivo session.txt existe)."""
        return os.path.exists("session.txt")

    def _criar_barra(self, tamanho, is_horizontal, object_name="Barra"):
        """Cria um widget para representar uma barra, com estilo básico."""
        barra = QFrame()
        barra.setObjectName(object_name)
        if is_horizontal:
            barra.setFixedHeight(tamanho)
        else:
            barra.setFixedWidth(tamanho)
        barra.setStyleSheet(f"""
            #{object_name} {{
                background-color: #2c3e50;
                border: 1px solid #34495e;
            }}
        """)
        return barra

    def atualizar_logica(self):
        """
        Atualiza a lógica do jogo e solicita redesenho do OpenGL.
        """
        self.opengl_widget.update()

    def _ao_clicar_icone_lateral(self, identificador):
        """Lida com os cliques nos ícones da barra lateral esquerda."""
        print(f"🖱️ JanelaPrincipal recebeu clique no ícone: {identificador}")
        if identificador == "login":
            self.on_icone_login()
        elif identificador == "play":
            self.on_icone_play()
        elif identificador == "sair":
            self.on_icone_sair()

    def on_icone_login(self):
        """Ação acionada pelo ícone de login: abre tela de login ou logout."""
        if self.usuario_logado:
            # Já logado → oferece logout
            reply = QMessageBox.question(
                self,
                "Logout",
                "Você está logado. Deseja sair?",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
            )
            if reply == QMessageBox.StandardButton.Yes:
                try:
                    os.remove("session.txt")
                    self.usuario_logado = False
                    self.gerenciador_icones.atualizar_estado_login(False)
                    QMessageBox.information(self, "Logout", "Você saiu com sucesso.")
                except Exception as e:
                    QMessageBox.critical(self, "Erro", f"Falha ao remover sessão: {e}")
        else:
            # Não logado → abre o novo diálogo com Login/Registro
            dialog = DialogoAutenticacao(self)
            if dialog.exec() == QDialog.DialogCode.Accepted:
                # Após login bem-sucedido, atualiza UI
                try:
                    with open("session.txt", "r") as f:
                        nome_usuario = f.read().strip()
                    self.usuario_logado = True
                    self.gerenciador_icones.atualizar_estado_login(True, nome_usuario)
                except Exception as e:
                    print(f"❌ Erro ao ler session.txt: {e}")

    def on_icone_play(self):
        """Ação acionada pelo ícone de play: oferece modo offline ou online."""
        print("Ação: Ícone 'Play' clicado. Oferecendo modos de jogo...")

        modo_dialog = QDialog(self)
        modo_dialog.setWindowTitle("Modo de Jogo")
        modo_dialog.setModal(True)
        modo_dialog.resize(300, 150)

        layout = QVBoxLayout()
        layout.addWidget(QLabel("Escolha o modo de jogo:"))

        btn_offline = QPushButton("Offline")
        btn_online = QPushButton("Online")

        layout.addWidget(btn_offline)
        layout.addWidget(btn_online)

        modo_dialog.setLayout(layout)

        # Vamos controlar o fechamento manualmente
        modo_dialog.accepted.connect(lambda: None)  # Desativar aceitação automática

        def escolher_offline():
            modo_dialog.reject()  # Fecha sem aceitar (para não disparar lógica de online)
            self._ir_para_tela_pre_jogo(offline=True)

        def escolher_online():
            modo_dialog.reject()  # Fecha o diálogo de modo, mas mantém o controle
            if self.usuario_logado:
                self._ir_para_tela_pre_jogo(offline=False)
            else:
                # Abre o diálogo completo (login + registro)
                self._abrir_dialogo_autenticacao_completo(
                    success_callback=lambda u: self._ir_para_tela_pre_jogo(offline=False))

        btn_offline.clicked.connect(escolher_offline)
        btn_online.clicked.connect(escolher_online)

        modo_dialog.exec()

    def _iniciar_offline(self, escolha, dialog):
        escolha[0] = "offline"
        dialog.accept()

    def _iniciar_online(self, escolha, dialog):
        escolha[0] = "online"
        dialog.accept()

        # Verifica login
        if not self.usuario_logado:
            print("Usuário não logado. Abrindo diálogo de autenticação...")
            self._abrir_dialogo_autenticacao_completo(success_callback=self._on_login_sucesso_pre_jogo)
        else:
            self._ir_para_tela_pre_jogo(offline=False)

    def _on_login_sucesso_pre_jogo(self, username: str):
        """Callback chamado após login bem-sucedido no fluxo de 'play online'."""
        print(f"✅ Login bem-sucedido. Iniciando pré-jogo online para {username}.")
        self._ir_para_tela_pre_jogo(offline=False)

    def _ir_para_tela_pre_jogo(self, offline: bool):
        """Redireciona para a tela de pré-jogo (futura implementação)."""
        modo = "Offline" if offline else "Online"
        QMessageBox.information(self, "Pré-Jogo",
                                f"Iniciando modo {modo}...\n(Tela de pré-jogo será implementada em breve.)")
        # Futuro: Trocar para widget de pré-jogo
        # Ex: self.setCentralWidget(TelaPreJogo(offline=offline, parent=self))

    def on_icone_sair(self):
        """Ação acionada pelo ícone de sair."""
        print("Ação: Ícone 'Sair' clicado. Fechando aplicação...")
        self.close()

    def _abrir_dialogo_autenticacao_completo(self, success_callback=None):
        """Abre o diálogo completo de autenticação (login + registro)."""
        dialog = DialogoAutenticacao(parent=self)

        def on_login_sucesso(username: str):
            with open("session.txt", "w") as f:
                f.write(username)
            self.usuario_logado = True
            self.gerenciador_icones.atualizar_estado_login(True, username)
            if success_callback:
                success_callback(username)
            dialog.accept()  # Fecha o diálogo

        def tentar_login():
            username = dialog.username_login.text().strip()
            password = dialog.senha_login.text()
            if not username or not password:
                QMessageBox.warning(dialog, "Erro", "Usuário e senha são obrigatórios.")
                return
            try:
                response = requests.post("http://localhost:5000/auth/login",
                                         json={"username": username, "password": password})
                data = response.json()
                if response.status_code == 200 and data.get("success"):
                    on_login_sucesso(username)
                else:
                    QMessageBox.critical(dialog, "Erro", data.get("message", "Login falhou."))
            except requests.exceptions.ConnectionError:
                QMessageBox.critical(dialog, "Erro", "Não foi possível conectar ao servidor.")
            except Exception as e:
                QMessageBox.critical(dialog, "Erro", f"Erro: {str(e)}")

        def tentar_registro():
            username = dialog.username_registro.text().strip()
            password = dialog.senha_registro.text()
            confirmar = dialog.confirmar_senha.text()
            if not username or not password or not confirmar:
                QMessageBox.warning(dialog, "Erro", "Todos os campos são obrigatórios.")
                return
            if password != confirmar:
                QMessageBox.warning(dialog, "Erro", "As senhas não coincidem.")
                return
            if len(password) < 6:
                QMessageBox.warning(dialog, "Erro", "A senha deve ter pelo menos 6 caracteres.")
                return
            try:
                response = requests.post("http://localhost:5000/auth/registrar",
                                         json={"username": username, "password": password})
                data = response.json()
                if response.status_code == 200 and data.get("success"):
                    QMessageBox.information(dialog, "Sucesso", "Conta criada com sucesso! Faça login.")
                    # Preenche o campo de login e muda para aba de login
                    dialog.username_login.setText(username)
                    dialog.abas.setCurrentIndex(0)
                else:
                    QMessageBox.critical(dialog, "Erro", data.get("message", "Falha no registro."))
            except requests.exceptions.ConnectionError:
                QMessageBox.critical(dialog, "Erro", "Não foi possível conectar ao servidor.")
            except Exception as e:
                QMessageBox.critical(dialog, "Erro", f"Erro: {str(e)}")

        # 🔁 Conecta os botões do QDialogButtonBox ao comportamento correto
        # Remover conexão anterior (se houver)
        try:
            dialog.buttons.accepted.disconnect()
        except TypeError:
            pass  # Já desconectado

        # Conecta "OK" ao comportamento da aba atual
        dialog.buttons.accepted.connect(
            lambda: tentar_login() if dialog.abas.currentIndex() == 0 else tentar_registro()
        )

        # "Cancel" já chama reject() → fecha o diálogo
        dialog.exec()

    def _abrir_tela_login(self):
        """Abre um diálogo de login com campos de usuário e senha."""

        dialog = QDialog(self)
        dialog.setWindowTitle("Entrar")
        dialog.setModal(True)
        dialog.resize(300, 120)

        layout = QFormLayout()

        username_input = QLineEdit()
        password_input = QLineEdit()
        password_input.setEchoMode(QLineEdit.EchoMode.Password)

        layout.addRow("Usuário:", username_input)
        layout.addRow("Senha:", password_input)

        buttons = QDialogButtonBox(QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel)
        layout.addRow(buttons)

        dialog.setLayout(layout)

        def tentar_login():
            username = username_input.text().strip()
            password = password_input.text()

            if not username or not password:
                QMessageBox.warning(dialog, "Erro", "Usuário e senha são obrigatórios.")
                return

            # Enviar requisição ao backend Flask
            try:
                response = requests.post(
                    "http://localhost:5000/auth/login",
                    json={"username": username, "password": password}
                )
                data = response.json()

                if response.status_code == 200 and data.get("success"):
                    # Login bem-sucedido
                    with open("session.txt", "w") as f:
                        f.write(username)
                    self.usuario_logado = True
                    # Atualiza UI: ícone + nome
                    self.gerenciador_icones.atualizar_estado_login(True, username)
                    QMessageBox.information(dialog, "Sucesso", f"Bem-vindo, {username}!")
                    dialog.accept()
                else:
                    QMessageBox.critical(dialog, "Erro", data.get("message", "Login falhou."))
            except requests.exceptions.ConnectionError:
                QMessageBox.critical(dialog, "Erro", "Não foi possível conectar ao servidor.")
            except Exception as e:
                QMessageBox.critical(dialog, "Erro", f"Erro inesperado: {e}")

        buttons.accepted.connect(tentar_login)
        buttons.rejected.connect(dialog.reject)

        dialog.exec()


# --- Ponto de Entrada da Aplicação ---
def main():
    print("🎮 Inicializando cliente gráfico com PyQt6...")
    app = QApplication(sys.argv)

    # Configurar o formato OpenGL padrão globalmente
    fmt = QSurfaceFormat()
    fmt.setVersion(3, 3)
    fmt.setProfile(QSurfaceFormat.OpenGLContextProfile.CoreProfile)
    # fmt.setDepthBufferSize(24)
    # fmt.setSamples(4)
    QSurfaceFormat.setDefaultFormat(fmt)

    try:
        janela = JanelaPrincipal()
        # janela.show() # show() já é chamado dentro de __init__
        print("✅ Janela principal exibida em fullscreen.")
        sys.exit(app.exec())
    except Exception as e:
        print(f"❌ Erro ao criar/iniciar a janela: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)


if __name__ == "__main__":
    # Cria um arquivo session.txt de placeholder para testar o ícone "logado"
    # with open("session.txt", "w") as f:
    #     f.write("usuario_teste_logado")
    main()

================================================================================
📄 client/states/__init__.py
================================================================================


================================================================================
📄 client/dialogs/auth_dialog.py
================================================================================
# client/dialogs/auth_dialog.py
from PyQt6.QtWidgets import (
    QDialog, QTabWidget, QWidget, QFormLayout, QLineEdit,
    QDialogButtonBox, QMessageBox, QVBoxLayout
)
import requests


class DialogoAutenticacao(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Autenticação")
        self.setModal(True)
        self.resize(350, 200)

        layout_principal = QVBoxLayout(self)

        # Abas: Login e Registro
        self.abas = QTabWidget()  # Salvando como atributo para acesso futuro
        self.abas.addTab(self.criar_aba_login(), "Entrar")
        self.abas.addTab(self.criar_aba_registro(), "Registrar")
        layout_principal.addWidget(self.abas)

        # Botões comuns → AGORA salvo como atributo: self.buttons
        self.buttons = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel
        )
        self.buttons.accepted.connect(self.on_ok)
        self.buttons.rejected.connect(self.reject)
        layout_principal.addWidget(self.buttons)

    def criar_aba_login(self):
        widget = QWidget()
        layout = QFormLayout()

        self.username_login = QLineEdit()
        self.username_login.setPlaceholderText("seu_username ou email")
        self.username_login.setToolTip("Digite seu username ou email para login.")
        layout.addRow("Username:", self.username_login)  # ← Aqui também

        self.senha_login = QLineEdit()
        self.senha_login.setEchoMode(QLineEdit.EchoMode.Password)
        layout.addRow("Senha:", self.senha_login)

        widget.setLayout(layout)
        return widget

    def criar_aba_registro(self):
        widget = QWidget()
        layout = QFormLayout()

        self.username_registro = QLineEdit()
        self.username_registro.setPlaceholderText("ex: jogador_42")
        self.username_registro.setToolTip("Seu nome de usuário único. Usado para login.")
        layout.addRow("Username:", self.username_registro)  # ← Alterado de "Usuário"

        self.senha_registro = QLineEdit()
        self.senha_registro.setEchoMode(QLineEdit.EchoMode.Password)
        layout.addRow("Senha:", self.senha_registro)

        self.confirmar_senha = QLineEdit()
        self.confirmar_senha.setEchoMode(QLineEdit.EchoMode.Password)
        layout.addRow("Confirmar:", self.confirmar_senha)

        widget.setLayout(layout)
        return widget

    def on_ok(self):
        """Chamado quando o botão OK é pressionado. Executa login ou registro conforme aba ativa."""
        aba_atual = self.abas.currentIndex()  # ✅ Acesso direto ao QTabWidget
        if aba_atual == 0:
            self.tentar_login()
        else:
            self.tentar_registro()

    def tentar_login(self):
        username = self.username_login.text().strip()
        password = self.senha_login.text()

        if not username or not password:
            QMessageBox.warning(self, "Erro", "Usuário e senha são obrigatórios.")
            return

        try:
            response = requests.post(
                "http://localhost:5000/auth/login",
                json={"username": username, "password": password}
            )
            data = response.json()

            if response.status_code == 200 and data.get("success"):
                with open("session.txt", "w") as f:
                    f.write(username)
                QMessageBox.information(self, "Sucesso", f"Bem-vindo, {username}!")
                self.accept()  # Fecha o diálogo com sucesso
            else:
                QMessageBox.critical(self, "Erro", data.get("message", "Falha no login."))
        except requests.exceptions.ConnectionError:
            QMessageBox.critical(self, "Erro", "Não foi possível conectar ao servidor.")
        except Exception as e:
            QMessageBox.critical(self, "Erro", f"Erro inesperado: {e}")

    def tentar_registro(self):
        username = self.username_registro.text().strip()
        password = self.senha_registro.text()
        confirmar = self.confirmar_senha.text()

        if not username or not password or not confirmar:
            QMessageBox.warning(self, "Erro", "Todos os campos são obrigatórios.")
            return
        if password != confirmar:
            QMessageBox.warning(self, "Erro", "As senhas não coincidem.")
            return
        if len(password) < 6:
            QMessageBox.warning(self, "Erro", "A senha deve ter pelo menos 6 caracteres.")
            return

        try:
            response = requests.post(
                "http://localhost:5000/auth/registrar",
                json={"username": username, "password": password}
            )
            data = response.json()

            if response.status_code == 200 and data.get("success"):
                QMessageBox.information(self, "Sucesso", "Conta criada com sucesso! Faça login.")
                # Podemos mudar para aba de login automaticamente
                self.parent().findChild(QTabWidget).setCurrentIndex(0)
                self.username_login.setText(username)
            else:
                QMessageBox.critical(self, "Erro", data.get("message", "Falha no registro."))
        except requests.exceptions.ConnectionError:
            QMessageBox.critical(self, "Erro", "Não foi possível conectar ao servidor.")
        except Exception as e:
            QMessageBox.critical(self, "Erro", f"Erro inesperado: {e}")

================================================================================
📄 client/components/icon_manager.py
================================================================================
# client/components/icon_manager.py
"""Componentes para gerenciar ícones interativos na barra lateral esquerda."""

import os
from PyQt6.QtWidgets import QLabel, QVBoxLayout, QWidget, QHBoxLayout
from PyQt6.QtCore import Qt, pyqtSignal
from PyQt6.QtGui import QPixmap, QCursor
import traceback


class IconeInterativo(QLabel):
    """
    Um QLabel que exibe uma imagem e emite um sinal quando clicado.
    """
    clicado = pyqtSignal(str)  # Sinal emitido ao ser clicado, passando um identificador

    def __init__(self, icone_path, identificador, tamanho=(64, 64), parent=None):
        """
        :param icone_path: Caminho para o arquivo PNG do ícone.
        :param identificador: String única para identificar este ícone ("login", "play", "sair").
        :param tamanho: Tupla (largura, altura) para redimensionar o ícone.
        :param parent: Widget pai.
        """
        super().__init__(parent)
        self.identificador = identificador
        self.tamanho = tamanho
        self.setAlignment(Qt.AlignmentFlag.AlignCenter)

        # Estilo para feedback visual (opcional)
        self.setStyleSheet("""
            IconeInterativo {
                border: 2px solid transparent; /* Borda invisível por padrão */
                border-radius: 5px; /* Bordas arredondadas */
            }
            IconeInterativo:hover {
                border: 2px solid #3498db; /* Borda azul ao passar o mouse */
                background-color: rgba(52, 152, 219, 30); /* Fundo azul claro transparente */
            }
        """)
        self.setCursor(QCursor(Qt.CursorShape.PointingHandCursor))  # Muda o cursor para mãozinha

        self.carregar_icone(icone_path)
        # Redimensionar o QLabel para o tamanho desejado
        self.setFixedSize(*self.tamanho)

    def carregar_icone(self, caminho):
        """
        Carrega e define a imagem do ícone.
        Inclui verificações detalhadas e logs para facilitar depuração.
        """
        print(f"[DEBUG] [IconeInterativo] Tentando carregar ícone '{self.identificador}' de: '{caminho}'")

        # --- Verificações detalhadas do caminho ---
        caminho_absoluto = os.path.abspath(caminho)
        existe = os.path.exists(caminho)
        eh_arquivo = os.path.isfile(caminho) if existe else False

        print(f"[DEBUG] [IconeInterativo] Caminho absoluto resolvido: '{caminho_absoluto}'")
        print(f"[DEBUG] [IconeInterativo] os.path.exists('{caminho}') = {existe}")
        print(f"[DEBUG] [IconeInterativo] os.path.isfile('{caminho}') = {eh_arquivo}")

        # --- Determinar se o carregamento pode prosseguir ---
        pixmap = None
        if not existe:
            print(
                f"⚠️ [IconeInterativo] O caminho '{caminho}' NÃO EXISTE. Diretório de execução pode estar incorreto. Usando placeholder.")
        elif not eh_arquivo:
            print(
                f"⚠️ [IconeInterativo] O caminho '{caminho}' EXISTE, mas NÃO É um arquivo (pode ser um diretório). Usando placeholder.")
        else:
            # Caminho existe e é um arquivo, tentar carregar com QPixmap
            print(f"[DEBUG] [IconeInterativo] Caminho válido, tentando QPixmap('{caminho}')...")
            try:
                pixmap = QPixmap(caminho)

                # Verificar se o carregamento foi bem-sucedido
                if pixmap.isNull():
                    print(f"⚠️ [IconeInterativo] QPixmap falhou ao carregar o arquivo '{caminho}'. "
                          f"O arquivo pode estar corrompido ou não ser uma imagem válida. Usando placeholder.")
                    pixmap = None  # Forçar uso do placeholder
                else:
                    print(
                        f"[DEBUG] [IconeInterativo] QPixmap carregou com sucesso. Tamanho original: {pixmap.width()}x{pixmap.height()}")

            except Exception as e:
                print(f"❌ [IconeInterativo] Erro inesperado ao carregar QPixmap de '{caminho}': {e}")
                import traceback
                traceback.print_exc()  # Imprime o stack trace completo
                pixmap = None  # Forçar uso do placeholder

        # --- Criar pixmap final (carregada ou placeholder) ---
        if pixmap is None:
            # Criar um pixmap de placeholder se a imagem não for carregada
            pixmap = QPixmap(self.tamanho[0], self.tamanho[1])
            pixmap.fill(Qt.GlobalColor.gray)  # Cor cinza para placeholder
            print(f"[DEBUG] [IconeInterativo] Placeholder cinza criado para '{self.identificador}'.")
        else:
            # Redimensionar a pixmap carregada para o tamanho desejado
            pixmap = pixmap.scaled(
                self.tamanho[0],
                self.tamanho[1],
                Qt.AspectRatioMode.KeepAspectRatio,
                Qt.TransformationMode.SmoothTransformation
            )
            print(
                f"[DEBUG] [IconeInterativo] Pixmap (carregada) redimensionada para {self.tamanho[0]}x{self.tamanho[1]}.")

        # --- Definir a pixmap (carregada ou placeholder) no QLabel ---
        self.setPixmap(pixmap)
        print(f"[DEBUG] [IconeInterativo] Pixmap definida para o ícone '{self.identificador}'.")

    def mousePressEvent(self, event):
        """Sobrescreve para emitir o sinal ao ser clicado."""
        if event.button() == Qt.MouseButton.LeftButton:
            print(f"🖱️ Ícone '{self.identificador}' clicado.")
            self.clicado.emit(self.identificador)  # Emite o sinal com o identificador
        super().mousePressEvent(event)  # Chama o método da classe base


class GerenciadorIconesEsquerda(QWidget):
    """
    Widget que contém e organiza os ícones interativos na barra esquerda.
    """
    icone_clicado = pyqtSignal(str)  # Re-emite o sinal dos ícones filhos

    def __init__(self, caminho_recursos="client/resources", parent=None):
        """
        :param caminho_recursos: Caminho para a pasta com os ícones PNG.
        :param parent: Widget pai.
        """
        super().__init__(parent)
        self.caminho_recursos = caminho_recursos
        self.icones = {}  # Dicionário para armazenar referências aos ícones {identificador: IconeInterativo}
        self.TAMANHO_ICONE = (48, 48)

        # Layout vertical para os ícones
        layout = QVBoxLayout(self)
        layout.setContentsMargins(10, 10, 10, 10)  # Margens internas
        layout.setSpacing(20)  # Espaço entre os ícones
        layout.setAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft)

        # --- Criar e adicionar ícones ---
        # --- Ícone de Login com nome do usuário ---
        icone_login_path = os.path.join(self.caminho_recursos, "log-in.png")
        self.icone_login = IconeInterativo(icone_login_path, "login", tamanho=self.TAMANHO_ICONE)
        self.icone_login.clicado.connect(self._ao_clicar_icone)

        # Layout horizontal para ícone + nome
        self.login_layout = QHBoxLayout()
        self.login_layout.setContentsMargins(0, 0, 0, 0)
        self.login_layout.setSpacing(8)
        self.login_layout.setAlignment(Qt.AlignmentFlag.AlignLeft)

        # Adicionar ícone
        self.login_layout.addWidget(self.icone_login)

        # Label para nome do usuário
        self.label_nome_usuario = QLabel()
        self.label_nome_usuario.setStyleSheet("""
            color: #ecf0f1;
            background: transparent;
            border: none;
            font-size: 14px;
            font-weight: bold;
        """)
        self.label_nome_usuario.hide()
        self.login_layout.addWidget(self.label_nome_usuario)

        # Container final
        self.login_container = QWidget()
        self.login_container.setLayout(self.login_layout)

        # Adicionar ao layout principal
        layout.addWidget(self.login_container)

        # Referência
        self.icones["login"] = self.icone_login

        # Criar um layout horizontal para o ícone + nome
        self.login_layout = QHBoxLayout()
        self.login_layout.setContentsMargins(0, 0, 0, 0)
        self.login_layout.setSpacing(8)  # Espaço entre ícone e texto
        self.login_layout.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)

        # Adicionar ícone
        self.login_layout.addWidget(self.icone_login)

        # Adicionar label de nome (inicialmente oculto)
        self.label_nome_usuario = QLabel()
        self.label_nome_usuario.setStyleSheet("""
            color: #ecf0f1;
            background: transparent;
            border: none;
            font-family: Arial, sans-serif;
            font-size: 14px;
            font-weight: bold;
        """)
        self.label_nome_usuario.hide()  # Esconde por padrão
        self.login_layout.addWidget(self.label_nome_usuario)

        # Container widget para o layout horizontal
        self.login_container = QWidget()
        self.login_container.setLayout(self.login_layout)

        # Adicionar o container ao layout principal
        layout.addWidget(self.login_container)

        # Armazenar referência
        self.icones["login"] = self.icone_login  # Mantém compatibilidade

        # Ícone de Play (Mais abaixo)
        icone_play_path = os.path.join(self.caminho_recursos, "play.png")
        self.icone_play = IconeInterativo(icone_play_path, "play", tamanho=self.TAMANHO_ICONE)
        self.icone_play.clicado.connect(self._ao_clicar_icone)
        layout.addWidget(self.icone_play)
        self.icones["play"] = self.icone_play

        # Espaço elástico para empurrar o ícone de sair para baixo
        layout.addStretch()

        # Ícone de Sair (Inferior Esquerdo)
        icone_sair_path = os.path.join(self.caminho_recursos, "arrow-left.png")
        self.icone_sair = IconeInterativo(icone_sair_path, "sair", tamanho=self.TAMANHO_ICONE)
        self.icone_sair.clicado.connect(self._ao_clicar_icone)
        layout.addWidget(self.icone_sair)
        self.icones["sair"] = self.icone_sair

    def atualizar_estado_login(self, esta_logado: bool, nome_usuario: str = None):
        """
        Atualiza o ícone e mostra/esconde o nome do usuário.
        """
        if esta_logado and nome_usuario:
            caminho = os.path.join(self.caminho_recursos, "smile.png")
            self.icone_login.carregar_icone(caminho)
            self.label_nome_usuario.setText(nome_usuario)
            self.label_nome_usuario.show()
        else:
            caminho = os.path.join(self.caminho_recursos, "log-in.png")
            self.icone_login.carregar_icone(caminho)
            self.label_nome_usuario.hide()

    def _ao_clicar_icone(self, identificador):
        """Slot interno para reemitir o sinal do ícone clicado."""
        print(f"📡 GerenciadorIconesEsquerda: Ícone '{identificador}' acionado.")
        self.icone_clicado.emit(identificador)  # Re-emite o sinal para o consumidor (JanelaPrincipal)

    # Métodos para atualizar ícones, se necessário (ex: login/logout)
    def atualizar_icone(self, identificador, novo_caminho):
        """Atualiza a imagem de um ícone existente."""
        if identificador in self.icones:
            self.icones[identificador].carregar_icone(novo_caminho)
        else:
            print(f"⚠️ GerenciadorIconesEsquerda: Ícone '{identificador}' não encontrado para atualizar.")


================================================================================
📄 client/components/__init__.py
================================================================================


================================================================================
📄 shared/polygons.py
================================================================================
import math
import numpy

def dicionario_poligonos(fator):

    def icosaedro():
        
        def triangulo_original():
            
            def primeira_definicao_pontos():
                lista_pontos = []
                for x in range(fator ** 2):
                    if x % 2 == 0:
                        coord_x = x / 2 + 0.5
                        coord_y = math.sin(math.pi / 6)
                    else:
                        coord_x = x / 2 + 0.5
                        coord_y = math.sqrt(3) / 3
                    lista_pontos.append((round(coord_x, 15), round(coord_y, 15)))
                return lista_pontos
            
            def ponto_por_linha():
                lista_pontos = [0]
                ppf = fator * 2 - 1
                una = fator * 2 - 1
                while una != 1:
                    lista_pontos.append(ppf)
                    ppf += una - 2
                    una -= 2
                return lista_pontos

            def processar_coordenadas(coordenadas, indices):
                r = math.sqrt(3) / 3
                h = math.sqrt(0.75) * fator
                coords = []
                for i in range(len(indices)):
                    if i == len(indices) - 1:
                        segmento = [coordenadas[-1]]
                    else:
                        inicio, fim = indices[i], indices[i + 1]
                        segmento = coordenadas[inicio:fim]
                    for x in range(len(segmento)):
                        coefy = math.sin(math.pi / 6) * r
                        cx = (0.5 * i + 0.5 * x) + 0.5 - fator / 2
                        if x % 2 == 0:
                            cy = 0 + math.sqrt(0.75) * i + coefy - h / 2
                        else:
                            cy = r - coefy + math.sqrt(0.75) * i + coefy - h / 2
                        coords.append((cx, cy))
                return coords
            return processar_coordenadas(primeira_definicao_pontos(), ponto_por_linha())

        to = triangulo_original()

        def triangulos_equatoriais_em_pe():
            raio = fator / (2 * math.sin(math.pi / 5))
            apotema = fator / (2 * math.tan(math.pi / 5))
            theta = math.asin((raio - apotema) / fator)
            h = fator * math.sqrt(0.75)
            t1 = [(x, math.cos(theta) * y, math.sin(theta) * y) for x, y in to]
            t1 = [(x, y, z + apotema + math.sin(theta) * h / 2) for x, y, z in t1]
            return t1

        t1 = triangulos_equatoriais_em_pe()

        def rotacionar_em_torno_do_eixo_y(coordenadas, angulo_graus):
            angulo_radianos = math.radians(angulo_graus)
            cos_theta = math.cos(angulo_radianos)
            sin_theta = math.sin(angulo_radianos)
            coordenadas_rotacionadas = []
            for x, y, z in coordenadas:
                x_novo = cos_theta * x + sin_theta * z
                y_novo = y
                z_novo = -sin_theta * x + cos_theta * z
                coordenadas_rotacionadas.append((x_novo, y_novo, z_novo))
            return coordenadas_rotacionadas

        t2 = rotacionar_em_torno_do_eixo_y(t1, 72)
        t3 = rotacionar_em_torno_do_eixo_y(t1, 144)
        t4 = rotacionar_em_torno_do_eixo_y(t1, 216)
        t5 = rotacionar_em_torno_do_eixo_y(t1, 288)

        def triangulos_equatoriais_invertidos():
            raio = fator / (2 * math.sin(math.pi / 5))
            apotema = fator / (2 * math.tan(math.pi / 5))
            theta = math.asin((raio - apotema) / fator)
            h = fator * math.sqrt(0.75)
            t6 = [(x, -y) for x, y in to]
            t6 = [(x, math.cos(theta) * y, math.sin(theta) * -y) for x, y in t6]
            t6 = [(x, y, z + apotema + math.sin(theta) * h / 2) for x, y, z in t6]
            return t6

        tr = triangulos_equatoriais_invertidos()
        t6 = rotacionar_em_torno_do_eixo_y(tr, 36)
        t7 = rotacionar_em_torno_do_eixo_y(tr, 108)
        t8 = rotacionar_em_torno_do_eixo_y(tr, 180)
        t9 = rotacionar_em_torno_do_eixo_y(tr, 252)
        t10 = rotacionar_em_torno_do_eixo_y(tr, 324)

        def triangulos_polares_norte():
            alpha = math.acos(1 / (2 * math.tan(math.pi / 5) * math.sqrt(0.75)))
            apotema = fator / (2 * math.tan(math.pi / 5))
            h = fator * math.sqrt(0.75)
            deslocamento = apotema - math.cos(alpha) * h / 2
            raio = fator / (2 * math.sin(math.pi / 5))
            theta = math.asin((raio - apotema) / fator)
            deslocamento_vertical = (math.cos(theta) * h / 2) + (math.sin(alpha) * h / 2)
            tr = [(x, 0, -y) for x, y in to]
            tr = [(x, math.sin(alpha) * -z + deslocamento_vertical,
                z * math.cos(alpha) + deslocamento) for x, y, z in tr]
            return tr

        tr = triangulos_polares_norte()

        t11 = rotacionar_em_torno_do_eixo_y(tr, 36)
        t12 = rotacionar_em_torno_do_eixo_y(tr, 108)
        t13 = rotacionar_em_torno_do_eixo_y(tr, 180)
        t14 = rotacionar_em_torno_do_eixo_y(tr, 252)
        t15 = rotacionar_em_torno_do_eixo_y(tr, 324)

        def triangulos_polares_sul():
            alpha = math.acos(1 / (2 * math.tan(math.pi / 5) * math.sqrt(0.75)))
            apotema = fator / (2 * math.tan(math.pi / 5))
            h = fator * math.sqrt(0.75)
            deslocamento = apotema - math.cos(alpha) * h / 2
            raio = fator / (2 * math.sin(math.pi / 5))
            theta = math.asin((raio - apotema) / fator)
            deslocamento_vertical = (math.cos(theta) * h / 2) + (math.sin(alpha) * h / 2)
            t16 = [(x, 0, -y) for x, y in to]
            t16 = [(x, math.sin(alpha) * z - deslocamento_vertical,
                    z * math.cos(alpha) + deslocamento) for x, y, z in t16]
            return t16

        t16 = triangulos_polares_sul()
        t17 = rotacionar_em_torno_do_eixo_y(t16, 72)
        t18 = rotacionar_em_torno_do_eixo_y(t16, 144)
        t19 = rotacionar_em_torno_do_eixo_y(t16, 216)
        t20 = rotacionar_em_torno_do_eixo_y(t16, 288)
        return [t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20]

    def esfera(pontos, raio):

        def projetar_ponto_na_esfera(ponto, raio):
            x, y, z = ponto
            magnitude = math.sqrt(x**2 + y**2 + z**2)
            return (
                raio * x / magnitude,
                raio * y / magnitude,
                raio * z / magnitude
            )

        return [[projetar_ponto_na_esfera(ponto, raio) for ponto in lista] for lista in pontos]

    esfera = esfera(icosaedro(), fator)

    def poligonos():
        poligonos = []
        
        def ponto_por_linha():
            lista_pontos = [0]
            ppf = fator * 2 - 1
            una = fator * 2 - 1
            while una != 1:
                lista_pontos.append(ppf)
                ppf += una - 2
                una -= 2
            return lista_pontos

        p = ponto_por_linha()

        def hexagonos_centrais():
            hexagonos = []
            for t in esfera:
                i = 0
                for x in range(fator - 2, 0, -1):
                    for y in range(x):
                        hexagonos.append(numpy.array([
                            t[p[y] + i * 2 + 1],
                            t[p[y] + i * 2 + 2],
                            t[p[y] + i * 2 + 3],
                            t[p[y + 1] + i * 2 + 2],
                            t[p[y + 1] + i * 2 + 1],
                            t[p[y + 1] + i * 2]
                        ]))
                    i += 1
            return hexagonos

        poligonos.append(hexagonos_centrais())

        def hexagonos_tropicais_sul():
            hexagonos = []
            for x in range(5):
                for y in range(fator - 1):
                    hexagonos.append(numpy.array([
                        esfera[x][y * 2],
                        esfera[x][y * 2 + 1],
                        esfera[x][y * 2 + 2],
                        esfera[x + 15][y * 2 + 2],
                        esfera[x + 15][y * 2 + 1],
                        esfera[x + 15][y * 2]
                    ]))
            return hexagonos

        poligonos.append(hexagonos_tropicais_sul())

        def hexagonos_tropicais_norte():
            hexagonos = []
            for x in range(5, 10, 1):
                for y in range(fator - 1):
                    hexagonos.append(numpy.array([
                        esfera[x][y * 2],
                        esfera[x][y * 2 + 1],
                        esfera[x][y * 2 + 2],
                        esfera[x + 5][y * 2 + 2],
                        esfera[x + 5][y * 2 + 1],
                        esfera[x + 5][y * 2]
                    ]))
            return hexagonos

        poligonos.append(hexagonos_tropicais_norte())

        def hexagonos_equatoriais_ascendentes():
            hexagonos = []
            for x in range(5):
                for y in range(fator - 1):
                    if x == 0:
                        hexagonos.append(numpy.array([
                            esfera[x][p[y]],
                            esfera[x][p[y] + 1],
                            esfera[x][p[y + 1]],
                            esfera[x + 9][p[fator - y - 1] - 1],
                            esfera[x + 9][p[fator - y - 1] - 2],
                            esfera[x + 9][p[fator - y - 1] + 2 * y]
                        ]))
                    else:
                        hexagonos.append(numpy.array([
                            esfera[x][p[y]],
                            esfera[x][p[y] + 1],
                            esfera[x][p[y + 1]],
                            esfera[x + 4][p[fator - y - 1] - 1],
                            esfera[x + 4][p[fator - y - 1] - 2],
                            esfera[x + 4][p[fator - y - 1] + 2 * y]
                        ]))
            return hexagonos

        poligonos.append(hexagonos_equatoriais_ascendentes())

        def hexagonos_equatoriais_descendentes():
            hexagonos = []
            for x in range(5):
                for y in range(fator - 1):
                    hexagonos.append(numpy.array([
                        esfera[x][p[fator - 1 - y] + 2 * y],
                        esfera[x][p[fator - 1 - y] - 2],
                        esfera[x][p[fator - 1 - y] - 1],
                        esfera[x + 5][p[y + 1]],
                        esfera[x + 5][p[y] + 1],
                        esfera[x + 5][p[y]]
                    ]))
            return hexagonos

        poligonos.append(hexagonos_equatoriais_descendentes())

        def hexagonos_polares_norte():
            hexagonos = []
            for x in range(10, 15, 1):
                for y in range(fator - 1):
                    if x == 10:
                        hexagonos.append(numpy.array([
                            esfera[x][p[y]],
                            esfera[x][p[y] + 1],
                            esfera[x][p[y + 1]],
                            esfera[x + 4][p[y + 1] + (fator - y - 2) * 2],
                            esfera[x + 4][p[y + 1] - 2],
                            esfera[x + 4][p[y + 1] - 1]
                        ]))
                    else:
                        hexagonos.append(numpy.array([
                            esfera[x][p[y]],
                            esfera[x][p[y] + 1],
                            esfera[x][p[y + 1]],
                            esfera[x - 1][p[y + 1] + (fator - y - 2) * 2],
                            esfera[x - 1][p[y + 1] - 2],
                            esfera[x - 1][p[y + 1] - 1]
                        ]))
            return hexagonos

        poligonos.append(hexagonos_polares_norte())

        def hexagonos_polares_sul():
            hexagonos = []
            for x in range(15, 20):
                for y in range(fator - 1):
                    if x == 15:
                        hexagonos.append(numpy.array([
                            esfera[x][p[y]],
                            esfera[x][p[y] + 1],
                            esfera[x][p[y + 1]],
                            esfera[x + 4][p[y + 1] + (fator - y - 2) * 2],
                            esfera[x + 4][p[y + 1] - 2],
                            esfera[x + 4][p[y + 1] - 1]
                        ]))
                    else:
                        hexagonos.append(numpy.array([
                            esfera[x][p[y]],
                            esfera[x][p[y] + 1],
                            esfera[x][p[y + 1]],
                            esfera[x - 1][p[y + 1] + (fator - y - 2) * 2],
                            esfera[x - 1][p[y + 1] - 2],
                            esfera[x - 1][p[y + 1] - 1]
                        ]))
            return hexagonos

        poligonos.append(hexagonos_polares_sul())

        def pentagonos():

            pentagonos = []

            def pentagonos_tropicais_sul():
                pentagonos = []
                for x in range(5):
                    if x == 0:
                        pentagonos.append(numpy.array([
                            esfera[0][0],
                            esfera[9][p[fator - 1]],
                            esfera[4][p[1] - 1],
                            esfera[19][p[1] - 1],
                            esfera[15][0]
                        ]))
                    else:
                        pentagonos.append(numpy.array([
                            esfera[x][0],
                            esfera[x + 4][p[fator - 1]],
                            esfera[x - 1][p[1] - 1],
                            esfera[x + 14][p[1] - 1],
                            esfera[x + 15][0]
                        ]))
                return pentagonos

            pentagonos.extend(pentagonos_tropicais_sul())

            def pentagonos_tropicais_norte():
                pentagonos = []
                for x in range(5):
                    if x == 0:
                        pentagonos.append(numpy.array([
                            esfera[0][p[fator - 1]],
                            esfera[5][0],
                            esfera[10][0],
                            esfera[14][p[1] - 1],
                            esfera[9][p[1] - 1]
                        ]))
                    else:
                        pentagonos.append(numpy.array([
                            esfera[x][p[fator - 1]],
                            esfera[x + 5][0],
                            esfera[x + 10][0],
                            esfera[x + 9][p[1] - 1],
                            esfera[x + 4][p[1] - 1]
                        ]))
                return pentagonos

            pentagonos.extend(pentagonos_tropicais_norte())

            def pentagono_polo_norte():
                return numpy.array([
                    esfera[10][p[fator - 1]],
                    esfera[11][p[fator - 1]],
                    esfera[12][p[fator - 1]],
                    esfera[13][p[fator - 1]],
                    esfera[14][p[fator - 1]]
                ])

            pentagonos.append(pentagono_polo_norte())

            def pentagono_polo_sul():
                return numpy.array([
                    esfera[15][p[fator - 1]],
                    esfera[16][p[fator - 1]],
                    esfera[17][p[fator - 1]],
                    esfera[18][p[fator - 1]],
                    esfera[19][p[fator - 1]]
                ])

            pentagonos.append(pentagono_polo_sul())
            
            return pentagonos

        poligonos.append(pentagonos())

        return poligonos

    poligonos = poligonos()

    def dic_pol():
        coord_vert = {}
        h = 0
        for x in range(5):        
            for i, z in enumerate(range(fator - 2, 0, -1)):
                n = fator * 2 - 1
                for a in range(z):
                    coord_vert[(n - a, fator * x + i + 1)] = poligonos[0][h]
                    h += 1

        for x in range(5):
            for i, z in enumerate(range(fator - 2, 0, -1)):
                n = fator + 1
                for a in range(z):
                    coord_vert[(n + a, fator * x + 2 + i + a)] = poligonos[0][h]
                    h += 1

        for x in range(5):
            for i, z in enumerate(range(fator - 2, 0, -1)):
                n = fator - 1
                for a in range(z):
                    coord_vert[(n - a, fator * x + 1 - x * (a + 1) + i)] = poligonos[0][h]
                    h += 1

        for x in range(5):
            b = fator * x + 1 - x
            for i, z in enumerate(range(fator - 2, 0, -1)):
                n = fator * 2 + 1
                for a in range(z):
                    coord_vert[(n + a, b + i - a * x)] = poligonos[0][h]
                    h += 1
        h = 0
        for x in range(5):
            for z in range(fator - 1):
                coord_vert[(fator * 2, fator * x + z + 1)] = poligonos[1][h]
                h += 1
        h = 0
        for x in range(5):
            for z in range(fator - 1):
                coord_vert[(fator, fator * x + z + 1)] = poligonos[2][h]
                h += 1
        h = 0
        for x in range(5):
            for z in range(fator - 1):
                coord_vert[(fator * 2 - z - 1, fator * x)] = poligonos[3][h]
                h += 1
        h = 0
        for x in range(5):
            for z in range(fator - 1):
                coord_vert[(fator + z + 1, fator * x + z + 1)] = poligonos[4][h]
                h += 1
        h = 0
        for x in range(5):
            for z in range(fator - 1):
                coord_vert[(fator - z - 1, (fator - z - 1) * x)] = poligonos[5][h]
                h += 1
        h = 0
        for x in range(5):
            for i, z in enumerate(range(fator - 1, 0, -1)):
                coord_vert[(fator * 2 + i + 1, z * x)] = poligonos[6][h]
                h += 1
        h = 0
        for x in range(5):
            coord_vert[(fator * 2, fator * x)] = poligonos[7][h]
            h += 1
        for x in range(5):
            coord_vert[(fator, fator * x)] = poligonos[7][h]
            h += 1
        coord_vert[(0, 0)] = poligonos[7][h]
        h += 1
        coord_vert[(fator * 3, 0)] = poligonos[7][h]

        return coord_vert
    
    return dic_pol()

================================================================================
📄 shared/planet.py
================================================================================
import random
from shared.polygons import dicionario_poligonos
from shared.geography import definir_geografia

class Planeta:
    def __init__(self, fator, bioma):
        self.fator = fator
        self.bioma_inicial = bioma
        self.geografia, self.capitais_players = definir_geografia(dicionario_poligonos(fator), fator, bioma) # capitais = [(int, int), ...]
        random.shuffle(self.capitais_players)
        self.numero_de_jogadores = len(self.capitais_players)
        biomas_invalidos = {"Ice", "Sea", "Ocean", "Coast", bioma}
        capitais_player_set = set(self.capitais_players)
        nodos_validos = [
            n for n in self.geografia.nodes()
            if self.geografia.nodes[n]["bioma"] not in biomas_invalidos and n not in capitais_player_set
        ]
        npn = 27 - len(self.capitais_players)  # Lembrar de evitar npn (países neutros) negativo
        self.capitais_neutros = random.sample(nodos_validos, npn)
        random.shuffle(self.capitais_neutros)
        self.civilizacoes = []


================================================================================
📄 shared/geography.py
================================================================================
import networkx
import random
import math
from statistics import mean
from random import choice

# CUSTOS BASE
CUSTOS_BASE = {
    'Ice': 20.0,
    'Mountains': 12.0,
    'Hills': 6.0,
    'Forest': 4.0,
    'Meadow': 3.0,
    'Savanna': 4.0,
    'Desert': 5.0,
    'Coast': 0.8,
    'Sea': 0.6,
    'Ocean': 0.4
}

PENALIDADE_TRANSICAO = 15.0

def letra_grega(placa):
    letras_gregas_dict = {
        "Alpha": "Α", "Beta": "Β", "Gamma": "Γ", "Delta": "Δ",
        "Epsilon": "Ε", "Zeta": "Ζ", "Eta": "Η", "Theta": "Θ",
        "Iota": "Ι", "Kappa": "Κ", "Lambda": "Λ", "Mu": "Μ",
        "Nu": "Ν", "Xi": "Ξ", "Omicron": "Ο", "Pi": "Π",
        "Rho": "Ρ", "Sigma": "Σ", "Tau": "Τ", "Upsilon": "Υ",
        "Phi": "Φ", "Chi": "Χ", "Psi": "Ψ", "Omega": "Ω"
    }
    return letras_gregas_dict.get(placa)

def definir_geografia(poligonos, fator, bioma):

    geografia = networkx.DiGraph()

    for coordenadas in poligonos:
        geografia.add_node(coordenadas)

    def tipo_de_poligono(c):
        if c == (0, 0):
            geografia.nodes[c]['tipo'] = 'pn'
            return "pn"
        elif 0 < c[0] < fator and c[1] % c[0] == 0:
            geografia.nodes[c]['tipo'] = 'ipn'
            return "ipn"
        elif 0 < c[0] < fator and c[1] % c[0] != 0:
            geografia.nodes[c]['tipo'] = 'cpn'
            return "cpn"
        elif c[0] == fator and c[1] % c[0] == 0:
            geografia.nodes[c]['tipo'] = 'ntn'
            return "ntn"
        elif c[0] == fator and c[1] % c[0] != 0:
            geografia.nodes[c]['tipo'] = 'itn'
            return "itn"
        elif fator < c[0] < fator * 2:
            geografia.nodes[c]['tipo'] = 'e'
            return "e"
        elif c[0] == fator * 2 and c[1] % fator != 0:
            geografia.nodes[c]['tipo'] = 'its'
            return "its"
        elif c[0] == fator * 2 and c[1] % fator == 0:
            geografia.nodes[c]['tipo'] = 'nts'
            return "nts"
        elif fator * 2 < c[0] < fator * 3 and c[1] % (fator * 3 - c[0]) != 0:
            geografia.nodes[c]['tipo'] = 'cps'
            return "cps"
        elif fator * 2 < c[0] < fator * 3 and c[1] % (fator * 3 - c[0]) == 0:
            geografia.nodes[c]['tipo'] = 'ips'
            return "ips"
        elif c[0] == fator * 3:
            geografia.nodes[c]['tipo'] = 'ps'
            return "ps"

    for n in list(geografia.nodes):
        no = tipo_de_poligono(n)
        if no == "pn":
            for y in range(5):
                geografia.add_edge(n, (1, y), direcao=f'S{y+1}')
            continue
        if no == "ps":
            for y in range(5):
                geografia.add_edge(n, (fator * 3 - 1, y), direcao=f'N{y+1}')
            continue
        x = n[1] // n[0]
        y = n[1] // (fator * 3 - n[0])
        if no == "ipn":
            if n[1] != n[0] * 5 - 1:
                geografia.add_edge(n, (n[0] + 1, n[1] + x), direcao='S')
                geografia.add_edge(n, (n[0] + 1, n[1] + x + 1), direcao='SE')
                geografia.add_edge(n, (n[0], n[1] + 1), direcao='E')
                geografia.add_edge(n, (n[0] - 1, n[1] - x), direcao='N')
                geografia.add_edge(n, (n[0], n[1] - 1), direcao='W') if n[1] != 0 else geografia.add_edge(n, (n[0], n[0] * 5 - 1), direcao='W')
                geografia.add_edge(n, (n[0] + 1, n[1] + x - 1), direcao='SW') if n[1] != 0 else \
                                        geografia.add_edge(n, (n[0] + 1, (n[0] + 1) * 5 - 1), direcao='SW')
            else:
                geografia.add_edge(n, (n[0] + 1, n[1] + x), direcao='S')
                geografia.add_edge(n, (n[0] + 1, n[1] + x + 1), direcao='SE')
                geografia.add_edge(n, (n[0], 0), direcao='E')
                geografia.add_edge(n, (n[0] - 1, n[1] - x), direcao='N')
                geografia.add_edge(n, (n[0], n[1] - 1), direcao='W')
                geografia.add_edge(n, (n[0] + 1, n[1] + x - 1), direcao='SW')
        elif no == "cpn":
            if n[1] != n[0] * 5 - 1:
                geografia.add_edge(n, (n[0] + 1, n[1] + x + 1), direcao='SE')
                geografia.add_edge(n, (n[0], n[1] + 1), direcao='E')
                geografia.add_edge(n, (n[0] - 1, n[1] - x), direcao='NE')
                geografia.add_edge(n, (n[0] - 1, n[1] - x - 1), direcao='NW')
                geografia.add_edge(n, (n[0], n[1] - 1), direcao='W')
                geografia.add_edge(n, (n[0] + 1, n[1] + x), direcao='SW')
            else:
                geografia.add_edge(n, (n[0] + 1, n[1] + x + 1), direcao='SE')
                geografia.add_edge(n, (n[0], 0), direcao='E')
                geografia.add_edge(n, (n[0] - 1, 0), direcao='NE')
                geografia.add_edge(n, (n[0] - 1, n[1] - x - 1), direcao='NW')
                geografia.add_edge(n, (n[0], n[1] - 1), direcao='W')
                geografia.add_edge(n, (n[0] + 1, n[1] + x), direcao='SW')
        elif no == "ntn":
            geografia.add_edge(n, (n[0] + 1, n[1]), direcao='SW')
            geografia.add_edge(n, (n[0] + 1, n[1] + 1), direcao='SE')
            geografia.add_edge(n, (n[0], n[1] + 1), direcao='NE')
            geografia.add_edge(n, (n[0] - 1, n[1] - x), direcao='N')
            geografia.add_edge(n, (n[0], n[1] - 1), direcao='NW') if n[1] != 0 else geografia.add_edge(n, (n[0], n[0] * 5 - 1), direcao='NW')
        elif no == "itn":
            if n[1] != fator * 5 - 1:
                geografia.add_edge(n, (n[0] + 1, n[1]), direcao='SW')
                geografia.add_edge(n, (n[0] + 1, n[1] + 1), direcao='NE')
                geografia.add_edge(n, (n[0], n[1] + 1), direcao='E')
                geografia.add_edge(n, (n[0] - 1, n[1] - x), direcao='NE')
                geografia.add_edge(n, (n[0] - 1, n[1] - x - 1), direcao='NW')
                geografia.add_edge(n, (n[0], n[1] - 1), direcao='W')
            else:
                geografia.add_edge(n, (n[0] + 1, n[1]), direcao='SW')
                geografia.add_edge(n, (n[0] + 1, 0), direcao='NE')
                geografia.add_edge(n, (n[0], 0), direcao='E')
                geografia.add_edge(n, (n[0] - 1, 0), direcao='NE')
                geografia.add_edge(n, (n[0] - 1, n[1] - x - 1), direcao='NW')
                geografia.add_edge(n, (n[0], n[1] - 1), direcao='W')
        elif no == "e":
            if n[1] != fator * 5 - 1:
                geografia.add_edge(n, (n[0] + 1, n[1]), direcao='SW')
                geografia.add_edge(n, (n[0] + 1, n[1] + 1), direcao='SE')
                geografia.add_edge(n, (n[0], n[1] + 1), direcao='E')
                geografia.add_edge(n, (n[0] - 1, n[1]), direcao='NE')
                geografia.add_edge(n, (n[0] - 1, n[1] - 1), direcao='NW') if n[1] != 0 else geografia.add_edge(n, (n[0] - 1, fator * 5 - 1), direcao='NW')
                geografia.add_edge(n, (n[0], n[1] - 1), direcao='W') if n[1] != 0 else geografia.add_edge(n, (n[0], fator * 5 - 1), direcao='W')
            else:
                geografia.add_edge(n, (n[0] + 1, n[1]), direcao='SW')
                geografia.add_edge(n, (n[0] + 1, 0), direcao='SE')
                geografia.add_edge(n, (n[0], 0), direcao='E')
                geografia.add_edge(n, (n[0] - 1, n[1]), direcao='NE')
                geografia.add_edge(n, (n[0] - 1, n[1] - 1), direcao='NW')
                geografia.add_edge(n, (n[0], n[1] - 1), direcao='W')
        elif no == "its":
            if n[1] != fator * 5 - 1:
                geografia.add_edge(n, (n[0] + 1, n[1] - y), direcao='SE')
                geografia.add_edge(n, (n[0], n[1] + 1), direcao='E')
                geografia.add_edge(n, (n[0] - 1, n[1]), direcao='NE')
                geografia.add_edge(n, (n[0] - 1, n[1] - 1), direcao='NW')
                geografia.add_edge(n, (n[0], n[1] - 1), direcao='W')
                geografia.add_edge(n, (n[0] + 1, n[1] - y - 1), direcao='SW')
            else:
                geografia.add_edge(n, (n[0] + 1, 0), direcao='SE')
                geografia.add_edge(n, (n[0], 0), direcao='E')
                geografia.add_edge(n, (n[0] - 1, n[1]), direcao='NE')
                geografia.add_edge(n, (n[0] - 1, n[1] - 1), direcao='NW')
                geografia.add_edge(n, (n[0], n[1] - 1), direcao='W')
                geografia.add_edge(n, (n[0] + 1, n[1] - y - 1), direcao='SW')
        elif no == "nts":
            geografia.add_edge(n, (n[0] + 1, n[1] - y), direcao='S')
            geografia.add_edge(n, (n[0], n[1] + 1), direcao='SE')
            geografia.add_edge(n, (n[0] - 1, n[1]), direcao='NE')
            geografia.add_edge(n, (n[0] - 1, n[1] - 1), direcao='NW') if n[1] != 0 else geografia.add_edge(n, (n[0] - 1, fator * 5 - 1), direcao='NW')
            geografia.add_edge(n, (n[0], n[1] - 1), direcao='SW') if n[1] != 0 else geografia.add_edge(n, (n[0], fator * 5 - 1), direcao='SW')
        elif no == "cps":
            if n[1] != (fator * 3 - n[0]) * 5 - 1:
                geografia.add_edge(n, (n[0] + 1, n[1] - y), direcao='SE')
                geografia.add_edge(n, (n[0], n[1] + 1), direcao='E')
                geografia.add_edge(n, (n[0] - 1, n[1] + y + 1), direcao='NE')
                geografia.add_edge(n, (n[0] - 1, n[1] + y), direcao='NW')
                geografia.add_edge(n, (n[0], n[1] - 1), direcao='W')
                geografia.add_edge(n, (n[0] + 1, n[1] - y - 1), direcao='SW')
            else:
                geografia.add_edge(n, (n[0] + 1, 0), direcao='SE')
                geografia.add_edge(n, (n[0], 0), direcao='E')
                geografia.add_edge(n, (n[0] - 1, n[1] + y + 1), direcao='NE')
                geografia.add_edge(n, (n[0] - 1, n[1] + y), direcao='NW')
                geografia.add_edge(n, (n[0], n[1] - 1), direcao='W')
                geografia.add_edge(n, (n[0] + 1, n[1] - y - 1), direcao='SW')
        elif no == "ips":
            if n[1] != (fator * 3 - n[0]) * 5 - 1:
                geografia.add_edge(n, (n[0] + 1, n[1] - y), direcao='S')
                geografia.add_edge(n, (n[0], n[1] + 1), direcao='SE')
                geografia.add_edge(n, (n[0] - 1, n[1] + y + 1), direcao='NE')
                geografia.add_edge(n, (n[0] - 1, n[1] + y), direcao='N')
                geografia.add_edge(n, (n[0] - 1, n[1] + y - 1), direcao='NW') if n[1] != 0 else \
                                        geografia.add_edge(n, (n[0] - 1, (fator * 3 - n[0] + 1) * 5 - 1), direcao='NW')
                geografia.add_edge(n, (n[0], n[1] - 1), direcao='SW') if n[1] != 0 else \
                                        geografia.add_edge(n, (n[0], (fator * 3 - n[0]) * 5 - 1), direcao='SW')
            else:
                geografia.add_edge(n, (n[0] + 1, n[1] - y), direcao='S')
                geografia.add_edge(n, (n[0], 0), direcao='SE')
                geografia.add_edge(n, (n[0] - 1, n[1] + y + 1), direcao='NE')
                geografia.add_edge(n, (n[0] - 1, n[1] + y), direcao='N')
                geografia.add_edge(n, (n[0] - 1, n[1] + y - 1), direcao='NW')
                geografia.add_edge(n, (n[0], n[1] - 1), direcao='SW')

    areas = list(poligonos.keys())
    areas_sem_definicao = {}
    areas_definidas = {}
    referencias_relevo = random.sample(areas, fator * 20)

    for area in areas:
        areas_sem_definicao[area] = []
        areas_definidas[area] = []

    for n in range(fator * 3 // 2):
        if not areas_sem_definicao:
            break
        for node in referencias_relevo:
            altitude = random.randint(0, 12)
            areas_definidas[node].append(altitude)
            if node in areas_sem_definicao:
                del areas_sem_definicao[node]
            distancias = networkx.single_source_shortest_path_length(geografia, node)
            nos_a_n_arestas = [node for node, distance in distancias.items() if distance == n + 1]
            for neighbor in nos_a_n_arestas:
                if neighbor in areas_sem_definicao and neighbor not in referencias_relevo:
                    areas_sem_definicao[neighbor].append(altitude)
        for chave in list(areas_sem_definicao.keys()):
            if areas_sem_definicao[chave]:
                areas_definidas[chave].append(round(mean(areas_sem_definicao[chave]), 3))
                del areas_sem_definicao[chave]

    chaves = list(areas_definidas.keys())
    random.shuffle(chaves)
    chaves_ordenadas = sorted(chaves, key=lambda chave: areas_definidas[chave])
    percentual_terra = random.randint(35, 45)
    limite_abissal = (100 - percentual_terra) // 2
    limite_barreira = limite_abissal + (100 - percentual_terra) // 3
    nivel_do_mar = 100 - percentual_terra
    limite_planicie = nivel_do_mar + (100 - nivel_do_mar) * 4 // 6
    limite_planalto = limite_planicie + (100 - limite_planicie) // 2

    for i, chave in enumerate(chaves_ordenadas):
        if i <= len(chaves_ordenadas) * limite_abissal // 100:
            geografia.nodes[chave]['altitude'] = 'abissal'
        elif i <= len(chaves_ordenadas) * limite_barreira // 100:
            geografia.nodes[chave]['altitude'] = 'barreira'
        elif i <= len(chaves_ordenadas) * nivel_do_mar // 100:
            geografia.nodes[chave]['altitude'] = 'plataforma'
        elif i <= len(chaves_ordenadas) * limite_planicie // 100:
            geografia.nodes[chave]['altitude'] = 'planicie'
        elif i <= len(chaves_ordenadas) * limite_planalto // 100:
            geografia.nodes[chave]['altitude'] = 'planalto'
        else:
            geografia.nodes[chave]['altitude'] = 'cordilheira'

    areas_sem_definicao = {}
    areas_definidas = {}
    referencias_umidade = random.sample(areas, 60)

    for area in areas:
        areas_sem_definicao[area] = []
        areas_definidas[area] = []

    for n in range(fator * 3 // 2):
        if not areas_sem_definicao:
            break
        for node in referencias_umidade:
            altitude = random.randint(0, 12)
            areas_definidas[node].append(altitude)
            if node in areas_sem_definicao:
                del areas_sem_definicao[node]
            distancias = networkx.single_source_shortest_path_length(geografia, node)
            nos_a_n_arestas = [node for node, distance in distancias.items() if distance == n + 1]
            for neighbor in nos_a_n_arestas:
                if neighbor in areas_sem_definicao and neighbor not in referencias_umidade:
                    areas_sem_definicao[neighbor].append(altitude)
        for chave in list(areas_sem_definicao.keys()):
            if areas_sem_definicao[chave]:
                areas_definidas[chave].append(round(mean(areas_sem_definicao[chave]), 3))
                del areas_sem_definicao[chave]

    chaves = list(areas_definidas.keys())
    random.shuffle(chaves)
    chaves_ordenadas = sorted(chaves, key=lambda chave: areas_definidas[chave])

    for i, chave in enumerate(chaves_ordenadas):
        if i <= len(chaves_ordenadas) * 25 // 100:
            geografia.nodes[chave]['umidade'] = 'arido'
        elif i <= len(chaves_ordenadas) * 50 // 100:
            geografia.nodes[chave]['umidade'] = 'semi-arido'
        elif i <= len(chaves_ordenadas) * 75 // 100:
            geografia.nodes[chave]['umidade'] = 'fertil'
        else:
            geografia.nodes[chave]['umidade'] = 'umido'

    # Definição das placas com dois pontos de referência cada
    placas = ['Alpha', 'Beta', 'Gamma', 'Delta', 'Epsilon', 'Zeta',
            'Eta', 'Theta', 'Iota', 'Kappa', 'Lambda', 'Mu',
            'Nu', 'Xi', 'Omicron', 'Pi', 'Rho', 'Sigma',
            'Tau', 'Upsilon', 'Phi', 'Chi', 'Psi', 'Omega']
    
    # Gerar duas referências para cada placa (total 48)
    placas_duplicadas = placas * 2
    random.shuffle(placas_duplicadas)
    referencias_geologia = random.sample(areas, 48)

    # Atribuir cada referência a uma placa
    areas_definidas = {area: None for area in areas}
    for i, node in enumerate(referencias_geologia):
        areas_definidas[node] = placas_duplicadas[i]

    # Calcular a placa para cada nó baseado na proximidade
    for node in areas_definidas:
        if areas_definidas[node] is not None:
            continue  # Pula pontos de referência já definidos
        
        # Encontrar todas as distâncias para pontos de referência
        distancias = []
        for ref in referencias_geologia:
            try:
                dist = networkx.shortest_path_length(geografia, ref, node)
                distancias.append( (ref, dist) )
            except networkx.exception.NetworkXNoPath:
                continue
        
        if not distancias:
            areas_definidas[node] = random.choice(placas)
            continue
        
        # Encontrar a distância mínima
        min_dist = min(d[1] for d in distancias)
        candidatos = [d[0] for d in distancias if d[1] == min_dist]
        
        # Escolher aleatoriamente entre candidatos equidistantes
        ref_escolhida = random.choice(candidatos)
        areas_definidas[node] = areas_definidas[ref_escolhida]
    
    coeficiente_movimento = 300

    # Gerar cores para as placas
    cores_placas = []
    for _ in range(24):
        while True:
            r = random.randint(0, 255)
            g = random.randint(0, 255)
            b = random.randint(0, 255)
            if (r + g + b) > 127.5:
                cores_placas.append((r, g, b))
                break

    latitude_equador = fator * 3 / 2

    for chave, valor in areas_definidas.items():
        geografia.nodes[chave]['placa'] = valor
        geografia.nodes[chave]['cor_placa'] = cores_placas[placas.index(valor)]
        geografia.nodes[chave]['letra_grega'] = letra_grega(geografia.nodes[chave]['placa'])
        if chave[0] < latitude_equador:
            distancia_para_equador = latitude_equador - chave[0]
            angulo = distancia_para_equador * 90 / latitude_equador
            incidencia_solar = math.cos(math.radians(angulo))
        elif chave[0] == latitude_equador:
            distancia_para_equador = 0
            angulo = distancia_para_equador * 90 / latitude_equador
            incidencia_solar = math.cos(math.radians(angulo))
        else:
            distancia_para_equador = chave[0] - latitude_equador
            angulo = distancia_para_equador * 90 / latitude_equador
            incidencia_solar = math.cos(math.radians(angulo))
        if geografia.nodes[chave]['altitude'] == 'abissal' \
        or geografia.nodes[chave]['altitude'] == 'barreira' \
        or geografia.nodes[chave]['altitude'] == 'plataforma':
            fator_altitude = 3
        elif geografia.nodes[chave]['altitude'] == 'planicie':
            fator_altitude = 1
        elif geografia.nodes[chave]['altitude'] == 'planalto':
            fator_altitude = -1
        elif geografia.nodes[chave]['altitude'] == 'cordilheira':
            fator_altitude = -3
        if geografia.nodes[chave]['umidade'] == 'umido':
            fator_umidade = 1.5
        elif geografia.nodes[chave]['umidade'] == 'fertil':
            fator_umidade = 0.5
        elif geografia.nodes[chave]['umidade'] == 'semi-arido':
            fator_umidade = -0.5
        elif geografia.nodes[chave]['umidade'] == 'arido':
            fator_umidade = -1.5
        geografia.nodes[chave]['temperatura'] = round(40 * incidencia_solar - 8 + fator_altitude + fator_umidade, 1) - 4

    for node, atributos in geografia.nodes(data=True):
        temperatura = atributos.get('temperatura')
        altitude = atributos.get('altitude')
        umidade = atributos.get('umidade')
        
        if temperatura < 0:
            atributos['bioma'] = 'Ice'
        else:
            if altitude == 'cordilheira':
                atributos['bioma'] = 'Mountains'
            elif altitude == 'planalto':
                atributos['bioma'] = 'Hills'
            elif altitude == 'planicie':
                if umidade == 'umido':
                    atributos['bioma'] = 'Forest'
                elif umidade == 'fertil':
                    atributos['bioma'] = 'Meadow'
                elif umidade == 'semi-arido':
                    atributos['bioma'] = 'Savanna'
                else:
                    atributos['bioma'] = 'Desert'
            elif altitude == 'plataforma':
                atributos['bioma'] = 'Coast'
            elif altitude == 'barreira':
                atributos['bioma'] = 'Sea'
            else:
                atributos['bioma'] = 'Ocean'
        
        # Aplica custo base diretamente do dicionário
        atributos['cust_mob'] = CUSTOS_BASE[atributos['bioma']] * coeficiente_movimento

    for u, v in geografia.edges():
        mob_u = geografia.nodes[u]['cust_mob']
        mob_v = geografia.nodes[v]['cust_mob']
        
        u_maritimo = geografia.nodes[u]['bioma'] in ['Coast', 'Sea', 'Ocean']
        v_maritimo = geografia.nodes[v]['bioma'] in ['Coast', 'Sea', 'Ocean']
        
        if u_maritimo != v_maritimo:  # Transição terra-mar
            geografia[u][v]['cust_mob'] = max(mob_u, mob_v) * 2 + PENALIDADE_TRANSICAO * coeficiente_movimento
        else:
            geografia[u][v]['cust_mob'] = (mob_u + mob_v) / 2

        # Bônus para rotas oceânicas longas
        if u_maritimo and v_maritimo:
            geografia[u][v]['cust_mob'] *= 0.7

    cores_biomas = {
        'Ocean': (0, 23, 98), 'Sea': (8, 33, 113), 'Coast': (12, 71, 108), 'Meadow': (91, 174, 70), 'Savanna': (231, 190, 141),
        'Forest': (75, 129, 66), 'Desert': (242, 242, 166), 'Hills': (201, 147, 121), 'Mountains': (158, 86, 86), 'Ice': (245, 255, 245)
    }

    bioma_escolhido = []

    for node in geografia.nodes:
        geografia.nodes[node]['cor_bioma'] = cores_biomas[geografia.nodes[node]['bioma']]
        if geografia.nodes[node]['bioma'] == f'{bioma}':
            bioma_escolhido.append(node)

    bioma_escolhido = [n for n, attr in geografia.nodes(data=True) if attr['bioma'] == f'{bioma}']
    lista_capitais = [choice(bioma_escolhido)]
    while len(lista_capitais) < len(bioma_escolhido) // 2:
        d2 = {}
        for candidato in bioma_escolhido:
            if candidato in lista_capitais:
                continue
            d = {}
            for capital in lista_capitais:
                d[capital] = networkx.shortest_path_length(geografia, source=candidato, target=capital, weight='custo_mobilidade')
            d2[candidato] = min(d.values())
        if not d2:  # Se não houver candidatos possíveis, o planeta não comporta a quantidade desejada
            print("d2 vazio")
            raise ValueError("O planeta não comporta essa quantidade de civilizações!")
        maior_valor = max(d2.values())
        chaves_maior_valor = [chave for chave, valor in d2.items() if valor == maior_valor]
        lista_capitais.append(choice(chaves_maior_valor))

    print(f"número de {bioma}:", len(bioma_escolhido))
    return geografia, lista_capitais


================================================================================
📄 shared/civilization.py
================================================================================
import random
from shared.flags import bandeira

class Civilizacao:
    def __init__(self, ref, indice, nome, player=False, ponto_inicial=None):
        self.player = player
        self.nome = nome
        self.cultura = ref.culturas[indice % len(ref.culturas)]
        self.cor = ref.civs_cores[self.nome]
        self.modalidade_bandeira = random.randint(0, 82)
        self.cores_bandeira = bandeira(self.nome, self.modalidade_bandeira)
        self.ponto_inicial = ponto_inicial
        self.provincias = []
        self.unidades = []

================================================================================
📄 shared/province.py
================================================================================
from shared.naming import formar_nome

class Provincia:
    def __init__(self, civilizacao, coordenadas):
        self.civilizacao = civilizacao
        self.coordenadas = coordenadas
        self.nome = formar_nome(civilizacao.cultura)

================================================================================
📄 shared/world.py
================================================================================
# shared/world.py
import random
from uuid import uuid4
from shared.references import Referencias
from shared.planet import Planeta
from shared.civilization import Civilizacao
from shared.province import Provincia


class Mundo:
    def __init__(self, fator=4, bioma='Meadow'):
        self.id_mundo = str(uuid4())
        ref = Referencias()
        random.shuffle(ref.culturas)
        lista_de_cores = list(ref.civs_cores.keys())
        random.shuffle(lista_de_cores)
        self.planeta = Planeta(fator=fator, bioma=bioma)
        self.civs = []

        # Criar civilizações com capitais corretas
        for i, capital in enumerate(self.planeta.capitais_players):
            nome = lista_de_cores[i % len(lista_de_cores)]
            civ = Civilizacao(ref, i, nome, True, capital)
            self.civs.append(civ)

        for i, capital in enumerate(self.planeta.capitais_neutros):
            indice = i + len(self.planeta.capitais_players)
            nome = lista_de_cores[indice % len(lista_de_cores)]
            civ = Civilizacao(ref, indice, nome, False, capital)
            self.civs.append(civ)

        # Atribuir província inicial usando o ponto_inicial de cada civ
        for civ in self.civs:
            provincia = Provincia(civ, civ.ponto_inicial)
            civ.provincias.append(provincia)

================================================================================
📄 shared/references.py
================================================================================
class Referencias:
    def __init__(self):
        self.culturas = [
            'English', 'Chinese', 'Spanish',
            'French', 'Indian', 'Russian',
            'Vietnamese', 'Turkish', 'Arabic',
            'Indonesian', 'Persian', 'Hausa',
            'Swahili', 'Portuguese', 'Telugu',
            'Bengali', 'Japanese', 'Marathi',
            'Wu', 'Yue', 'Min',
            'Korean', 'Italian', 'German'
        ]
        self.civs_cores = {
            'Black': (16, 16, 16), 'Midnight Blue': (0, 0, 127), 'Blue': (0, 0, 255),
            'Dark Green': (0, 127, 0), 'Teal': (0, 127, 127), 'Sky Blue': (32, 127, 223),
            'Green': (0, 255, 0), 'Spring Green': (0, 255, 127), 'Cyan': (0, 223, 223),
            'Maroon': (127, 0, 0), 'Purple': (127, 0, 127), 'Violet': (127, 0, 255),
            'Olive': (127, 127, 0), 'Gray': (127, 127, 127), 'Lavender': (127, 127, 255),
            'Chartreuse': (127, 255, 0), 'Light Green': (127, 223, 127), 'Pale Cyan': (127, 255, 255),
            'Red': (234, 33, 37), 'Rose': (255, 0, 127), 'Magenta': (255, 0, 255),
            'Orange': (223, 127, 32), 'Salmon': (255, 127, 127), 'Orchid': (255, 127, 255),
            'Yellow': (255, 255, 0), 'Light Yellow': (255, 255, 127), 'White': (250, 255, 253)
        }

        self.tons_de_pele = [(245, 212, 205), (212, 160, 147), (163, 106, 95), (101, 61, 53)]
        self.tons_de_cabelo = [(209, 195, 2), (140, 106, 0), (99, 55, 26), (52, 48, 47)]

================================================================================
✅ Total de 29 arquivos incluídos.
================================================================================