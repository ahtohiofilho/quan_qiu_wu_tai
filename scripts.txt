ARQUIVO DE C√ìDIGO CONSOLIDADO
Gerado em: 2025-09-07 20:16:18
Diret√≥rio: /home/mariagoreti/quan_qiu_wu_tai
Conte√∫do dos scripts principais reunidos.

================================================================================

================================================================================
üìÅ ESTRUTURA DO PROJETO
================================================================================

üìÅ .
‚îú‚îÄ‚îÄ server
‚îÇ   ‚îú‚îÄ‚îÄ config
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ config.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ extensions.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ initializer.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ signals.py
‚îÇ   ‚îú‚îÄ‚îÄ core
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ admin_gui.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ commander.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ manager.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ registrar_players.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ simulador_players.py
‚îÇ   ‚îú‚îÄ‚îÄ integrations
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ aws_loader.py
‚îÇ   ‚îú‚îÄ‚îÄ routes
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ game.py
‚îÇ   ‚îú‚îÄ‚îÄ saves
‚îÇ   ‚îú‚îÄ‚îÄ services
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ matchmaking_service.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ queue_service.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user_service.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ world_pool.py
‚îÇ   ‚îú‚îÄ‚îÄ tools
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ sei_la_o_que.py
‚îÇ   ‚îú‚îÄ‚îÄ app.py
‚îÇ   ‚îî‚îÄ‚îÄ serialization.py
‚îú‚îÄ‚îÄ client
‚îÇ   ‚îú‚îÄ‚îÄ components
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ icon_manager.py
‚îÇ   ‚îú‚îÄ‚îÄ dialogs
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ auth_dialog.py
‚îÇ   ‚îú‚îÄ‚îÄ rendering
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ camera.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ opengl_widget.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ planet_renderer.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ shader.py
‚îÇ   ‚îú‚îÄ‚îÄ resources
‚îÇ   ‚îú‚îÄ‚îÄ shaders
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ basic.frag
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ basic.vert
‚îÇ   ‚îú‚îÄ‚îÄ states
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ waiting_room.py
‚îÇ   ‚îú‚îÄ‚îÄ utils
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ scaling.py
‚îÇ   ‚îú‚îÄ‚îÄ widgets
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ match_overlay.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ offline_setup_overlay.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ waiting_room_overlay.py
‚îÇ   ‚îî‚îÄ‚îÄ main.py
‚îú‚îÄ‚îÄ shared
‚îÇ   ‚îú‚îÄ‚îÄ civilization.py
‚îÇ   ‚îú‚îÄ‚îÄ geography.py
‚îÇ   ‚îú‚îÄ‚îÄ planet.py
‚îÇ   ‚îú‚îÄ‚îÄ polygons.py
‚îÇ   ‚îú‚îÄ‚îÄ province.py
‚îÇ   ‚îú‚îÄ‚îÄ references.py
‚îÇ   ‚îú‚îÄ‚îÄ turn.py
‚îÇ   ‚îî‚îÄ‚îÄ world.py

================================================================================
üìÑ CONTE√öDO DOS ARQUIVOS
================================================================================

================================================================================
üìÑ server/app.py
================================================================================
# server/app.py
from flask import Flask, jsonify
from server.config.config import config
from server.config.extensions import ext
from server.services.user_service import UserService
from server.routes.auth import auth_bp, register_routes
from server.routes.game import create_game_blueprint
from server.services.matchmaking_service import MatchmakingService
from server.services.world_pool import MundoPoolService  # ‚úÖ Importe o novo servi√ßo
from server.integrations.aws_loader import AWSLoader
from server.core.manager import Gerenciador


def create_app(config_name='default'):
    """Factory function para criar a aplica√ß√£o Flask."""
    app = Flask(__name__)

    # 1. Carrega a configura√ß√£o
    app.config.from_object(config[config_name])

    # 2. Inicializa as extens√µes
    ext.init_app(app)

    # 3. Cria inst√¢ncias de servi√ßos, injetando depend√™ncias
    user_service = UserService(ext.dynamodb, app.config['DYNAMODB_TABLE_NAME'])
    print(f"‚úÖ DEBUG: UserService criado: {user_service}")

    # --- üîπ AWS Loader e Gerenciador de Mundos ---
    aws_loader = AWSLoader(
        profile_name=app.config.get('AWS_PROFILE_NAME'),
        region_name=app.config.get('AWS_REGION_NAME')
    )

    # ‚úÖ Passando o nome da tabela DynamoDB para o Gerenciador
    gerenciador = Gerenciador(
        aws_loader=aws_loader,
        save_dir="saves",
        dynamodb_table_name=app.config['DYNAMODB_TABLE_NAME']  # ‚Üê Corre√ß√£o essencial
    )

    # --- üîπ World Pool: Gerencia mundos pr√©-criados ---
    world_pool = MundoPoolService(
        gerenciador=gerenciador,
        fator=4,
        bioma="Meadow",
        min_mundos=3,
        max_mundos=10,
        intervalo_verificacao=5.0
    )

    # --- üîπ Matchmaking: Sistema Avan√ßado de Salas ---
    # MatchmakingService agora recebe o world_pool, n√£o o gerenciador diretamente
    matchmaking_service = MatchmakingService(world_pool=world_pool)

    # Callback para quando uma partida for formada
    def partida_formada(jogadores):
        print(f"\nüéâüéâüéâ PARTIDA INICIADA COM: {jogadores}")
        print(f"üéÆ Os jogadores est√£o prontos para o combate!\n")
        # Aqui voc√™ pode:
        # - Notificar jogadores via WebSocket
        # - Registrar a partida no DynamoDB
        # - Iniciar a l√≥gica do jogo

    # ‚úÖ Registra o callback no novo servi√ßo
    matchmaking_service.partida_iniciada_callback = partida_formada

    # Armazena servi√ßos no app.config para acesso futuro, se necess√°rio
    app.config['USER_SERVICE'] = user_service
    app.config['MATCHMAKING_SERVICE'] = matchmaking_service

    # 4. Registra os Blueprints e injeta depend√™ncias
    print("üìã DEBUG: Iniciando inje√ß√£o de depend√™ncias e registro de blueprints...")

    # --- üîπ Auth ---
    print("üîß DEBUG: Injetando UserService em auth_bp...")
    register_routes(user_service)
    print(f"‚úÖ DEBUG: register_routes(user_service) chamado com sucesso.")
    app.register_blueprint(auth_bp)
    print("‚úÖ DEBUG: auth_bp registrado no app.")

    # --- üîπ Jogo Online (NOVO) ---
    jogo_bp = create_game_blueprint(user_service, matchmaking_service)
    app.register_blueprint(jogo_bp)
    print("‚úÖ DEBUG: jogo_bp registrado no app.")

    # 5. Rotas principais (opcional)
    @app.route('/')
    def home():
        return "üöÄ Servidor Global Arena - API (Refatorado com Classes)", 200

    # üîç Rota de status do matchmaking (monitoramento)
    @app.route('/status')
    def status():
        return jsonify({
            "success": True,
            "total_na_fila": world_pool.total_jogadores_na_fila(),  # ‚úÖ Agora existe
            "mundos_no_pool": world_pool.quantidade_total(),
            "vagas_disponiveis": world_pool.quantidade_vagas(),
            "partidas_ativas": len(matchmaking_service.salas)
        })

    return app


# Para execu√ß√£o direta (ex: python server/app.py)
if __name__ == '__main__':
    app = create_app('development')  # Ou 'production'
    print("üöÄ Iniciando Servidor Global Arena (Flask - Refatorado)...")
    print("üìÑ Endpoints dispon√≠veis:")
    print("   GET  /                        - Status do servidor")
    print("   GET  /status                  - Status do matchmaking e pool de mundos")
    print("   GET  /auth/teste_dynamodb     - Teste de conex√£o com DynamoDB")
    print("   POST /jogo/entrar             - Entrar na fila de jogo online (novo)")
    print("-" * 40)
    app.run(host='127.0.0.1', port=5000, debug=app.config['DEBUG'])

================================================================================
üìÑ server/serialization.py
================================================================================
# server/serialization.py
import json
import networkx as nx
import numpy as np
from pathlib import Path
from typing import Any, Dict, Optional
from shared.world import Mundo
from shared.references import Referencias


class Serializador:
    """
    Classe respons√°vel por serializar e desserializar o estado completo de um Mundo.
    Converte para dict serializ√°vel em JSON, salva em disco e recarrega.
    """

    @staticmethod
    def _convert(value: Any) -> Any:
        """
        Converte valores n√£o serializ√°veis em tipos compat√≠veis com JSON.
        """
        if isinstance(value, np.integer):
            return int(value)
        if isinstance(value, np.floating):
            return float(value)
        if isinstance(value, np.ndarray):
            return value.tolist()
        if isinstance(value, tuple):
            return list(value)
        if hasattr(value, '__dict__'):
            return {k: Serializador._convert(v) for k, v in value.__dict__.items() if not k.startswith('_')}
        return value

    @classmethod
    def to_serializable_dict(cls, mundo: Mundo) -> Dict[str, Any]:
        """
        Converte um objeto Mundo em um dicion√°rio compat√≠vel com JSON.
        Remove atributos deriv√°veis para reduzir tamanho.
        """
        if not hasattr(mundo, 'planeta') or not hasattr(mundo, 'civs'):
            raise ValueError("Objeto mundo inv√°lido: falta atributos 'planeta' ou 'civs'")

        G = mundo.planeta.geografia.copy()

        # Atributos que podem ser recalculados, ent√£o n√£o precisam ser salvos
        node_attrs_to_remove = {
            'cor_placa', 'cor_bioma', 'letra_grega', 'cust_mob', 'tipo', 'altitude', 'umidade', 'temperatura',
        }
        for node in G.nodes:
            for attr in node_attrs_to_remove:
                G.nodes[node].pop(attr, None)  # Remove silenciosamente

        # Remover arestas (ser√£o recalculadas com custo de mobilidade)
        G.remove_edges_from(list(G.edges))

        # Converter atributos dos n√≥s
        for node in G.nodes:
            attrs = G.nodes[node]
            for key in list(attrs.keys()):
                attrs[key] = cls._convert(attrs[key])

        # Usa 'edges="links"' para manter compatibilidade com o formato antigo
        # O padr√£o futuro ser√° 'edges="edges"', mas queremos evitar mudan√ßas inesperadas
        G_data = nx.node_link_data(G, edges="links")
        G_data.pop("directed", None)
        G_data.pop("multigraph", None)
        G_data.pop("graph", None)

        # Serializar civiliza√ß√µes
        civilizacoes_data = []
        for civ in mundo.civs:
            civ_data = {
                'nome': civ.nome,
                'cultura': civ.cultura,
                'cor': cls._convert(civ.cor),
                'modalidade_bandeira': civ.modalidade_bandeira,
                'cores_bandeira': cls._convert(civ.cores_bandeira),
                'player': civ.player,
                'provincias': [
                    {
                        'coordenadas': cls._convert(p.coordenadas),
                        'nome': p.nome
                    }
                    for p in civ.provincias
                ]
            }
            civilizacoes_data.append(civ_data)

        return {
            "id_mundo": mundo.id_mundo,
            "fator": mundo.planeta.fator,
            "bioma_inicial": mundo.planeta.bioma_inicial,
            "vagas": mundo.planeta.numero_de_jogadores,
            "geografia": G_data,
            "civilizacoes": civilizacoes_data
        }

    @classmethod
    def from_serializable_dict(cls, data: Dict[str, Any], ref: Optional[Referencias] = None):
        """
        Reconstroi um objeto Mundo a partir de um dicion√°rio.
        Requer uma inst√¢ncia de Referencias para inicializa√ß√£o.
        """
        """
        Ainda a ser implementado
        retorna Mundo
        """

    @classmethod
    def save_to_json(cls, mundo: Mundo, filepath: str) -> bool:
        try:
            data = cls.to_serializable_dict(mundo)
            path = Path(filepath)
            path.parent.mkdir(exist_ok=True, parents=True)
            with open(path, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
            print(f"‚úÖ Mundo salvo em JSON: {filepath}")
            return True
        except Exception as e:
            print(f"‚ùå Falha ao salvar mundo: {e}")
            return False

    @classmethod
    def save_mundo(cls, mundo: Mundo, filepath: str = None) -> str:
        """
        Salva um objeto Mundo em JSON.
        Se filepath n√£o for fornecido, gera um nome autom√°tico em 'saves/'.
        :param mundo: Inst√¢ncia de Mundo
        :param filepath: Caminho opcional para salvar
        :return: Caminho final usado, ou string vazia se falhar
        """
        from pathlib import Path

        if filepath is None:
            # Gera caminho padr√£o: saves/mundo_{id}.json
            saves_dir = Path("saves")
            saves_dir.mkdir(exist_ok=True)
            filepath = saves_dir / f"mundo_{mundo.id_mundo}.json"
        else:
            # Garante que o diret√≥rio pai exista
            path = Path(filepath)
            path.parent.mkdir(exist_ok=True, parents=True)

        sucesso = cls.save_to_json(mundo, filepath)
        return str(filepath) if sucesso else ""

================================================================================
üìÑ server/services/matchmaking_service.py
================================================================================
# server/services/matchmaking_service.py
from typing import List, Optional, Callable
import threading
from shared.world import Mundo
from server.services.world_pool import MundoPoolService  # ‚úÖ Inje√ß√£o de depend√™ncia

class SalaDeEspera:
    def __init__(self, mundo: Mundo, callback: Callable[[List[str]], None]):
        self.mundo = mundo
        self.vagas = len(mundo.planeta.capitais_players)  # ‚úÖ Vagas definidas pelo mundo
        self.jogadores = []
        self.lock = threading.Lock()
        self.callback = callback

    def adicionar_jogador(self, username: str) -> str:
        with self.lock:
            if username in self.jogadores:
                return f"Erro ao entrar na fila: {username} j√° est√° na sala."
            if len(self.jogadores) >= self.vagas:
                return "Erro ao entrar na fila: sala cheia."

            self.jogadores.append(username)

            if len(self.jogadores) == self.vagas:
                self.callback(self.jogadores.copy())

            return f"{username} entrou na sala {self.mundo.id_mundo} ({len(self.jogadores)}/{self.vagas})"

    def esta_cheia(self) -> bool:
        with self.lock:
            return len(self.jogadores) >= self.vagas

    def tamanho(self) -> int:
        with self.lock:
            return len(self.jogadores)

    def remover_jogador(self, username: str) -> bool:
        """Remove um jogador da sala. Retorna True se encontrado."""
        if username in self.jogadores:
            self.jogadores.remove(username)
            print(f"üóëÔ∏è Jogador '{username}' removido da sala de espera.")
            return True
        return False


class MatchmakingService:
    """
    Matchmaking baseado em MUNDOS PR√â-CRIADOS fornecidos pelo MundoPoolService.
    O MatchmakingService n√£o cria mundos ‚Äî apenas aloca jogadores.
    """
    def __init__(self, world_pool: MundoPoolService):
        self.world_pool = world_pool
        self.salas: List[SalaDeEspera] = []  # Salas ativas com vagas
        self.lock = threading.Lock()
        self.partida_iniciada_callback: Optional[Callable[[List[str]], None]] = None

    def _on_partida_cheia(self, jogadores: List[str]):
        """Callback interno chamado quando uma sala enche. Garante limpeza completa do estado."""
        print(f"üîµ [DEBUG] MatchmakingService._on_partida_cheia: In√≠cio com {len(jogadores)} jogadores")

        # 1. Encontrar a sala associada aos jogadores
        sala = None
        with self.lock:
            for s in self.salas:
                # Comparar listas de jogadores (ordem pode variar, mas conte√∫do deve ser igual)
                if set(s.jogadores) == set(jogadores):
                    sala = s
                    break

        if not sala:
            print("üü° [DEBUG] MatchmakingService._on_partida_cheia: Sala n√£o encontrada. Ignorando.")
            return

        print(f"üü¢ [DEBUG] MatchmakingService._on_partida_cheia: Sala encontrada com mundo {sala.mundo.id_mundo}")

        # 2. Se encontrou a sala e ela tem um mundo, consuma-o
        if sala.mundo:
            sucesso = self.world_pool.consumir_mundo(sala.mundo.id_mundo)
            if sucesso:
                print(f"‚úÖ Mundo {sala.mundo.id_mundo} consumido ap√≥s partida iniciar.")
            else:
                print(f"‚ö†Ô∏è Falha ao consumir mundo {sala.mundo.id_mundo}")

        # 3. Notificar o cliente que a partida come√ßou
        if self.partida_iniciada_callback:
            print("üü¢ [DEBUG] MatchmakingService._on_partida_cheia: Notificando cliente: partida iniciada")
            self.partida_iniciada_callback(jogadores)
        else:
            print("üü° [DEBUG] MatchmakingService._on_partida_cheia: Nenhum callback registrado para partida iniciada")

        # 4. Remover a sala da lista de salas ativas
        with self.lock:
            antes = len(self.salas)
            # Remover pela refer√™ncia da sala, n√£o pela lista de jogadores
            if sala in self.salas:
                self.salas.remove(sala)
                print(f"üóëÔ∏è [DEBUG] MatchmakingService._on_partida_cheia: Sala com mundo {sala.mundo.id_mundo} removida")
            else:
                print("üü° [DEBUG] MatchmakingService._on_partida_cheia: Sala j√° foi removida")
            depois = len(self.salas)
            print(f"üü¢ [DEBUG] MatchmakingService._on_partida_cheia: Salas ativas: {antes} ‚Üí {depois}")

        print("üü¢ [DEBUG] MatchmakingService._on_partida_cheia: Execu√ß√£o conclu√≠da")

    def entrar_na_fila(self, username: str) -> str:
        """
        1. Obt√©m um mundo com vaga do MundoPoolService.
        2. Associa o jogador a esse mundo (cria ou entra em sala).
        3. Registra ocupa√ß√£o no pool.

        NOTA: O mundo N√ÉO √© consumido aqui. Ele s√≥ ser√° consumido em `_on_partida_cheia`,
        quando a sala encher. Isso permite que m√∫ltiplos jogadores entrem no mesmo mundo.
        """
        with self.lock:
            # 1. Obter um mundo com vaga dispon√≠vel
            mundo = self.world_pool.obter_mundo_com_vaga()
            if not mundo:
                return f"Erro ao entrar na fila: nenhum mundo dispon√≠vel para {username}."

            # 2. Verificar se j√° existe uma sala para esse mundo
            sala_existente = next((s for s in self.salas if s.mundo.id_mundo == mundo.id_mundo), None)

            if sala_existente:
                mensagem = sala_existente.adicionar_jogador(username)
                print(f"üë• {username} adicionado √† sala existente do mundo {mundo.id_mundo}")
            else:
                # Criar nova sala para esse mundo
                nova_sala = SalaDeEspera(mundo=mundo, callback=self._on_partida_cheia)
                self.salas.append(nova_sala)
                mensagem = nova_sala.adicionar_jogador(username)
                print(f"üÜï Sala criada para o mundo {mundo.id_mundo}. {username} entrou.")

            # 3. Registrar no pool que o jogador ocupou uma vaga
            if "Erro" not in mensagem:
                self.world_pool.registrar_jogador_no_mundo(username, mundo)
                print(f"‚úÖ {username} registrado no mundo {mundo.id_mundo}")

            # ‚ùå REMOVIDO: consumo prematuro do mundo
            # O mundo ser√° consumido apenas quando a sala encher, em `_on_partida_cheia`
            # Isso permite que outros jogadores entrem no mesmo mundo

            print(mensagem)
            return mensagem

    def sair_da_fila(self, username: str) -> bool:
        """Remove o jogador da fila de qualquer sala. Remove a sala se ficar vazia."""
        with self.lock:
            for sala in self.salas:
                if sala.remover_jogador(username):
                    print(f"üì§ {username} removido da sala {sala.mundo.id_mundo}")

                    # ‚úÖ Remover do pool de jogadores do mundo
                    if sala.mundo.id_mundo in self.world_pool.jogadores_por_mundo:
                        if username in self.world_pool.jogadores_por_mundo[sala.mundo.id_mundo]:
                            self.world_pool.jogadores_por_mundo[sala.mundo.id_mundo].remove(username)
                            print(f"üßπ {username} removido de jogadores_por_mundo[{sala.mundo.id_mundo}]")

                    # ‚úÖ Remover a sala se ficar vazia
                    if len(sala.jogadores) == 0:
                        self.salas.remove(sala)
                        print(f"üóëÔ∏è Sala com mundo {sala.mundo.id_mundo} removida (vazia)")
                    return True
            return False

================================================================================
üìÑ server/services/queue_service.py
================================================================================
# server/services/queue_service.py
"""
Servi√ßo de fila de espera para matchmaking online.
Gerencia a entrada de jogadores e forma√ß√£o de partidas quando h√° 4+ jogadores.
"""

import threading
from typing import Optional, Callable


class FilaService:
    """
    Servi√ßo respons√°vel por gerenciar a fila de jogadores online.
    Forma partidas automaticamente quando 4 jogadores est√£o na fila.
    """

    def __init__(self):
        self.fila = []
        self.lock = threading.Lock()
        self.partida_iniciada_callback: Optional[Callable[[list], None]] = None

    def adicionar_jogador(self, username: str) -> bool:
        with self.lock:
            if username in self.fila:
                print(f"‚ö†Ô∏è '{username}' j√° est√° na fila. Bloqueado.")
                return False
            self.fila.append(username)
            print(f"üì• Jogador '{username}' adicionado √† fila. Total: {len(self.fila)}")
            self._tentar_formar_partida()
            return True

    def remover_jogador(self, username: str):
        """
        Remove um jogador da fila, se estiver presente.
        """
        with self.lock:
            if username in self.fila:
                self.fila.remove(username)
                print(f"üì§ Jogador '{username}' removido da fila.")

    def _tentar_formar_partida(self):
        with self.lock:
            print(f"üîç Verificando forma√ß√£o de partida. Fila atual: {self.fila} (total: {len(self.fila)})")  # ‚Üê Novo log
            if len(self.fila) >= 4:
                partida = [self.fila.pop(0) for _ in range(4)]
                print(f"üéâ Partida formada com: {partida}")
                if self.partida_iniciada_callback:
                    try:
                        self.partida_iniciada_callback(partida)
                    except Exception as e:
                        print(f"‚ùå Erro ao executar partida_iniciada_callback: {e}")
                else:
                    print("‚ÑπÔ∏è Nenhum callback configurado.")

================================================================================
üìÑ server/services/user_service.py
================================================================================
# server/services/user_service.py
import bcrypt
from botocore.exceptions import ClientError


class UserService:
    def __init__(self, dynamodb_client, table_name):
        self.dynamodb = dynamodb_client
        self.table_name = table_name

    def _format_user_key(self, username: str) -> dict:
        """Formata a chave prim√°ria do usu√°rio no DynamoDB."""
        return {
            'PK': {'S': f'USER#{username}'},
            'SK': {'S': 'PROFILE'}
        }

    def get_user(self, username: str) -> dict:
        """Busca um usu√°rio pelo username."""
        if not self.dynamodb:
            print("‚ö†Ô∏è Cliente DynamoDB n√£o dispon√≠vel no UserService.")
            return None
        try:
            response = self.dynamodb.get_item(
                TableName=self.table_name,
                Key=self._format_user_key(username)
            )
            return response.get('Item')
        except ClientError as e:
            print(f"‚ùå Erro do DynamoDB ao buscar usu√°rio '{username}': {e.response['Error']['Message']}")
            return None
        except Exception as e:
            print(f"‚ùå Erro inesperado ao buscar usu√°rio '{username}': {e}")
            return None

    def create_user_item(self, username: str, **attributes) -> bool:
        """
        Cria um novo item de usu√°rio no DynamoDB.
        `attributes` pode conter {'password_hash': bytes, 'outro_attr': valor, ...}
        """
        if not self.dynamodb:
            print("‚ö†Ô∏è Cliente DynamoDB n√£o dispon√≠vel no UserService.")
            return False
        try:
            # Inicia o item com a chave prim√°ria
            item = self._format_user_key(username)

            # Adiciona outros atributos fornecidos
            for attr_name, attr_value in attributes.items():
                # Trata tipos espec√≠ficos
                if isinstance(attr_value, bytes):
                    # Para password_hash, salva como tipo bin√°rio 'B'
                    item[attr_name] = {'B': attr_value}
                elif isinstance(attr_value, str):
                    # Para strings, salva como tipo string 'S'
                    item[attr_name] = {'S': attr_value}
                elif isinstance(attr_value, (int, float)):
                    # Para n√∫meros, salva como tipo n√∫mero 'N' (convertido para string)
                    item[attr_name] = {'N': str(attr_value)}
                else:
                    # Para outros tipos, converte para string e salva como 'S'
                    # (voc√™ pode querer ser mais espec√≠fico aqui dependendo das suas necessidades)
                    print(
                        f"‚ö†Ô∏è Atributo '{attr_name}' tem tipo inesperado ({type(attr_value)}). Convertendo para string.")
                    item[attr_name] = {'S': str(attr_value)}

            self.dynamodb.put_item(
                TableName=self.table_name,
                Item=item
            )
            print(f"‚úÖ Item de usu√°rio '{username}' criado/Atualizado no DynamoDB.")
            return True
        except ClientError as e:
            print(f"‚ùå Erro do DynamoDB ao criar usu√°rio '{username}': {e.response['Error']['Message']}")
            return False
        except Exception as e:
            print(f"‚ùå Erro inesperado ao criar usu√°rio '{username}': {e}")
            return False

    def authenticate_user(self, username: str, password: str) -> tuple[bool, str]:
        """
        Autentica um usu√°rio verificando a senha com bcrypt.

        :param username: Nome de usu√°rio.
        :param password: Senha em texto plano.
        :return: (sucesso: bool, mensagem: str)
        """
        if not username or not password:
            return False, "Usu√°rio ou senha ausentes."

        # 1. Buscar usu√°rio
        user = self.get_user(username)
        if not user:
            return False, "Usu√°rio n√£o encontrado."

        # 2. Extrair o hash da senha
        password_hash_attr = user.get('password_hash')
        if not password_hash_attr:
            return False, "Usu√°rio sem senha cadastrada."

        # 3. O hash pode vir como {'B': bytes} do DynamoDB
        if isinstance(password_hash_attr, dict) and 'B' in password_hash_attr:
            stored_hash = password_hash_attr['B']
        elif isinstance(password_hash_attr, bytes):
            stored_hash = password_hash_attr
        else:
            return False, "Formato de hash de senha inv√°lido."

        # 4. Verificar com bcrypt
        try:
            if bcrypt.checkpw(password.encode('utf-8'), stored_hash):
                return True, "Login bem-sucedido."
            else:
                return False, "Senha incorreta."
        except Exception as e:
            print(f"‚ùå Erro ao verificar senha com bcrypt: {e}")
            return False, "Erro interno ao processar autentica√ß√£o."


================================================================================
üìÑ server/services/world_pool.py
================================================================================
# server/services/world_pool.py
from typing import List, Optional, Dict
import threading
from shared.world import Mundo
from server.core.manager import Gerenciador


class MundoPoolService:
    """
    Servi√ßo ativo que mant√©m um n√∫mero m√≠nimo de mundos com vagas dispon√≠veis.
    Reabastece automaticamente o pool quando necess√°rio.
    """
    def __init__(
        self,
        gerenciador: Gerenciador,
        fator: int = 4,
        bioma: str = "Meadow",
        min_mundos: int = 3,        # ‚úÖ M√≠nimo que queremos manter ativo
        max_mundos: int = 10,       # Limite total de mundos no sistema
        intervalo_verificacao: float = 5.0  # Tempo entre verifica√ß√µes (segundos)
    ):
        self.gerenciador = gerenciador
        self.fator = fator
        self.bioma = bioma
        self.min_mundos = min_mundos
        self.max_mundos = max_mundos
        self.intervalo_verificacao = intervalo_verificacao

        self.mundos_com_vaga: List[Mundo] = []  # Apenas mundos com pelo menos 1 vaga
        self.jogadores_por_mundo: Dict[str, List[str]] = {}  # id_mundo ‚Üí [user1, ...]
        self.lock = threading.Lock()

        # Controle da thread de reabastecimento
        self._thread_reabastecimento = None
        self._parar_reabastecimento = threading.Event()

        # Inicializa o pool e inicia o servi√ßo ativo
        self._inicializar_pool()
        self.iniciar_servico()

    def total_jogadores_na_fila(self) -> int:
        """Retorna o n√∫mero total de jogadores j√° alocados nos mundos do pool."""
        total = 0
        with self.lock:
            for jogadores in self.jogadores_por_mundo.values():
                total += len(jogadores)
        return total

    def quantidade_total(self) -> int:
        """Retorna o n√∫mero total de mundos com vagas dispon√≠veis no pool."""
        return self.quantidade_mundos_ativos()

    def _inicializar_pool(self):
        """Inicializa o pool com mundos existentes e cria novos apenas se necess√°rio."""
        print("üîÑ Inicializando pool de mundos...")

        # Etapa 1: Carregar mundos existentes com vagas
        self._carregar_mundos_existentes()

        # Etapa 2: Contar quantos ainda precisamos criar
        with self.lock:
            atual = len(self.mundos_com_vaga)
        print(f"üì¶ {atual} mundos com vagas j√° carregados.")

        # Etapa 3: Criar apenas o necess√°rio para atingir min_mundos
        a_criar = max(0, self.min_mundos - atual)
        print(f"üèóÔ∏è  Criando {a_criar} novos mundos para atingir o m√≠nimo ({self.min_mundos})...")

        for _ in range(a_criar):
            sucesso, mundo = self.gerenciador.criar_e_upload_mundo_com_retorno(
                fator=self.fator,
                bioma=self.bioma,
                bucket_name="global-arena-tiles",
                s3_prefix="planetas/"
            )
            if sucesso and mundo:
                with self.lock:
                    self.mundos_com_vaga.append(mundo)
                    self.jogadores_por_mundo[mundo.id_mundo] = []
                print(f"‚úÖ Mundo {mundo.id_mundo} adicionado ao pool inicial.")
            else:
                print("‚ö†Ô∏è Falha ao criar mundo durante inicializa√ß√£o.")

    def iniciar_servico(self):
        """Inicia o loop de monitoramento e reabastecimento."""
        if self._thread_reabastecimento is None:
            self._parar_reabastecimento.clear()
            self._thread_reabastecimento = threading.Thread(target=self._loop_reabastecimento, daemon=True)
            self._thread_reabastecimento.start()
            print(f"‚úÖ MundoPoolService: servi√ßo ativo iniciado (min={self.min_mundos}, max={self.max_mundos})")

    def parar_servico(self):
        """Para o servi√ßo de reabastecimento (para testes ou desligamento)."""
        if self._thread_reabastecimento is not None:
            self._parar_reabastecimento.set()
            self._thread_reabastecimento.join(timeout=2)
            print("üõë MundoPoolService: servi√ßo ativo parado.")

    def _loop_reabastecimento(self):
        """Loop cont√≠nuo que verifica e reabastece o pool."""
        while not self._parar_reabastecimento.is_set():
            self._parar_reabastecimento.wait(self.intervalo_verificacao)
            if self._parar_reabastecimento.is_set():
                break
            self._reabastecer()

    def _reabastecer(self):
        """Cria mundos at√© atingir min_mundos, respeitando max_mundos."""
        with self.lock:
            atual = len(self.mundos_com_vaga)
            if atual >= self.min_mundos:
                return  # J√° temos o m√≠nimo

            # Quantos mundos precisamos criar?
            a_criar = min(self.min_mundos - atual, self.max_mundos - len(self.mundos_com_vaga))
            for _ in range(a_criar):
                sucesso, mundo = self.gerenciador.criar_e_upload_mundo_com_retorno(
                    fator=self.fator,
                    bioma=self.bioma,
                    bucket_name="global-arena-tiles",
                    s3_prefix="planetas/"
                )
                if sucesso and mundo:
                    self.mundos_com_vaga.append(mundo)
                    self.jogadores_por_mundo[mundo.id_mundo] = []
                    print(f"üîÑ Mundo {mundo.id_mundo} criado. Pool agora tem {len(self.mundos_com_vaga)} mundos com vaga.")
                else:
                    print("‚ö†Ô∏è Falha ao criar mundo durante reabastecimento.")
                    break

    def obter_mundo_com_vaga(self) -> Optional[Mundo]:
        """Retorna um mundo com vaga dispon√≠vel, se houver."""
        with self.lock:
            for mundo in self.mundos_com_vaga:
                ocupadas = len(self.jogadores_por_mundo[mundo.id_mundo])
                if ocupadas < len(mundo.planeta.capitais_players):
                    return mundo
            return None

    def registrar_jogador_no_mundo(self, username: str, mundo: Mundo):
        """Registra um jogador em um mundo. Remove o mundo do pool se encher."""
        with self.lock:
            lista = self.jogadores_por_mundo[mundo.id_mundo]
            if username not in lista:
                lista.append(username)

            # Se o mundo encheu, remova do pool
            if len(lista) >= len(mundo.planeta.capitais_players):
                if mundo in self.mundos_com_vaga:
                    self.mundos_com_vaga.remove(mundo)
                    print(f"üóëÔ∏è Mundo {mundo.id_mundo} removido do pool (partida formada).")

    def quantidade_mundos_ativos(self) -> int:
        """Retorna quantos mundos ainda t√™m vagas dispon√≠veis."""
        with self.lock:
            return len(self.mundos_com_vaga)

    def quantidade_vagas_totais(self) -> int:
        """Retorna o n√∫mero total de vagas dispon√≠veis no pool."""
        total = 0
        with self.lock:
            for mundo in self.mundos_com_vaga:
                ocupadas = len(self.jogadores_por_mundo[mundo.id_mundo])
                total += len(mundo.planeta.capitais_players) - ocupadas
        return total

    def quantidade_vagas(self) -> int:
        """Retorna o n√∫mero total de vagas dispon√≠veis em todos os mundos do pool."""
        total = 0
        with self.lock:
            for mundo in self.mundos_com_vaga:
                ocupadas = len(self.jogadores_por_mundo.get(mundo.id_mundo, []))
                total += len(mundo.planeta.capitais_players) - ocupadas
        return total

    def _carregar_mundos_existentes(self):
        """Carrega mundos com vagas DO DynamoDB para o pool, mas apenas se estiverem 'disponiveis'."""
        try:
            dynamodb = self.gerenciador.aws_loader.get_client('dynamodb')
            response = dynamodb.scan(
                TableName=self.gerenciador.dynamodb_table_name,
                # ‚úÖ Filtra por PK come√ßando com PLANET#, com vagas > 0 E status = 'disponivel'
                FilterExpression="begins_with(PK, :pk_prefix) AND vagas > :zero AND #status = :ativo",
                ExpressionAttributeNames={
                    '#status': 'status'  # ‚úÖ Protege contra palavras reservadas
                },
                ExpressionAttributeValues={
                    ':pk_prefix': {'S': 'PLANET#'},
                    ':zero': {'N': '0'},
                    ':ativo': {'S': 'disponivel'}  # ‚úÖ Apenas mundos dispon√≠veis
                }
            )

            with self.lock:
                for item in response.get('Items', []):
                    id_mundo = item['PK']['S'].split('#')[1]
                    vagas = int(item['vagas']['N'])
                    # ‚úÖ Verifica novamente (embora o scan j√° tenha filtrado)
                    if vagas > 0:
                        # ‚úÖ Evita duplica√ß√£o
                        if not any(m.id_mundo == id_mundo for m in self.mundos_com_vaga):
                            mundo_stub = Mundo(fator=self.fator, bioma=self.bioma)
                            mundo_stub.id_mundo = id_mundo
                            self.mundos_com_vaga.append(mundo_stub)
                            self.jogadores_por_mundo[id_mundo] = []
                            print(f"üîÅ Mundo carregado do DynamoDB: {id_mundo} ({vagas} vagas)")
        except Exception as e:
            print(f"‚ö†Ô∏è Falha ao carregar mundos existentes: {e}")
            import traceback
            traceback.print_exc()

    def consumir_mundo(self, id_mundo: str) -> Optional[Mundo]:
        """Remove um mundo do pool e marca como 'consumido' no DynamoDB."""
        with self.lock:
            # 1. Remover do pool local
            mundo = None
            for m in self.mundos_com_vaga:
                if m.id_mundo == id_mundo:
                    self.mundos_com_vaga.remove(m)
                    mundo = m
                    break
            if not mundo:
                print(f"‚ö†Ô∏è Mundo {id_mundo} n√£o encontrado no pool para consumo.")
                return None

            print(f"üåç Mundo {id_mundo} removido do pool (consumido).")

            # 2. Atualizar status no DynamoDB
            try:
                self.dynamodb.update_item(
                    TableName=self.dynamodb_table_name,
                    Key={
                        'PK': {'S': f'PLANET#{id_mundo}'},
                        'SK': {'S': 'METADATA'}
                    },
                    UpdateExpression="SET #status = :consumido",
                    ExpressionAttributeNames={'#status': 'status'},
                    ExpressionAttributeValues={':consumido': {'S': 'consumido'}}
                )
                print(f"‚úÖ DynamoDB atualizado: mundo {id_mundo} marcado como 'consumido'.")
            except Exception as e:
                print(f"‚ùå Falha ao atualizar status do mundo {id_mundo} no DynamoDB: {e}")

            return mundo

================================================================================
üìÑ server/tools/sei_la_o_que.py
================================================================================
# sei_la_o_que.py

from server.integrations.aws_loader import AWSLoader  # ou from server.aws_loader import AWSLoader

def main():
    print("üöÄ Iniciando aplica√ß√£o...\n")

    # --- Configura√ß√£o ---
    loader = AWSLoader(
        region_name='us-east-2',
        # profile_name='seu-perfil'  # opcional
    )

    # --- 1. Informa√ß√µes da conta ---
    try:
        account = loader.get_account_info()
        print(f"‚úÖ Logado na conta AWS: {account['account_id']}")
        print(f"üë§ Usu√°rio/Role: {account['arn']}\n")
    except Exception as e:
        print(f"‚ùå Falha ao obter conta: {e}")
        return

    # --- 2. Listar buckets S3 ---
    try:
        buckets = loader.list_s3_buckets()
        print(f"üì¶ Buckets S3 encontrados ({len(buckets)}):")
        for bucket in buckets:
            print(f"  - {bucket}")
    except Exception as e:
        print(f"‚ùå Erro ao listar buckets S3: {e}")

    # --- 3. Listar tabelas DynamoDB ---
    try:
        tables = loader.list_dynamodb_tables()
        print(f"\nüìä Tabelas DynamoDB encontradas ({len(tables)}):")
        for table in tables:
            print(f"  - {table}")
    except Exception as e:
        print(f"‚ùå Erro ao listar tabelas DynamoDB: {e}")

    # --- 4. Exemplo: usar cliente S3 ---
    try:
        s3 = loader.get_client('s3')
        response = s3.list_buckets()
        print(f"\nüåç Conex√£o S3 bem-sucedida. Total de buckets: {len(response['Buckets'])}")
    except Exception as e:
        print(f"‚ùå Falha ao usar cliente S3: {e}")


if __name__ == "__main__":
    main()

================================================================================
üìÑ server/integrations/aws_loader.py
================================================================================
# aws_loader.py

import boto3
from botocore.exceptions import NoCredentialsError, PartialCredentialsError


class AWSLoader:
    def __init__(self, profile_name=None, region_name='us-east-2'):
        """
        Inicializa o loader de credenciais AWS.

        :param profile_name: Nome do perfil no arquivo ~/.aws/credentials (opcional)
        :param region_name: Regi√£o AWS padr√£o
        """
        self.profile_name = profile_name
        self.region_name = region_name
        self.session = None
        self._create_session()

    def _create_session(self):
        """Cria uma sess√£o boto3 com base no perfil ou nas credenciais padr√£o."""
        try:
            if self.profile_name:
                self.session = boto3.Session(profile_name=self.profile_name, region_name=self.region_name)
            else:
                self.session = boto3.Session(region_name=self.region_name)

            # Testa credenciais
            sts = self.session.client('sts')
            sts.get_caller_identity()
            print("‚úÖ Credenciais AWS carregadas com sucesso.")

        except NoCredentialsError:
            raise Exception("‚ùå Credenciais AWS n√£o encontradas. Configure AWS_ACCESS_KEY_ID e AWS_SECRET_ACCESS_KEY.")
        except PartialCredentialsError:
            raise Exception("‚ùå Credenciais incompletas. Verifique AWS_ACCESS_KEY_ID e AWS_SECRET_ACCESS_KEY.")
        except Exception as e:
            raise Exception(f"‚ùå Erro ao carregar credenciais: {e}")

    def get_credentials(self):
        """
        Retorna as credenciais (access key, secret key, token).
        """
        credentials = self.session.get_credentials()
        frozen_creds = credentials.get_frozen_credentials()
        return {
            'access_key': frozen_creds.access_key,
            'secret_key': frozen_creds.secret_key,
            'token': frozen_creds.token
        }

    def get_client(self, service_name):
        """Retorna um cliente boto3 para o servi√ßo especificado."""
        return self.session.client(service_name)

    def get_resource(self, service_name):
        """Retorna um recurso boto3 (ex: S3 resource)."""
        return self.session.resource(service_name)

    # --- üîß Novos m√©todos adicionados ---
    def get_account_info(self):
        """Retorna informa√ß√µes da conta AWS: ID, ARN, usu√°rio, regi√£o."""
        sts = self.session.client('sts')
        identity = sts.get_caller_identity()
        return {
            'account_id': identity['Account'],
            'user_id': identity['UserId'],
            'arn': identity['Arn'],
            'region': self.region_name
        }

    def list_s3_buckets(self):
        """Lista todos os buckets S3 da conta."""
        s3 = self.get_client('s3')
        response = s3.list_buckets()
        return [bucket['Name'] for bucket in response['Buckets']]

    def list_dynamodb_tables(self):
        """Lista todas as tabelas DynamoDB da conta."""
        dynamodb = self.get_client('dynamodb')
        response = dynamodb.list_tables()
        return response['TableNames']

================================================================================
üìÑ server/config/initializer.py
================================================================================
# server/initializer.py
"""
M√≥dulo para inicializar ou reinicializar a infraestrutura AWS:
- Cria/recria a tabela DynamoDB 'GlobalArena' com PK/SK.
- Limpa os dados no S3 nos prefixos usados.
- Garante que o bucket S3 exista.

Pode ser executado como script: python server/inicializador.py
"""

from botocore.exceptions import ClientError
from server.integrations.aws_loader import AWSLoader


class InicializadorAWS:
    def __init__(self, aws_loader: AWSLoader):
        self.aws_loader = aws_loader
        self.dynamodb = self.aws_loader.get_client('dynamodb')
        self.s3 = self.aws_loader.get_client('s3')
        self.bucket_name = "global-arena-tiles"
        self.region = aws_loader.region_name

    def inicializar(self, confirmar: bool = True):
        """
        Inicializa ou reinicializa toda a infraestrutura.
        :param confirmar: Se True, pede confirma√ß√£o antes de apagar dados.
        """
        if confirmar:
            resposta = input(
                "‚ö†Ô∏è  Isso apagar√° todos os mundos e metadados no S3 e DynamoDB.\n"
                "Deseja continuar? (s/N): "
            )
            if resposta.lower() not in ['s', 'sim', 'y', 'yes']:
                print("‚ùå Opera√ß√£o cancelada.")
                return False

        print("üîÑ Inicializando infraestrutura AWS...")

        try:
            # 1. Garantir que o bucket S3 existe
            self._criar_bucket_se_nao_existir()

            # 2. Limpar dados no S3
            prefixos = ["planetas/", "saves/"]
            for prefix in prefixos:
                self._limpar_prefixo_s3(prefix)

            # 3. Recriar tabela DynamoDB (√∫nica: GlobalArena)
            self._recriar_tabela_globalarena()

            print("‚úÖ Infraestrutura AWS reinicializada com sucesso!")
            return True

        except Exception as e:
            print(f"‚ùå Erro ao inicializar infraestrutura: {e}")
            return False

    def _criar_bucket_se_nao_existir(self):
        """Cria o bucket S3 se ele n√£o existir."""
        try:
            self.s3.head_bucket(Bucket=self.bucket_name)
            print(f"‚ÑπÔ∏è  Bucket S3 '{self.bucket_name}' j√° existe.")
        except ClientError:
            print(f"üì¶ Criando bucket S3 '{self.bucket_name}'...")
            try:
                if self.region == "us-east-1":
                    self.s3.create_bucket(Bucket=self.bucket_name)
                else:
                    self.s3.create_bucket(
                        Bucket=self.bucket_name,
                        CreateBucketConfiguration={'LocationConstraint': self.region}
                    )
                print(f"‚úÖ Bucket '{self.bucket_name}' criado com sucesso.")
            except ClientError as e:
                print(f"‚ùå Falha ao criar bucket: {e}")
                raise

    def _limpar_prefixo_s3(self, prefix: str):
        """Remove todos os objetos com o prefixo dado no S3."""
        print(f"üßπ Limpando S3: s3://{self.bucket_name}/{prefix}")
        paginator = self.s3.get_paginator('list_objects_v2')
        apagados = 0

        try:
            pages = paginator.paginate(Bucket=self.bucket_name, Prefix=prefix)
            for page in pages:
                if 'Contents' not in page:
                    continue
                keys = [{'Key': obj['Key']} for obj in page['Contents']]
                if keys:
                    self.s3.delete_objects(Bucket=self.bucket_name, Delete={'Objects': keys})
                    apagados += len(keys)
            print(f"‚úÖ {apagados} objetos apagados no prefixo '{prefix}'.")
        except ClientError as e:
            print(f"‚ùå Erro ao limpar S3 no prefixo '{prefix}': {e}")

    def _recriar_tabela_globalarena(self):
        """Deleta e recria a tabela GlobalArena com PK/SK."""
        table_name = "GlobalArena"
        try:
            print(f"üîç Verificando tabela '{table_name}'...")
            self.dynamodb.describe_table(TableName=table_name)
            print(f"üóëÔ∏è  Tabela '{table_name}' encontrada. Deletando...")
            self.dynamodb.delete_table(TableName=table_name)

            # Aguardar exclus√£o
            waiter = self.dynamodb.get_waiter('table_not_exists')
            waiter.wait(TableName=table_name, WaiterConfig={'Delay': 2, 'MaxAttempts': 30})
            print(f"‚úÖ Tabela '{table_name}' deletada.")
        except ClientError as e:
            if e.response['Error']['Code'] != 'ResourceNotFoundException':
                raise e
            print(f"‚ÑπÔ∏è  Tabela '{table_name}' n√£o existe. Ser√° criada.")

        # Criar tabela com PK/SK
        print(f"üÜï Criando tabela '{table_name}' com PK/SK...")
        try:
            self.dynamodb.create_table(
                TableName=table_name,
                AttributeDefinitions=[
                    {'AttributeName': 'PK', 'AttributeType': 'S'},
                    {'AttributeName': 'SK', 'AttributeType': 'S'}
                ],
                KeySchema=[
                    {'AttributeName': 'PK', 'KeyType': 'HASH'},
                    {'AttributeName': 'SK', 'KeyType': 'RANGE'}
                ],
                BillingMode='PAY_PER_REQUEST'
            )

            # Aguardar ativa√ß√£o
            waiter = self.dynamodb.get_waiter('table_exists')
            waiter.wait(TableName=table_name, WaiterConfig={'Delay': 2, 'MaxAttempts': 30})
            print(f"‚úÖ Tabela '{table_name}' criada e ativa.")
        except ClientError as e:
            print(f"‚ùå Falha ao criar tabela '{table_name}': {e}")
            raise


# ========================== CLI ==========================
if __name__ == "__main__":
    """
    Execu√ß√£o direta do m√≥dulo:
    $ python server/inicializador.py
    """
    print("üîß Inicializador AWS - Reinicializa√ß√£o de Infraestrutura\n")

    # Cria o loader AWS
    try:
        aws_loader = AWSLoader()
        print(f"‚úÖ Conectado √† AWS (regi√£o: {aws_loader.region_name})")
    except Exception as e:
        print(f"‚ùå Falha ao conectar √† AWS: {e}")
        exit(1)

    # Inicializa
    inicializador = InicializadorAWS(aws_loader)
    inicializador.inicializar(confirmar=True)

================================================================================
üìÑ server/config/extensions.py
================================================================================
# server/extensions.py
from server.integrations.aws_loader import AWSLoader

class Extensions:
    def __init__(self):
        self.dynamodb = None
        # self.redis = None # Futuro

    def init_app(self, app):
        """Inicializa as extens√µes com base na configura√ß√£o da app Flask."""
        try:
            aws_loader = AWSLoader(
                profile_name=app.config['AWS_PROFILE_NAME'],
                region_name=app.config['AWS_REGION_NAME']
            )
            self.dynamodb = aws_loader.get_client('dynamodb')
            print("‚úÖ Cliente DynamoDB conectado via Extensions.")
        except Exception as e:
            print(f"‚ùå Falha ao conectar ao DynamoDB na inicializa√ß√£o: {e}")
            self.dynamodb = None # Ou lan√ßar exce√ß√£o, dependendo da pol√≠tica de falhas

# Inst√¢ncia global
ext = Extensions()

================================================================================
üìÑ server/config/signals.py
================================================================================
# server/signals.py
from PyQt6.QtCore import QObject, pyqtSignal

class WorkerSignals(QObject):
    """
    Define sinais para comunica√ß√£o segura com a thread da UI.
    Usado pelo Comandante para enviar feedback.
    """
    success = pyqtSignal(object)   # resultado
    error = pyqtSignal(str)        # mensagem de erro
    finished = pyqtSignal()        # opera√ß√£o conclu√≠da

================================================================================
üìÑ server/config/config.py
================================================================================
# server/config.py
import os


class Config:
    # Flask
    SECRET_KEY = os.environ.get(
        'SECRET_KEY') or 'chave_secreta_dev_super_segura'  # Em produ√ß√£o, use vari√°vel de ambiente

    # AWS
    AWS_PROFILE_NAME = os.environ.get('AWS_PROFILE_NAME') or None
    AWS_REGION_NAME = os.environ.get('AWS_REGION_NAME') or 'us-east-2'  # Certifique-se de usar a mesma regi√£o

    # DynamoDB
    DYNAMODB_TABLE_NAME = os.environ.get(
        'DYNAMODB_TABLE_NAME') or 'GlobalArena'  # Ou 'UsuariosGlobalArena' se criar uma nova

    # Futuras configura√ß√µes (ex: Redis, Logging)
    # REDIS_URL = os.environ.get('REDIS_URL') or 'redis://localhost:6379/0'


class DevelopmentConfig(Config):
    DEBUG = True


class ProductionConfig(Config):
    DEBUG = False
    # SECRET_KEY = os.environ.get('SECRET_KEY') # Obrigat√≥rio em produ√ß√£o


config = {
    'development': DevelopmentConfig,
    'production': ProductionConfig,
    'default': DevelopmentConfig
}

================================================================================
üìÑ server/routes/game.py
================================================================================
# server/routes/game.py
"""
Rotas relacionadas ao jogo online (fila de matchmaking, status, etc).
Todas as rotas s√£o registradas dentro de uma fun√ß√£o f√°brica de blueprint,
permitindo inje√ß√£o expl√≠cita de depend√™ncias (UserService, MatchmakingService).
"""

from flask import Blueprint, jsonify, request
from server.services.user_service import UserService
from server.services.matchmaking_service import MatchmakingService


def create_game_blueprint(
    user_service: UserService,
    matchmaking_service: MatchmakingService
) -> Blueprint:
    """
    Cria o blueprint de rotas do jogo com as depend√™ncias injetadas.
    """
    jogo_bp = Blueprint("jogo", __name__, url_prefix="/jogo")

    @jogo_bp.route("/entrar", methods=["POST"])
    def entrar_na_fila():
        """Adiciona o jogador √† fila de matchmaking online."""
        if not request.is_json:
            return jsonify({"success": False, "message": "JSON esperado"}), 400

        data = request.get_json()
        modo = data.get("modo")
        username = data.get("username")

        if modo != "online":
            return jsonify({"success": False, "message": "Modo inv√°lido. Use 'online'."}), 400
        if not username:
            return jsonify({"success": False, "message": "Username necess√°rio."}), 400

        # Validar se o usu√°rio existe
        usuario = user_service.get_user(username)
        if not usuario:
            return jsonify({"success": False, "message": "Usu√°rio n√£o encontrado."}), 404

        # Tenta entrar na fila
        mensagem = matchmaking_service.entrar_na_fila(username)
        if "Erro ao entrar na fila" in mensagem:
            return jsonify({"success": False, "message": mensagem}), 409

        # Encontra a sala onde o jogador foi alocado
        sala_atual = next(
            (s for s in matchmaking_service.salas if username in s.jogadores),
            None
        )
        if not sala_atual:
            return jsonify({
                "success": False,
                "message": "Erro interno: jogador n√£o encontrado em nenhuma sala."
            }), 500

        total_na_fila = sum(len(sala.jogadores) for sala in matchmaking_service.salas)

        return jsonify({
            "success": True,
            "message": mensagem,
            "modo": modo,
            "total_na_fila": total_na_fila,
            "max_jogadores": sala_atual.vagas
        }), 200

    @jogo_bp.route("/sair", methods=["POST"])
    def sair_da_fila():
        """
        Permite que um jogador saia da fila de matchmaking.
        √ötil quando clica em 'Cancelar' na UI.
        """
        print(f"üîî Rota /jogo/sair chamada")
        if not request.is_json:
            print(f"‚ùå Requisi√ß√£o n√£o √© JSON")
            return jsonify({"success": False, "message": "JSON esperado"}), 400

        username = request.get_json().get("username")
        if not username:
            print(f"‚ö†Ô∏è Username ausente")
            return jsonify({"success": False, "message": "Username necess√°rio."}), 400

        if matchmaking_service.sair_da_fila(username):
            print(f"‚úÖ {username} saiu da fila com sucesso.")
            return jsonify({
                "success": True,
                "message": f"{username} saiu da fila com sucesso."
            }), 200
        print(f"‚ö†Ô∏è {username} n√£o estava na fila.")
        return jsonify({
            "success": False,
            "message": "Voc√™ n√£o estava na fila."
        }), 400

    @jogo_bp.route("/limpar_usuario", methods=["POST"])
    def limpar_usuario():
        """Remove o jogador de qualquer fila ou sala, mesmo que n√£o esteja na fila."""
        if not request.is_json:
            return jsonify({"success": False, "message": "JSON esperado"}), 400

        username = request.get_json().get("username")
        if not username:
            return jsonify({"success": False, "message": "Username necess√°rio"}), 400

        # Cleanup independente do estado
        matchmaking_service.sair_da_fila(username)
        return jsonify({"success": True, "message": f"Estado de {username} limpo."}), 200

    @jogo_bp.route("/estado", methods=["POST"])
    def estado_jogador():
        """
        Retorna o estado atual do jogador: se est√° na fila, em partida ou livre.
        √ötil para o cliente decidir qual UI mostrar.
        """
        print("üîµ [DEBUG] /jogo/estado: Requisi√ß√£o recebida")

        # 1. Verificar se o corpo √© JSON
        if not request.is_json:
            print("üî¥ [DEBUG] /jogo/estado: Requisi√ß√£o n√£o √© JSON")
            return jsonify({"error": "JSON esperado."}), 400

        # 2. Extrair o username
        data = request.get_json()
        print(f"üîµ [DEBUG] /jogo/estado: Dados recebidos: {data}")

        username = data.get("username")
        if not username:
            print("üî¥ [DEBUG] /jogo/estado: Username ausente no JSON")
            return jsonify({"error": "Username necess√°rio."}), 400

        print(f"üü¢ [DEBUG] /jogo/estado: Consultando estado do jogador: {username}")

        # 3. Verificar no MatchmakingService
        try:
            # Verifica se est√° em alguma sala (na fila)
            em_fila = any(username in sala.jogadores for sala in matchmaking_service.salas)
            print(f"üîµ [DEBUG] /jogo/estado: em_fila = {em_fila}")

            # Verifica se est√° em uma partida (sala cheia)
            em_partida = any(
                username in sala.jogadores and len(sala.jogadores) >= sala.vagas
                for sala in matchmaking_service.salas
            )
            print(f"üîµ [DEBUG] /jogo/estado: em_partida = {em_partida}")

            # Conta o total na fila
            total_na_fila = sum(len(sala.jogadores) for sala in matchmaking_service.salas)
            print(f"üü¢ [DEBUG] /jogo/estado: total_na_fila = {total_na_fila}")

            # Detalhar cada sala (para depura√ß√£o profunda)
            for i, sala in enumerate(matchmaking_service.salas):
                jogadores = sala.jogadores
                vagas = sala.vagas
                cheia = len(jogadores) >= vagas
                tem_usuario = username in jogadores
                print(
                    f"üîç [DEBUG] /jogo/estado: Sala {i}: jogadores={jogadores}, vagas={vagas}, cheia={cheia}, tem_usuario={tem_usuario}")

        except Exception as e:
            print(f"‚ùå [DEBUG] /jogo/estado: Erro ao verificar estado: {e}")
            return jsonify({"error": "Erro interno ao verificar estado."}), 500

        # 4. Retornar resposta
        response_data = {
            "success": True,
            "username": username,
            "em_fila": em_fila,
            "em_partida": em_partida,
            "total_na_fila": total_na_fila
        }
        print(f"üü¢ [DEBUG] /jogo/estado: Resposta enviada: {response_data}")

        return jsonify(response_data), 200

    @jogo_bp.route("/debug/salas", methods=["GET"])
    def debug_salas():
        """Rota de depura√ß√£o: mostra o estado de todas as salas."""
        with matchmaking_service.lock:
            salas_info = []
            for i, sala in enumerate(matchmaking_service.salas):
                with sala.lock:  # Acessa o estado interno da sala com seguran√ßa
                    salas_info.append({
                        "indice": i,
                        "id_mundo": sala.mundo.id_mundo,
                        "vagas": sala.vagas,
                        "jogadores": sala.jogadores.copy(),  # C√≥pia segura
                        "tamanho": len(sala.jogadores),
                        "esta_cheia": len(sala.jogadores) >= sala.vagas
                    })
            return jsonify({
                "success": True,
                "total_salas": len(salas_info),
                "salas": salas_info
            }), 200

    @jogo_bp.route("/minha_sala", methods=["POST"])
    def minha_sala():
        """Retorna o estado da sala do jogador: jogadores, vagas, se est√° cheia."""
        if not request.is_json:
            return jsonify({"error": "JSON esperado."}), 400

        username = request.get_json().get("username")
        if not username:
            return jsonify({"error": "Username necess√°rio."}), 400

        # Procurar a sala onde o jogador est√°
        for sala in matchmaking_service.salas:
            if username in sala.jogadores:
                return jsonify({
                    "em_fila": True,
                    "jogadores_na_sala": sala.jogadores.copy(),
                    "vagas": sala.vagas,
                    "esta_cheia": len(sala.jogadores) >= sala.vagas
                })

        # Se n√£o est√° em nenhuma sala
        return jsonify({
            "em_fila": False,
            "jogadores_na_sala": [],
            "vagas": 0,
            "esta_cheia": False
        }), 200

    return jogo_bp

================================================================================
üìÑ server/routes/auth.py
================================================================================
# server/routes/auth.py
"""
M√≥dulo de rotas de autentica√ß√£o (login, registro).
Gerencia a inje√ß√£o de depend√™ncia do UserService.
"""
import re
import bcrypt
import unicodedata
from flask import Blueprint, request, jsonify, current_app

# Cria o Blueprint com prefixo
auth_bp = Blueprint('auth', __name__, url_prefix='/auth')

# Vari√°vel global para inje√ß√£o de depend√™ncia
_user_service = None


def normalizar_username(username: str) -> str:
    """
    Normaliza o username: remove acentos, converte para min√∫sculas,
    substitui caracteres especiais por underscores.
    Retorna None se resultar em string vazia.
    """
    if not username:
        return None
    # Remove acentos
    username = unicodedata.normalize('NFKD', username)
    username = ''.join(c for c in username if not unicodedata.combining(c))
    # Substitui n√£o alfanum√©ricos por underscore
    username = re.sub(r'[^a-zA-Z0-9]', '_', username)
    # Min√∫sculas
    username = username.lower()
    # Underscores m√∫ltiplos ‚Üí √∫nico
    username = re.sub(r'_+', '_', username).strip('_')
    return username or None


def register_routes(user_service):
    """
    Fun√ß√£o de inje√ß√£o de depend√™ncia.
    Configura as rotas do auth_bp com o UserService fornecido.
    Deve ser chamada ANTES de registrar o blueprint no app.
    """
    global _user_service
    print(f"üì• DEBUG: Injetando user_service: {user_service}")
    _user_service = user_service

    # Valida se o servi√ßo foi injetado
    if not _user_service:
        print("‚ùå ERRO GRAVE: user_service √© None em register_routes!")
        raise RuntimeError("UserService n√£o injetado em auth_bp.")
    else:
        print(f"‚úÖ DEBUG: _user_service atribu√≠do com sucesso: {_user_service}")


# --- ENDPOINT: Teste de Conex√£o ---
@auth_bp.route('/teste_dynamodb', methods=['GET'])
def teste_dynamodb():
    """Testa a conex√£o com o DynamoDB via UserService."""
    if not _user_service or not _user_service.dynamodb:
        return jsonify({
            "status": "erro",
            "message": "Cliente DynamoDB n√£o dispon√≠vel."
        }), 500

    try:
        response = _user_service.dynamodb.list_tables()
        tabelas = response.get('TableNames', [])
        return jsonify({
            "status": "sucesso",
            "message": "Conex√£o com DynamoDB bem-sucedida.",
            "tabelas": tabelas
        }), 200
    except Exception as e:
        return jsonify({
            "status": "erro",
            "message": f"Falha ao acessar DynamoDB: {str(e)}"
        }), 500


# --- ENDPOINT: Registrar Usu√°rio ---
@auth_bp.route('/registrar', methods=['POST'])
def registrar():
    """
    Registra um novo usu√°rio.
    Expects: {"username": "str", "password": "str"}
    Returns: {"success": bool, "message": str}
    """
    if not request.is_json:
        return jsonify({"success": False, "message": "JSON esperado."}), 400

    data = request.get_json()
    username = data.get('username', '').strip()
    password = data.get('password', '')

    # Validar campos
    if not username or not password:
        return jsonify({"success": False, "message": "Username e senha s√£o obrigat√≥rios."}), 400
    if len(username) < 3:
        return jsonify({"success": False, "message": "Username deve ter pelo menos 3 caracteres."}), 400
    if len(password) < 6:
        return jsonify({"success": False, "message": "Senha deve ter pelo menos 6 caracteres."}), 400

    # Normalizar username (opcional)
    username_normalizado = normalizar_username(username)
    if not username_normalizado:
        return jsonify({"success": False, "message": "Username inv√°lido ap√≥s normaliza√ß√£o."}), 400

    # Verificar se j√° existe (usando o nome original)
    if _user_service.get_user(username):
        return jsonify({"success": False, "message": "Username j√° est√° em uso."}), 409

    # Hashear senha
    try:
        salt = bcrypt.gensalt()
        password_hash = bcrypt.hashpw(password.encode('utf-8'), salt)
    except Exception as e:
        print(f"‚ùå Erro ao hashear senha para '{username}': {e}")
        return jsonify({"success": False, "message": "Erro ao processar senha."}), 500

    # Salvar no DynamoDB
    sucesso = _user_service.create_user_item(username, password_hash=password_hash)
    if sucesso:
        print(f"‚úÖ Usu√°rio '{username}' registrado com sucesso.")
        return jsonify({"success": True, "message": "Usu√°rio registrado com sucesso."}), 201
    else:
        return jsonify({"success": False, "message": "Falha ao salvar no banco."}), 500


# --- ENDPOINT: Login ---
@auth_bp.route('/login', methods=['POST'])
def login():
    """
    Autentica um usu√°rio.
    Expects: {"username": "str", "password": "str"}
    Returns: {"success": bool, "message": str, "token": str (opcional)}
    """
    print("üîç DEBUG: Rota /auth/login foi chamada!")

    # Garantir acesso ao servi√ßo injetado via register_routes
    global _user_service
    if not _user_service:
        print("üí• ERRO: _user_service n√£o foi injetado!")
        return jsonify({
            "success": False,
            "message": "Erro interno do servidor."
        }), 500

    try:
        # 1. Validar formato da requisi√ß√£o
        if not request.is_json:
            print("‚ùå Requisi√ß√£o n√£o √© JSON")
            return jsonify({
                "success": False,
                "message": "JSON esperado."
            }), 400

        data = request.get_json()
        username = data.get('username', '').strip()
        password = data.get('password', '')

        print(f"üîê Tentativa de login - username: {username}")

        # 2. Validar campos obrigat√≥rios
        if not username:
            print("‚ö†Ô∏è Username ausente")
            return jsonify({
                "success": False,
                "message": "Username √© obrigat√≥rio."
            }), 400
        if not password:
            print("‚ö†Ô∏è Senha ausente")
            return jsonify({
                "success": False,
                "message": "Senha √© obrigat√≥ria."
            }), 400

        # 3. Buscar usu√°rio no DynamoDB
        usuario = _user_service.get_user(username)
        if not usuario:
            print(f"‚ùå Credenciais inv√°lidas para '{username}'.")
            return jsonify({
                "success": False,
                "message": "Credenciais inv√°lidas."
            }), 401

        # 4. Extrair e validar hash da senha
        password_hash_attr = usuario.get('password_hash')
        if not password_hash_attr:
            print(f"‚ùå Usu√°rio '{username}' sem password_hash.")
            return jsonify({
                "success": False,
                "message": "Credenciais inv√°lidas."
            }), 401

        # Suporta formato DynamoDB {'B': bytes} ou bytes direto
        stored_hash = password_hash_attr.get('B') if isinstance(password_hash_attr, dict) else password_hash_attr

        if not isinstance(stored_hash, bytes):
            print(f"‚ö†Ô∏è Hash inv√°lido para '{username}': {type(stored_hash)}")
            return jsonify({
                "success": False,
                "message": "Credenciais inv√°lidas."
            }), 401

        # 5. Verificar senha com bcrypt
        if bcrypt.checkpw(password.encode('utf-8'), stored_hash):
            print(f"‚úÖ Login bem-sucedido para '{username}'.")

            # üîê Gera um token fake para compatibilidade com o simulador
            # (Futuro: substituir por JWT real)
            fake_token = f"fake-jwt-{username}-{hash(username) % 10000}"

            return jsonify({
                "success": True,
                "message": "Login bem-sucedido.",
                "token": fake_token  # ‚Üê Adicionado para o simulador usar
            }), 200
        else:
            print(f"‚ùå Senha incorreta para '{username}'.")
            return jsonify({
                "success": False,
                "message": "Credenciais inv√°lidas."
            }), 401

    except Exception as e:
        print(f"üí• ERRO N√ÉO TRATADO em /auth/login: {type(e).__name__}: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({
            "success": False,
            "message": "Erro interno no servidor."
        }), 500

================================================================================
üìÑ server/core/commander.py
================================================================================
# server/commander.py
import queue
import threading
import time
import uuid
import random
from typing import Callable, Optional
from server.config.signals import WorkerSignals
from server.core.manager import Gerenciador
from server.config.initializer import InicializadorAWS


class Comando:
    def __init__(
        self,
        nome: str,
        callback: Callable,
        args=None,
        kwargs=None,
        on_success: Callable = None,
        on_error: Callable = None,
        signals: Optional[WorkerSignals] = None  # ‚úÖ Novo: sinais PyQt6
    ):
        self.id = str(uuid.uuid4())[:8]
        self.nome = nome
        self.callback = callback
        self.args = args or ()
        self.kwargs = kwargs or {}
        self.on_success = on_success  # ‚ö†Ô∏è Evite UI aqui
        self.on_error = on_error      # ‚ö†Ô∏è Evite UI aqui
        self.signals = signals        # ‚úÖ Use para UI segura
        self.timestamp = time.time()

    def __repr__(self):
        return f"<Comando(id={self.id}, nome='{self.nome}')>"


class Comandante:
    """
    Orquestrador de opera√ß√µes de dom√≠nio.
    Deve ser usado pela interface gr√°fica para disparar a√ß√µes ass√≠ncronas.
    Nunca deve conter l√≥gica de UI.
    """
    def __init__(self, gerenciador: Gerenciador, aws_loader):
        self.gerenciador = gerenciador
        self.aws_loader = aws_loader
        self.fila = queue.Queue()
        self.ativo = True
        self.thread = threading.Thread(target=self._loop, daemon=True)
        # üîÅ Estado da simula√ß√£o
        self.simulacao_ativa = False
        self.thread_simulacao: Optional[threading.Thread] = None

    def iniciar(self):
        """Inicia a thread de processamento de comandos."""
        self.thread.start()
        print("‚úÖ Comandante iniciado. Pronto para executar comandos.")

    def parar(self, timeout: float = 2.0):
        """Para o loop de comandos de forma segura."""
        self.ativo = False
        while not self.fila.empty():
            try:
                self.fila.get_nowait()
            except queue.Empty:
                break
        self.thread.join(timeout=timeout)
        if self.thread.is_alive():
            print("‚ö†Ô∏è Thread do Comandante n√£o encerrou a tempo.")
        else:
            print("üõë Comandante parado com sucesso.")

    def _loop(self):
        """Loop principal: executa comandos da fila."""
        while self.ativo:
            try:
                comando = self.fila.get(timeout=0.2)
                print(f"‚öôÔ∏è Executando [{comando.id}]: {comando.nome}")
                try:
                    resultado = comando.callback(*comando.args, **comando.kwargs)
                    print(f"‚úÖ [{comando.id}] {comando.nome} conclu√≠do.")

                    # ‚úÖ Primeiro: emitir sinais (seguro para UI)
                    if comando.signals:
                        comando.signals.success.emit(resultado)
                        comando.signals.finished.emit()

                    # ‚ö†Ô∏è Segundo: callbacks (cuidado! est√£o na thread secund√°ria)
                    if comando.on_success:
                        try:
                            comando.on_success(resultado)
                        except Exception as cb_e:
                            print(f"‚ö†Ô∏è Erro no callback on_success: {cb_e}")

                except Exception as e:
                    print(f"‚ùå [{comando.id}] Erro em '{comando.nome}': {e}")

                    # ‚úÖ Sinais de erro
                    if comando.signals:
                        comando.signals.error.emit(str(e))
                        comando.signals.finished.emit()

                    # ‚ö†Ô∏è Callbacks de erro
                    if comando.on_error:
                        try:
                            comando.on_error(str(e))
                        except Exception as cb_e:
                            print(f"‚ö†Ô∏è Erro no callback on_error: {cb_e}")

                finally:
                    self.fila.task_done()

            except queue.Empty:
                continue

    def _enviar_comando(self, nome: str, callback: Callable, *args, **kwargs):
        """
        M√©todo auxiliar para criar e enviar um comando.
        Aceita on_success, on_error e signals nos kwargs.
        """
        on_success = kwargs.pop('on_success', None)
        on_error = kwargs.pop('on_error', None)
        signals = kwargs.pop('signals', None)  # ‚úÖ Extrai os sinais

        comando = Comando(
            nome=nome,
            callback=callback,
            args=args,
            kwargs=kwargs,
            on_success=on_success,
            on_error=on_error,
            signals=signals  # ‚úÖ Passa os sinais
        )
        self.fila.put(comando)

    # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
    # Comandos de Dom√≠nio
    # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

    def criar_e_upload_mundo(
        self,
        fator: int,
        bioma: str,
        bucket_name: str = "global-arena-tiles",
        s3_prefix: str = "planetas/",
        dynamodb_table_name: str = "GlobalArena",
        on_success: Callable = None,
        on_error: Callable = None,
        signals: Optional[WorkerSignals] = None  # ‚úÖ Novo par√¢metro
    ):
        """Comando: cria e faz upload de um novo mundo."""
        def task():
            sucesso, mundo = self.gerenciador.criar_e_upload_mundo_com_retorno(
                fator=fator,
                bioma=bioma,
                bucket_name=bucket_name,
                s3_prefix=s3_prefix,
                dynamodb_table_name=dynamodb_table_name
            )
            return sucesso, mundo

        self._enviar_comando(
            nome=f"Criar e Upload Mundo (fator={fator}, bioma={bioma})",
            callback=task,
            on_success=on_success,
            on_error=on_error,
            signals=signals  # ‚úÖ Passa os sinais
        )

    def reinicializar_infra(
        self,
        confirmar: bool = False,
        on_success: Callable = None,
        on_error: Callable = None,
        signals: Optional[WorkerSignals] = None  # ‚úÖ Novo par√¢metro
    ):
        """Comando: reinicializa a infra AWS (S3 + DynamoDB)."""
        def task():
            inicializador = InicializadorAWS(self.aws_loader)
            sucesso = inicializador.inicializar(confirmar=confirmar)
            return sucesso

        self._enviar_comando(
            nome="Reinicializar Infra AWS",
            callback=task,
            on_success=on_success,
            on_error=on_error,
            signals=signals  # ‚úÖ Passa os sinais
        )

    def testar_conexao_aws(
        self,
        on_success: Callable = None,
        on_error: Callable = None,
        signals: Optional[WorkerSignals] = None  # ‚úÖ Novo par√¢metro
    ):
        """Comando: testa conex√£o com AWS (conta, S3, DynamoDB)."""
        def task():
            try:
                account = self.aws_loader.get_account_info()
                buckets = self.aws_loader.list_s3_buckets()
                tables = self.aws_loader.list_dynamodb_tables()
                return {
                    'success': True,
                    'account': account,
                    'buckets': buckets,
                    'tables': tables
                }
            except Exception as e:
                raise e

        self._enviar_comando(
            nome="Testar Conex√£o AWS",
            callback=task,
            on_success=on_success,
            on_error=on_error,
            signals=signals  # ‚úÖ Passa os sinais
        )

    def iniciar_simulacao_players(self, signals: Optional[WorkerSignals] = None):
        """Inicia a simula√ß√£o de players online."""
        def task():
            if self.simulacao_ativa:
                return

            self.simulacao_ativa = True
            contador = 0

            def entrar_na_fila(usuario):
                nonlocal contador
                try:
                    import requests
                    print(f"üîÑ [Comandante] Tentando login com: {usuario['username']}")  # ‚Üê Novo log
                    response = requests.post("http://localhost:5000/auth/login", json=usuario)
                    if response.status_code == 200:
                        token = response.json().get("token")
                        headers = {"Authorization": f"Bearer {token}"} if token else {}
                        print(f"üîÑ [Comandante] {usuario['username']} logado. Tentando entrar na fila...")  # ‚Üê Novo log

                        # Chamada para /jogo/entrar
                        response_entrar = requests.post(
                            "http://localhost:5000/jogo/entrar",
                            json={"modo": "online", "username": usuario["username"]},
                            headers=headers
                        )

                        # ‚úÖ Log da resposta
                        print(
                            f"üì® Resposta de /jogo/entrar para {usuario['username']}: {response_entrar.status_code} - {response_entrar.text}")

                        if response_entrar.status_code == 200:
                            contador += 1
                            if signals:
                                signals.success.emit(f"‚úÖ {usuario['username']} entrou na fila ({contador})")
                        else:
                            print(f"‚ùå Falha ao entrar na fila: {response_entrar.text}")
                    else:
                        print(f"‚ùå Login falhou para {usuario['username']}: {response.text}")

                except Exception as e:
                    print(f"‚ùå Erro ao processar {usuario['username']}: {e}")
                    if signals:
                        signals.error.emit(f"‚ùå Falha com {usuario['username']}")

            USUARIOS_SIMULADOS = [{"username": f"player{i:03d}", "password": "senha123"} for i in range(1, 51)]

            while self.simulacao_ativa:
                usuario = random.choice(USUARIOS_SIMULADOS)
                thread = threading.Thread(target=entrar_na_fila, args=(usuario,), daemon=True)
                thread.start()
                time.sleep(random.uniform(1.0, 3.0))

            if signals:
                signals.success.emit("üõë Simula√ß√£o encerrada.")

        self._enviar_comando(
            nome="Simular Players Online",
            callback=task,
            on_success=lambda msg: signals.success.emit(msg) if signals else None,
            on_error=lambda err: signals.error.emit(err) if signals else None,
            signals=signals
        )

    def parar_simulacao_players(self):
        """Para a simula√ß√£o de players."""
        self.simulacao_ativa = False

================================================================================
üìÑ server/core/simulador_players.py
================================================================================
# server/simulador_players.py
import requests
import random
import time
import threading

# Configura√ß√£o
URL_BASE = "http://localhost:5000"
NUM_PLAYERS = 50  # Quantidade de players simulados: player001 at√© player050

# Gera usu√°rios dinamicamente
USUARIOS_SIMULADOS = [{"username": f"player{i:03d}", "password": "senha123"} for i in range(1, 51)]
print("üéØ Simulador carregado com formatos: player001, player002, ...")

def registrar_usuario(usuario):
    """Tenta registrar o usu√°rio no servidor."""
    try:
        response = requests.post(f"{URL_BASE}/auth/registrar", json=usuario, timeout=3)
        data = response.json()
        if data.get("success"):
            print(f"üÜï Registrado: {usuario['username']}")
            return True
        else:
            # Pode j√° existir ‚Üí n√£o √© erro
            if "j√° est√° em uso" in data.get("message", ""):
                return True
            print(f"‚ùå Falha ao registrar {usuario['username']}: {data.get('message')}")
            return False
    except Exception as e:
        print(f"‚ö†Ô∏è Erro ao registrar {usuario['username']}: {e}")
        return False

def login_usuario(usuario):
    """Tenta fazer login. Se falhar por usu√°rio n√£o encontrado, tenta registrar."""
    try:
        response = requests.post(f"{URL_BASE}/auth/login", json=usuario, timeout=3)
        data = response.json()

        if data.get("success"):
            print(f"‚úÖ {usuario['username']} logou com sucesso.")
            return data.get("token")  # futuro: JWT
        else:
            mensagem = data.get("message", "")
            if "n√£o encontrado" in mensagem:
                print(f"üîÅ {usuario['username']} n√£o existe. Tentando registrar...")
                if registrar_usuario(usuario):
                    return login_usuario(usuario)  # Tenta logar novamente ap√≥s registrar
            else:
                print(f"‚ùå {usuario['username']} falhou: {mensagem}")
        return None
    except requests.exceptions.ConnectionError:
        print("üõë Erro: N√£o foi poss√≠vel conectar ao servidor. Certifique-se de que o servidor est√° rodando em http://localhost:5000")
        return None
    except Exception as e:
        print(f"‚ö†Ô∏è Erro inesperado ao logar {usuario['username']}: {e}")
        return None

def entrar_na_fila(usuario):
    """Ap√≥s login, entra na fila de jogo online."""
    token = login_usuario(usuario)
    if not token:
        return

    headers = {"Authorization": f"Bearer {token}"} if token else {}
    try:
        response = requests.post(
            f"{URL_BASE}/jogo/entrar",
            json={"modo": "online", "username": usuario["username"]},
            headers=headers,
            timeout=3
        )
        data = response.json()
        print(f"üéÆ {usuario['username']} ‚Üí {data.get('message')}")
    except Exception as e:
        print(f"‚ö†Ô∏è Falha ao entrar na fila: {e}")

def simular_entrada_periodica(intervalo_min=2, intervalo_max=5):
    """
    Simula entrada peri√≥dica e aleat√≥ria de players no sistema.
    Cada player tenta:
    1. Logar (ou se registrar, se necess√°rio)
    2. Entrar na fila de matchmaking
    """
    print(f"üîÑ Iniciando simula√ß√£o com {len(USUARIOS_SIMULADOS)} players...")
    print(f"üí° Intervalo: {intervalo_min}s a {intervalo_max}s entre tentativas")
    print("‚ÑπÔ∏è  Pressione Ctrl+C para parar.")

    while True:
        usuario = random.choice(USUARIOS_SIMULADOS)
        thread = threading.Thread(target=entrar_na_fila, args=(usuario,), daemon=True)
        thread.start()
        time.sleep(random.uniform(intervalo_min, intervalo_max))

if __name__ == "__main__":
    print("üöÄ Iniciando simulador de players online...")
    try:
        simular_entrada_periodica(intervalo_min=1.5, intervalo_max=4.0)
    except KeyboardInterrupt:
        print("\nüõë Simula√ß√£o encerrada pelo usu√°rio.")
    except Exception as e:
        print(f"\n‚ùå Erro inesperado: {e}")

================================================================================
üìÑ server/core/registrar_players.py
================================================================================
# server/registrar_players.py
import requests

# Lista de players a serem registrados
USUARIOS = [
    {"username": f"player{i:03d}", "password": "senha123"} for i in range(1, 51)
]

print("üìù Registrando 50 players de teste...")

for usuario in USUARIOS:
    response = requests.post("http://localhost:5000/auth/registrar", json=usuario)
    data = response.json()
    if data.get("success"):
        print(f"‚úÖ {usuario['username']} registrado com sucesso.")
    else:
        # Pode j√° existir ‚Üí n√£o √© erro
        if "j√° existe" in data.get("message", ""):
            print(f"üîÅ {usuario['username']} j√° registrado.")
        else:
            print(f"‚ùå Falha ao registrar {usuario['username']}: {data['message']}")

================================================================================
üìÑ server/core/admin_gui.py
================================================================================
# server/admin_gui.py
import sys
from PyQt6.QtWidgets import (
    QApplication, QMainWindow, QTabWidget, QWidget, QVBoxLayout,
    QComboBox, QSpinBox, QMessageBox, QFormLayout, QGroupBox,
    QFileDialog, QTextEdit, QPushButton
)
from server.config.signals import WorkerSignals
from server.serialization import Serializador
from server.core.manager import Gerenciador
from server.integrations.aws_loader import AWSLoader
from server.core.commander import Comandante


class ServerAdminGUI(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Gerenciador de Servidor - Global Arena")
        self.setGeometry(100, 100, 700, 500)

        # === Inicializa√ß√£o de depend√™ncias ===
        try:
            self.aws_loader = AWSLoader()
            self.gerenciador = Gerenciador(self.aws_loader)
            print("‚úÖ Gerenciador inicializado com AWS.")
        except Exception as e:
            QMessageBox.critical(self, "Erro AWS", f"N√£o foi poss√≠vel conectar √† AWS:\n{e}")
            self.gerenciador = None

        # ‚úÖ Inicializa o Comandante
        try:
            self.comandante = Comandante(self.gerenciador, self.aws_loader)
            self.comandante.iniciar()
            print("‚úÖ Comandante iniciado.")
        except Exception as e:
            QMessageBox.critical(self, "Erro", f"Falha ao iniciar o Comandante:\n{e}")
            self.comandante = None

        # ‚úÖ Cria e conecta os sinais
        self.setup_signals()

        # ‚úÖ Armazena o √∫ltimo mundo criado
        self.ultimo_mundo = None

        # Configura√ß√£o do sistema de abas
        self.tabs = QTabWidget()
        self.setCentralWidget(self.tabs)

        # ‚úÖ Cria as abas
        self.backup_tab = self.create_backup_tab()
        self.config_tab = QWidget()
        self.tabs.addTab(self.backup_tab, "Backup & Cria√ß√£o")
        self.tabs.addTab(self.config_tab, "Configura√ß√µes")

    def closeEvent(self, event):
        if self.comandante:
            self.comandante.parar()
        event.accept()

    def setup_signals(self):
        """Cria e conecta os sinais para comunica√ß√£o segura."""
        self.signals = WorkerSignals()
        self.signals.success.connect(self.on_success)
        self.signals.error.connect(self.on_error)
        self.signals.finished.connect(self.on_finished)

    def on_success(self, resultado):
        """Trata diferentes tipos de sucesso: cria√ß√£o de mundo ou mensagens de log."""
        if isinstance(resultado, tuple):
            # Caso 1: resultado de upload de mundo (sucesso, mundo)
            try:
                sucesso, mundo = resultado
                if sucesso:
                    self.ultimo_mundo = mundo
                    QMessageBox.information(
                        self, "Sucesso", f"Mundo {mundo.id_mundo} criado e enviado!"
                    )
                else:
                    QMessageBox.critical(self, "Falha", "Upload falhou.")
            except Exception as e:
                print(f"‚ùå Erro ao processar resultado de upload: {e}")
        else:
            # Caso 2: mensagem de log (ex: simula√ß√£o de players)
            self.log_output.append(f"üü¢ {resultado}")  # Exibe no widget de log
            print(f"üü¢ {resultado}")  # Tamb√©m imprime no terminal

    def on_error(self, mensagem: str):
        QMessageBox.critical(self, "Erro", f"Falha: {mensagem}")

    def on_finished(self):
        print("‚úÖ Opera√ß√£o conclu√≠da.")

    # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
    # M√©todos para constru√ß√£o da UI
    # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

    def create_backup_tab(self):
        """Cria a aba de opera√ß√µes de backup e cria√ß√£o de mundos"""
        tab = QWidget()
        layout = QVBoxLayout()

        # === Grupo: Criar e Upload de Mundo ===
        group_criar = QGroupBox("Criar e Enviar Novo Mundo")
        form_layout = QFormLayout()

        self.spin_fator = QSpinBox()
        self.spin_fator.setMinimum(2)
        self.spin_fator.setMaximum(8)
        self.spin_fator.setValue(4)
        form_layout.addRow("Fator:", self.spin_fator)

        self.combo_bioma = QComboBox()
        biomas = ["Meadow", "Forest", "Savanna", "Desert", "Hills", "Mountains"]
        self.combo_bioma.addItems(biomas)
        self.combo_bioma.setCurrentText("Meadow")
        form_layout.addRow("Bioma Inicial:", self.combo_bioma)

        group_criar.setLayout(form_layout)
        layout.addWidget(group_criar)

        btn_upload = QPushButton("üåç Criar e Enviar Mundo para Nuvem")
        btn_upload.clicked.connect(self.handle_criar_e_upload)
        layout.addWidget(btn_upload)

        layout.addSpacing(20)

        # === Grupo: Simula√ß√£o de Players ===
        group_sim = QGroupBox("Simula√ß√£o de Players Online")
        layout_sim = QVBoxLayout()

        btn_iniciar_sim = QPushButton("‚ñ∂Ô∏è Iniciar Simula√ß√£o de Players")
        btn_iniciar_sim.setStyleSheet("""
            QPushButton { background-color: #27ae60; color: white; font-weight: bold; border-radius: 6px; padding: 8px; }
            QPushButton:hover { background-color: #2ecc71; }
        """)
        btn_iniciar_sim.clicked.connect(self.handle_iniciar_simulacao)
        layout_sim.addWidget(btn_iniciar_sim)

        btn_parar_sim = QPushButton("‚èπÔ∏è Parar Simula√ß√£o de Players")
        btn_parar_sim.setStyleSheet("""
            QPushButton { background-color: #e74c3c; color: white; font-weight: bold; border-radius: 6px; padding: 8px; }
            QPushButton:hover { background-color: #c0392b; }
        """)
        btn_parar_sim.clicked.connect(self.handle_parar_simulacao)
        layout_sim.addWidget(btn_parar_sim)

        group_sim.setLayout(layout_sim)
        layout.addWidget(group_sim)

        layout.addSpacing(20)

        # === Grupo: Salvar Localmente ===
        group_local = QGroupBox("Salvar Estado Localmente")
        layout_local = QVBoxLayout()

        btn_save = QPushButton("üíæ Salvar Estado como JSON (Local)")
        btn_save.clicked.connect(self.handle_save_json)
        layout_local.addWidget(btn_save)

        group_local.setLayout(layout_local)
        layout.addWidget(group_local)

        layout.addSpacing(20)

        # === Bot√£o: Reinicializar Infraestrutura AWS ===
        btn_reiniciar = QPushButton("‚ö†Ô∏è Reinicializar Infraestrutura AWS")
        btn_reiniciar.setStyleSheet("""
            QPushButton {
                background-color: #a83232;
                color: white;
                font-weight: bold;
                border-radius: 6px;
                padding: 8px;
            }
            QPushButton:hover {
                background-color: #c03939;
            }
        """)
        btn_reiniciar.clicked.connect(self.handle_reinicializar_servidor)
        layout.addWidget(btn_reiniciar)
        layout.addSpacing(10)

        # === Log de Atividades ===
        self.log_output = QTextEdit()
        self.log_output.setReadOnly(True)
        self.log_output.setMaximumHeight(150)
        self.log_output.setPlaceholderText("Log de atividades...")
        layout.addWidget(self.log_output)

        layout.addStretch()
        tab.setLayout(layout)
        return tab

    def handle_iniciar_simulacao(self):
        """Inicia a simula√ß√£o de players online."""
        if not self.comandante:
            QMessageBox.critical(self, "Erro", "Comandante n√£o est√° dispon√≠vel.")
            return
        self.comandante.iniciar_simulacao_players(signals=self.signals)

    def handle_parar_simulacao(self):
        """Para a simula√ß√£o de players online."""
        if not self.comandante:
            return
        self.comandante.parar_simulacao_players()
        self.signals.success.emit("üõë Simula√ß√£o interrompida pelo usu√°rio.")

    def handle_save_json(self):
        """Salva o √∫ltimo mundo criado (se existir) como JSON local."""
        if not self.ultimo_mundo:
            QMessageBox.warning(self, "Aviso", "Nenhum mundo foi criado ainda.")
            return

        try:
            mundo = self.ultimo_mundo
            filepath, _ = QFileDialog.getSaveFileName(
                self,
                "Salvar Mundo como JSON",
                f"saves/mundo_{mundo.id_mundo}.json",
                "JSON Files (*.json)"
            )
            if not filepath:
                return  # Cancelado

            caminho_salvo = Serializador.save_mundo(mundo, filepath)
            if caminho_salvo:
                QMessageBox.information(
                    self, "Sucesso", f"Mundo salvo localmente:\n{caminho_salvo}"
                )
            else:
                QMessageBox.critical(self, "Falha", "Erro ao salvar o arquivo.")
        except Exception as e:
            QMessageBox.critical(self, "Erro", f"Falha ao salvar: {str(e)}")

    def handle_criar_e_upload(self):
        if not self.comandante:
            QMessageBox.critical(self, "Erro", "Comandante n√£o est√° dispon√≠vel.")
            return

        fator = self.spin_fator.value()
        bioma = self.combo_bioma.currentText()

        self.comandante.criar_e_upload_mundo(
            fator=fator,
            bioma=bioma,
            signals=self.signals
        )

    def handle_reinicializar_servidor(self):
        if not self.comandante:
            QMessageBox.critical(self, "Erro", "Comandante n√£o est√° dispon√≠vel.")
            return

        reply = QMessageBox.question(
            self,
            "‚ö†Ô∏è Reinicializar Infraestrutura",
            "Isso apagar√° TODOS os mundos e metadados no S3 e DynamoDB.\n"
            "Continuar?",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
        )
        if reply != QMessageBox.StandardButton.Yes:
            return

        self.comandante.reinicializar_infra(
            confirmar=False,
            signals=self.signals
        )


# Execu√ß√£o da aplica√ß√£o
if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = ServerAdminGUI()
    window.show()
    sys.exit(app.exec())

================================================================================
üìÑ server/core/manager.py
================================================================================
# server/manager.py
import json
import time
from pathlib import Path
from typing import Optional, Tuple

from server.serialization import Serializador
from server.integrations.aws_loader import AWSLoader
from shared.world import Mundo


class Gerenciador:
    """
    Gerencia opera√ß√µes de mundo: cria√ß√£o, serializa√ß√£o, upload S3 e salvamento de metadados no DynamoDB.
    Nada √© salvo localmente.
    """

    def __init__(self,
                 aws_loader: AWSLoader,
                 save_dir: str = "saves",
                 dynamodb_table_name: str = "GlobalArena"):  # ‚úÖ Adicione o par√¢metro
        self.aws_loader = aws_loader
        self.save_dir = Path(save_dir)
        self.save_dir.mkdir(exist_ok=True)
        self.dynamodb_table_name = dynamodb_table_name  # ‚úÖ Armazena o nome da tabela

    # server/manager.py

    def upload_mundo(self,
                     mundo: Mundo,
                     bucket_name: str = "global-arena-tiles",
                     s3_prefix: str = "planetas/",
                     dynamodb_table_name: str = "GlobalArena") -> bool:
        """
        Faz upload do mundo: dados pesados para S3, metadados leves para DynamoDB.
        Agora com rollback se falhar no DynamoDB.
        """
        try:
            pk = f"PLANET#{mundo.id_mundo}"
            sk = "METADATA"
            s3_key = f"{s3_prefix}{mundo.id_mundo}.json"

            # --- Verificar se j√° existe no DynamoDB ---
            dynamodb = self.aws_loader.get_client('dynamodb')
            response = dynamodb.get_item(
                TableName=dynamodb_table_name,
                Key={'PK': {'S': pk}, 'SK': {'S': sk}}
            )
            if 'Item' in response:
                print(f"‚ùå Mundo com ID {mundo.id_mundo} j√° existe no DynamoDB.")
                return False

            # --- Serializar e enviar para S3 ---
            dados_s3 = Serializador.to_serializable_dict(mundo)
            dados_json = json.dumps(dados_s3, ensure_ascii=False, indent=2)

            s3 = self.aws_loader.get_client('s3')
            s3.put_object(
                Bucket=bucket_name,
                Key=s3_key,
                Body=dados_json,
                ContentType='application/json'
            )
            print(f"‚úÖ Upload para S3 conclu√≠do: s3://{bucket_name}/{s3_key}")

            # --- Salvar metadados no DynamoDB ---
            try:
                bioma_inicial = getattr(mundo.planeta, 'bioma_inicial', 'Desconhecido')
                vagas = getattr(mundo.planeta, 'numero_de_jogadores', 0)

                dynamodb.put_item(
                    TableName=dynamodb_table_name,
                    Item={
                        'PK': {'S': pk},
                        'SK': {'S': sk},
                        'entityType': {'S': 'Planet'},
                        'fator': {'N': str(mundo.planeta.fator)},
                        'bioma_inicial': {'S': bioma_inicial},
                        'vagas': {'N': str(vagas)},
                        'timestamp': {'N': str(int(time.time()))},
                        'status': {'S': 'disponivel'}
                    }
                )
                print(f"‚úÖ Metadados do mundo {mundo.id_mundo} salvos no DynamoDB.")
                return True

            except Exception as e:
                print(f"‚ùå Falha ao salvar no DynamoDB: {e}")
                print(f"üßπ Removendo arquivo √≥rf√£o do S3: s3://{bucket_name}/{s3_key}")
                try:
                    s3.delete_object(Bucket=bucket_name, Key=s3_key)
                    print("‚úÖ Arquivo √≥rf√£o removido com sucesso.")
                except Exception as del_e:
                    print(f"‚ö†Ô∏è Falha ao remover arquivo √≥rf√£o do S3: {del_e}")
                return False

        except Exception as e:
            print(f"‚ùå Erro inesperado durante upload_mundo: {e}")
            return False

    def criar_e_upload_mundo(
        self,
        fator: int,
        bioma: str,
        bucket_name: str = "global-arena-tiles",
        s3_prefix: str = "planetas/"
    ) -> bool:
        """
        Cria um novo mundo com fator e bioma dados, e faz upload direto para S3 + DynamoDB.

        :param fator: N√≠vel de detalhe da grade geogr√°fica (ex: 4)
        :param bioma: Bioma inicial para escolha de capitais (ex: "Meadow")
        :param bucket_name: Nome do bucket S3
        :param s3_prefix: Prefixo (pasta) no bucket
        :return: True se sucesso, False caso contr√°rio
        """
        try:
            print(f"üåç Criando mundo com fator={fator}, bioma='{bioma}'...")
            mundo = Mundo(fator=fator, bioma=bioma)
            print(f"‚úÖ Mundo criado: {mundo.id_mundo}")

            sucesso = self.upload_mundo(mundo, bucket_name=bucket_name, s3_prefix=s3_prefix)

            if sucesso:
                print(f"üéâ Mundo {mundo.id_mundo} enviado com sucesso para a nuvem!")
            else:
                print(f"‚ùå Falha no upload do mundo {mundo.id_mundo}")

            return sucesso

        except Exception as e:
            print(f"‚ùå Erro ao criar e upload mundo: {e}")
            return False

    def criar_e_upload_mundo_com_retorno(
            self,
            fator: int,
            bioma: str,
            bucket_name: str = "global-arena-tiles",
            s3_prefix: str = "planetas/",
            dynamodb_table_name: str = "GlobalArena"
    ) -> Tuple[bool, Optional[Mundo]]:
        """
        Cria um novo mundo com fator e bioma dados, faz upload para S3 + DynamoDB,
        e retorna sucesso e a inst√¢ncia do mundo.
        """
        try:
            print(f"üåç Criando mundo com fator={fator}, bioma='{bioma}'...")
            mundo = Mundo(fator=fator, bioma=bioma)
            print(f"‚úÖ Mundo criado: {mundo.id_mundo}")

            sucesso = self.upload_mundo(
                mundo,
                bucket_name=bucket_name,
                s3_prefix=s3_prefix,
                dynamodb_table_name=dynamodb_table_name
            )

            if sucesso:
                print(f"üéâ Mundo {mundo.id_mundo} enviado com sucesso para a nuvem!")
            else:
                print(f"‚ùå Falha no upload do mundo {mundo.id_mundo}")

            return sucesso, mundo

        except Exception as e:
            print(f"‚ùå Erro ao criar e upload mundo: {e}")
            import traceback
            traceback.print_exc()
            return False, None

    def criar_mundo(self, fator: int, bioma: str) -> Mundo:
        """Cria e retorna um novo mundo."""
        return Mundo(fator=fator, bioma=bioma)

================================================================================
üìÑ client/main.py
================================================================================
# client/main.py

import sys
import os
import requests
from PyQt6.QtWidgets import (
    QApplication, QMainWindow, QWidget, QVBoxLayout, QLabel, QPushButton, QHBoxLayout,
    QSizePolicy, QFrame, QMessageBox, QDialog, QFormLayout, QLineEdit, QDialogButtonBox
)
from PyQt6.QtCore import QTimer, Qt
from PyQt6.QtGui import QSurfaceFormat, QFont
from client.components.icon_manager import GerenciadorIconesEsquerda
from client.dialogs.auth_dialog import DialogoAutenticacao
from client.widgets.waiting_room_overlay import WaitingRoomOverlay
from client.widgets.offline_setup_overlay import OfflineSetupOverlay
from client.rendering.opengl_widget import OpenGLWidget
from client.widgets.match_overlay import OverlayPartida

# --- Componente Janela Principal ---
class JanelaPrincipal(QMainWindow):
    """
    Janela principal da aplica√ß√£o, contendo a UI 2D e o widget OpenGL.
    Layout: Barras Superior/Inferior (5% da altura),
            Laterais (max(320px, 15% da largura)),
            √Årea Central para o conte√∫do OpenGL.
    """

    def __init__(self):
        super().__init__()
        self.setWindowTitle("Global Arena - Cliente PyQt6")

        # === Estado e Controle ===
        self.usuario_logado = self._verificar_login()
        self.loop_ativo = True
        self.overlay_sala = None
        self.polling_timer = None
        self.game_placeholder = None

        # === Dimens√µes da Tela ===
        screen_geometry = self.screen().availableGeometry()
        screen_width = screen_geometry.width()
        screen_height = screen_geometry.height()
        bar_height = int(screen_height * 0.05)
        sidebar_width = max(320, int(screen_width * 0.15))

        print(f"üéÆ Janela PyQt6 criada. Tela: {screen_width}x{screen_height}. "
              f"Barras H: {bar_height}px, Barras V: {sidebar_width}px")

        # === Layout Principal da Janela ===
        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        main_window_layout = QVBoxLayout(central_widget)
        main_window_layout.setContentsMargins(0, 0, 0, 0)
        main_window_layout.setSpacing(0)

        # === Barra Superior ===
        self.barra_superior = self._criar_barra(bar_height, is_horizontal=True, object_name="BarraSuperior")
        layout_barra_superior = QHBoxLayout(self.barra_superior)
        layout_barra_superior.setContentsMargins(10, 5, 10, 5)
        label_status = QLabel("Status: Aguardando...")
        layout_barra_superior.addWidget(label_status)
        layout_barra_superior.addStretch()

        # === Conte√∫do Principal (Barra Esquerda + √Årea Central + Barra Direita) ===
        conteudo_principal_widget = QWidget()
        conteudo_principal_layout = QHBoxLayout(conteudo_principal_widget)
        conteudo_principal_layout.setContentsMargins(0, 0, 0, 0)
        conteudo_principal_layout.setSpacing(0)

        # --- Barra Esquerda (com transpar√™ncia) ---
        self.barra_esquerda = self._criar_barra(sidebar_width, is_horizontal=False, object_name="BarraEsquerda")
        self.barra_esquerda.setAttribute(Qt.WidgetAttribute.WA_TranslucentBackground)
        self.barra_esquerda.setStyleSheet("""
            #BarraEsquerda {
                background-color: rgba(25, 25, 35, 180);
                border-right: 1px solid #3498db;
            }
            QLabel {
                color: #ecf0f1;
            }
        """)
        layout_esquerda = QVBoxLayout(self.barra_esquerda)
        layout_esquerda.setContentsMargins(0, 0, 0, 0)

        self.gerenciador_icones = GerenciadorIconesEsquerda(caminho_recursos="client/resources")
        self.gerenciador_icones.icone_clicado.connect(self._ao_clicar_icone_lateral)

        if self.usuario_logado:
            try:
                with open("session.txt", "r") as f:
                    nome_usuario = f.read().strip()
                if not nome_usuario:
                    raise ValueError("Nome vazio")
            except Exception as e:
                print(f"‚ùå Erro ao ler session.txt: {e}")
                nome_usuario = "Player"
            self.gerenciador_icones.atualizar_estado_login(True, nome_usuario)
        else:
            self.gerenciador_icones.atualizar_estado_login(False)

        layout_esquerda.addWidget(self.gerenciador_icones)

        # --- √Årea Central (OpenGL + Overlay) ---
        area_central_widget = QWidget()
        area_central_layout = QHBoxLayout(area_central_widget)
        area_central_layout.setContentsMargins(0, 0, 0, 0)
        area_central_layout.setSpacing(0)

        # Container OpenGL
        self.opengl_container = QWidget()
        container_layout = QVBoxLayout(self.opengl_container)
        container_layout.setContentsMargins(0, 0, 0, 0)
        container_layout.setSpacing(0)

        # Widget OpenGL
        self.opengl_widget = OpenGLWidget()
        self.opengl_widget.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
        container_layout.addWidget(self.opengl_widget)

        # Overlay de Boas-Vindas (centralizado)
        self.overlay_widget = QWidget(self.opengl_container)
        self.overlay_widget.setAttribute(Qt.WidgetAttribute.WA_TranslucentBackground)
        self.overlay_widget.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents)
        self.overlay_widget.setStyleSheet("background-color: rgba(0, 0, 0, 120); border: none;")

        overlay_layout = QVBoxLayout(self.overlay_widget)
        overlay_layout.setContentsMargins(0, 0, 0, 0)
        overlay_layout.setSpacing(10)
        overlay_layout.setAlignment(Qt.AlignmentFlag.AlignCenter)

        # Labels (mantidos como antes)
        self.label_welcome = QLabel("Welcome to")
        font_welcome = QFont()
        font_welcome.setPointSize(14)
        font_welcome.setItalic(True)
        font_welcome.setWeight(500)
        self.label_welcome.setFont(font_welcome)
        self.label_welcome.setStyleSheet("color: #aaaaaa; background: transparent; border: none;")
        self.label_welcome.setAlignment(Qt.AlignmentFlag.AlignCenter)

        self.label_titulo = QLabel("Global Arena")
        font_titulo = QFont()
        font_titulo.setPointSize(48)
        font_titulo.setBold(True)
        font_titulo.setWeight(700)
        self.label_titulo.setFont(font_titulo)
        self.label_titulo.setStyleSheet("""
            color: white;
            background-color: transparent;
            border: none;
            text-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
        """)
        self.label_titulo.setAlignment(Qt.AlignmentFlag.AlignCenter)

        self.label_subtitulo = QLabel("the only one for non-flat-earthers")
        font_subtitulo = QFont()
        font_subtitulo.setPointSize(16)
        font_subtitulo.setItalic(True)
        self.label_subtitulo.setFont(font_subtitulo)
        self.label_subtitulo.setStyleSheet("""
            color: #cccccc;
            background-color: transparent;
            border: none;
            font-style: italic;
        """)
        self.label_subtitulo.setAlignment(Qt.AlignmentFlag.AlignCenter)

        overlay_layout.addWidget(self.label_welcome)
        overlay_layout.addWidget(self.label_titulo)
        overlay_layout.addWidget(self.label_subtitulo)

        # --- Ajuste de Tamanho e Posi√ß√£o do Overlay ---
        def _safe_resize_event(event):
            self.overlay_widget.setGeometry(self.opengl_container.rect())
            self.overlay_widget.raise_()
            if hasattr(self, 'overlay_sala') and self.overlay_sala:
                self._ajustar_overlay_sala()
                self.overlay_sala.raise_()
            QWidget.resizeEvent(self.opengl_container, event)

        self.opengl_container.resizeEvent = _safe_resize_event

        # Mostrar overlay imediatamente
        self.overlay_widget.setGeometry(self.opengl_container.rect())
        self.overlay_widget.raise_()
        self.overlay_widget.show()

        QTimer.singleShot(50, lambda: [
            self.overlay_widget.setGeometry(self.opengl_container.rect()),
            self.overlay_widget.raise_(),
            self.overlay_widget.show()
        ])

        # Adicionar OpenGL ao layout central
        area_central_layout.addWidget(self.opengl_container)

        # --- Barra Direita (com transpar√™ncia, mesma apar√™ncia da esquerda) ---
        self.barra_direita = self._criar_barra(sidebar_width, is_horizontal=False, object_name="BarraDireita")
        self.barra_direita.setAttribute(Qt.WidgetAttribute.WA_TranslucentBackground)
        self.barra_direita.setStyleSheet("""
            #BarraDireita {
                background-color: rgba(25, 25, 35, 180);
                border-left: 1px solid #3498db;
            }
            QLabel {
                color: #ecf0f1;
            }
        """)

        layout_direita = QVBoxLayout(self.barra_direita)
        layout_direita.addStretch()
        banner_placeholder = QLabel("Banner\n300x600")
        banner_placeholder.setFixedSize(300, 600)
        banner_placeholder.setStyleSheet("""
            background-color: rgba(30, 30, 40, 200);
            color: white;
            border: 1px solid #555;
            border-radius: 8px;
            font-size: 14px;
        """)
        banner_placeholder.setAlignment(Qt.AlignmentFlag.AlignCenter)
        layout_direita.addWidget(banner_placeholder, alignment=Qt.AlignmentFlag.AlignCenter)
        layout_direita.addStretch()

        # --- Adicionar widgets √† √°rea central ---
        area_central_layout.addWidget(self.opengl_container)
        area_central_layout.addWidget(self.barra_direita)

        # --- Adicionar barra esquerda e √°rea central ao conte√∫do principal ---
        conteudo_principal_layout.addWidget(self.barra_esquerda)
        conteudo_principal_layout.addWidget(area_central_widget)

        # === Barra Inferior ===
        self.barra_inferior = self._criar_barra(bar_height, is_horizontal=True, object_name="BarraInferior")
        self.barra_inferior.setAttribute(Qt.WidgetAttribute.WA_TranslucentBackground)
        self.barra_inferior.setStyleSheet("""
            #BarraInferior {
                background-color: rgba(25, 25, 35, 180);
                border-top: 1px solid #3498db;
            }
            QLabel {
                color: #ecf0f1;
            }
        """)
        layout_barra_inferior = QHBoxLayout(self.barra_inferior)
        layout_barra_inferior.addWidget(QLabel("Barra Inferior"))

        # === Montagem Final da Janela ===
        main_window_layout.addWidget(self.barra_superior)
        main_window_layout.addWidget(conteudo_principal_widget)
        main_window_layout.addWidget(self.barra_inferior)

        # === Loop de Atualiza√ß√£o (60 FPS) ===
        self.timer = QTimer(self)
        self.timer.timeout.connect(self.atualizar_logica)
        self.timer.start(16)

        # === Exibi√ß√£o ===
        self.show()
        self.setWindowState(Qt.WindowState.WindowFullScreen)

        # === Debug Final ===
        print("‚úÖ Janela exibida. Overlay for√ßado a aparecer.")
        print("üîç Geometria do container:", self.opengl_container.geometry())
        print("üîç Geometria do overlay:", self.overlay_widget.geometry())
        print("üîç Overlay vis√≠vel?", self.overlay_widget.isVisible())

        self.partida_iniciada = False

        self.overlay_partida = OverlayPartida(parent=self.barra_esquerda)
        self.overlay_partida.hide()  # Come√ßa escondido

    def _iniciar_partida(self, modo: str, **kwargs):
        """
        M√©todo centralizado para iniciar qualquer tipo de partida.
        Garante que flags, overlays e estado sejam tratados de forma consistente.
        """
        print(f"üü¢ [DEBUG] _iniciar_partida: Iniciando partida {modo}...")

        # ‚úÖ Evitar m√∫ltiplas chamadas (evita bugs de duplo clique)
        if hasattr(self, 'partida_iniciada') and self.partida_iniciada:
            print("üü° [DEBUG] _iniciar_partida: Partida j√° iniciada. Ignorando nova chamada.")
            return

        # ‚úÖ Parar o loop de renderiza√ß√£o antes de alterar a UI
        self.parar_loop()
        print("‚è∏Ô∏è [DEBUG] Render loop parado.")

        # --- Configura√ß√£o espec√≠fica por modo ---
        try:
            if modo == "offline":
                fator = kwargs.get("fator", 4)
                bioma = kwargs.get("bioma", "Meadow")
                print(f"üéÆ [DEBUG] Modo offline: fator={fator}, bioma='{bioma}'")
                self._configurar_modo_offline(fator, bioma)

            elif modo == "online":
                # L√≥gica ser√° tratada pelo sistema de fila e polling
                print("üåê [DEBUG] Modo online: a l√≥gica ser√° gerenciada pelo MatchmakingService.")
                # Aqui pode-se adicionar: entrar_na_fila(), iniciar_polling(), etc.
                pass

            else:
                print(f"‚ùå [ERRO] Modo desconhecido: {modo}")
                return

        except Exception as e:
            print(f"‚ùå Erro ao configurar modo '{modo}': {e}")
            import traceback
            traceback.print_exc()
            return

        # ‚úÖ Esconder overlays de espera (sala, boas-vindas, etc.)
        self._esconder_overlay_sala_espera()

        # ‚úÖ Ativar modo de jogo no OpenGL
        if hasattr(self, 'opengl_widget') and self.opengl_widget:
            self.opengl_widget.ativar_modo_jogo()
            self.opengl_widget.update()
            print("üéÆ [DEBUG] OpenGLWidget ativado e atualizado.")
        else:
            print("‚ùå [ERRO] opengl_widget n√£o dispon√≠vel para ativa√ß√£o.")

        # ‚úÖ Chamar o m√©todo de finaliza√ß√£o (limpeza, overlay de a√ß√µes, etc.)
        print("üîµ [DEBUG] _iniciar_partida: Chamando on_partida_iniciada() para finalizar transi√ß√£o")
        self.on_partida_iniciada()

        print("‚úÖ Transi√ß√£o para partida conclu√≠da.")

    def _configurar_modo_offline(self, fator, bioma):
        try:
            from shared.world import Mundo
            self.mundo = Mundo(fator=fator, bioma=bioma)
            print(
                f"‚úÖ Mundo criado: fator={fator}, bioma='{bioma}', prov√≠ncias={len(self.mundo.planeta.geografia.nodes)}")
            self.opengl_widget.carregar_mundo(self.mundo)

            # --- üîÅ For√ßar reset da c√¢mera para enxergar o planeta ---
            self.opengl_widget.camera.resetar(fator)

            # --- üîπ DEFINIR CIVILIZA√á√ÉO DO JOGADOR HUMANO ---
            civilizacoes_player = [civ for civ in self.mundo.civs if civ.player]
            if civilizacoes_player:
                import random
                civ_jogador = random.choice(civilizacoes_player)
                civ_jogador.eh_jogador_local = True
                self.civ_jogador = civ_jogador
                print(f"üéÆ Jogador humano definido: {civ_jogador.nome}")

                # --- üîπ CENTRALIZAR C√ÇMERA NA PROV√çNCIA INICIAL (DEPOIS DO RESET) ---
                if civ_jogador.provincias:
                    provincia_inicial = civ_jogador.provincias[0]
                    self.opengl_widget.centralizar_em(provincia_inicial.coordenadas)
                    print(f"üìç C√¢mera centralizada na prov√≠ncia do jogador: {provincia_inicial.coordenadas}")

        except Exception as e:
            print(f"‚ùå Erro ao criar mundo offline: {e}")

    def _mostrar_dialogo_modos(self):
        """Exibe um di√°logo para escolher entre modo Offline e Online."""
        # Evita m√∫ltiplas aberturas do di√°logo
        if hasattr(self, '_modo_dialog_aberto') and self._modo_dialog_aberto:
            return
        self._modo_dialog_aberto = True

        modo_dialog = QDialog(self)
        modo_dialog.setWindowTitle("Modo de Jogo")
        modo_dialog.setModal(True)
        modo_dialog.resize(300, 150)
        modo_dialog.setStyleSheet("""
            QDialog {
                background-color: #2c3e50;
                font-family: Arial;
            }
            QLabel {
                color: #ecf0f1;
                font-size: 14px;
                margin-bottom: 15px;
            }
            QPushButton {
                background-color: #3498db;
                color: white;
                border: none;
                padding: 10px;
                border-radius: 6px;
                font-size: 13px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #2980b9;
            }
        """)

        layout = QVBoxLayout()
        layout.setSpacing(10)
        layout.setContentsMargins(20, 20, 20, 20)

        # T√≠tulo
        label = QLabel("Selecione o modo de jogo:")
        layout.addWidget(label)

        # Bot√µes
        btn_offline = QPushButton("üéÆ Offline")
        btn_offline.clicked.connect(lambda: [
            modo_dialog.accept(),
            self._mostrar_overlay_offline()
        ])
        btn_online = QPushButton("üåê Online")

        layout.addWidget(btn_offline)
        layout.addWidget(btn_online)

        modo_dialog.setLayout(layout)

        # Prevenir aceita√ß√£o autom√°tica
        modo_dialog.accepted.connect(lambda: None)

        def escolher_offline():
            modo_dialog.reject()
            self._modo_dialog_aberto = False
            self._ir_para_tela_pre_jogo(offline=True)

        def escolher_online():
            modo_dialog.reject()
            self._modo_dialog_aberto = False
            if self.usuario_logado:
                self._entrar_na_fila()
            else:
                # Abre o di√°logo de login e entra na fila ap√≥s sucesso
                self._abrir_dialogo_autenticacao_completo(
                    success_callback=lambda username: self._entrar_na_fila()
                )

        # Conectar bot√µes
        btn_offline.clicked.connect(escolher_offline)
        btn_online.clicked.connect(escolher_online)

        # Limpar flag se o di√°logo for fechado de outra forma (ex: ESC)
        modo_dialog.finished.connect(lambda: setattr(self, '_modo_dialog_aberto', False))

        modo_dialog.exec()

    def atualizar_logica(self):
        """Atualiza a l√≥gica do jogo e solicita redesenho do OpenGL."""
        if not self.loop_ativo:
            return  # Evita update() se o loop foi desativado

        try:
            if hasattr(self, 'opengl_widget') and self.opengl_widget:
                self.opengl_widget.update()
        except RuntimeError:
            # Widget foi deletado ‚Äî apenas pare o loop
            self.parar_loop()

    def parar_loop(self):
        """Para o loop de atualiza√ß√£o gr√°fica."""
        self.loop_ativo = False
        if self.timer:
            self.timer.stop()

    def reiniciar_loop(self):
        """Reinicia o loop de atualiza√ß√£o gr√°fica (√∫til ao voltar ao menu)."""
        if not self.loop_ativo:
            self.loop_ativo = True
            self.timer.start(18)

    def _verificar_login(self):
        """Verifica se o usu√°rio est√° logado (exemplo: arquivo session.txt existe)."""
        return os.path.exists("session.txt")

    def _criar_barra(self, tamanho, is_horizontal, object_name="Barra"):
        """Cria um widget para representar uma barra, com estilo b√°sico."""
        barra = QFrame()
        barra.setObjectName(object_name)
        if is_horizontal:
            barra.setFixedHeight(tamanho)
        else:
            barra.setFixedWidth(tamanho)
        barra.setStyleSheet(f"""
            #{object_name} {{
                background-color: #2c3e50;
                border: 1px solid #34495e;
            }}
        """)
        return barra

    def atualizar_logica(self):
        """
        Atualiza a l√≥gica do jogo e solicita redesenho do OpenGL.
        """
        self.opengl_widget.update()

    def _ao_clicar_icone_lateral(self, identificador):
        """Lida com os cliques nos √≠cones da barra lateral esquerda."""
        print(f"üñ±Ô∏è JanelaPrincipal recebeu clique no √≠cone: {identificador}")
        if identificador == "login":
            self.on_icone_login()
        elif identificador == "play":
            self.on_icone_play()
        elif identificador == "sair":
            self.on_icone_sair()

    def on_icone_login(self):
        """A√ß√£o acionada pelo √≠cone de login: abre tela de login ou logout."""
        if self.usuario_logado:
            # J√° logado ‚Üí oferece logout
            reply = QMessageBox.question(
                self,
                "Logout",
                "Voc√™ est√° logado. Deseja sair da conta?",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                QMessageBox.StandardButton.No
            )
            if reply == QMessageBox.StandardButton.Yes:
                try:
                    # ‚úÖ Remove sess√£o
                    if os.path.exists("session.txt"):
                        os.remove("session.txt")
                        print("üóëÔ∏è session.txt removed (logout).")
                    # ‚úÖ Atualiza estado
                    self.usuario_logado = False
                    self.gerenciador_icones.atualizar_estado_login(False)
                    # ‚úÖ Feedback opcional (pode ser removido para UX mais limpa)
                    # QMessageBox.information(self, "Logout", "Voc√™ saiu com sucesso.")
                except Exception as e:
                    QMessageBox.critical(self, "Erro", f"Falha ao remover sess√£o: {e}")
        else:
            # N√£o logado ‚Üí abre o di√°logo completo com login e registro
            dialog = DialogoAutenticacao(self)

            def on_login_sucesso(username: str):
                """Callback chamado ap√≥s login bem-sucedido."""
                self.usuario_logado = True
                self.gerenciador_icones.atualizar_estado_login(True, username)

            if dialog.exec() == QDialog.DialogCode.Accepted:
                # ‚úÖ O di√°logo j√° garante que o login foi bem-sucedido
                try:
                    with open("session.txt", "r") as f:
                        nome_usuario = f.read().strip()
                    # Atualiza UI com o nome do usu√°rio
                    self.usuario_logado = True
                    self.gerenciador_icones.atualizar_estado_login(True, nome_usuario)
                except Exception as e:
                    print(f"‚ùå Erro ao ler session.txt ap√≥s login: {e}")
                    # Mesmo com erro, o login foi feito ‚Äî usa fallback
                    self.gerenciador_icones.atualizar_estado_login(True, "Player")

    def on_icone_play(self):
        """Action triggered by the 'Play' icon: checks server state before acting."""
        print("üîµ [DEBUG] on_icone_play: In√≠cio da execu√ß√£o")
        print("Action: 'Play' icon clicked. Checking state...")

        # ‚úÖ Stop render loop before any UI changes
        self.parar_loop()
        print("‚è∏Ô∏è [DEBUG] on_icone_play: Render loop parado")

        try:
            # ‚úÖ 1. Verificar se o usu√°rio est√° logado
            username = self._ler_username()
            print(f"üîµ [DEBUG] on_icone_play: Username lido de session.txt: '{username}'")

            if not username:
                print("üü° [DEBUG] on_icone_play: Nenhum usu√°rio logado. Mostrando di√°logo de modos.")
                self._mostrar_dialogo_modos()
                return

            # ‚úÖ 2. CONSULTAR ESTADO ANTES DE LIMPAR
            print("üîµ [DEBUG] on_icone_play: Consultando estado do jogador no servidor...")
            try:
                response = requests.post(
                    "http://localhost:5000/jogo/estado",
                    json={"username": username},
                    timeout=3
                )
                print(f"üü¢ [DEBUG] on_icone_play: Resposta de /jogo/estado: {response.status_code} - {response.text}")

                if response.status_code == 200:
                    data = response.json()
                    print(f"üü¢ [DEBUG] on_icone_play: Estado recebido: {data}")

                    if data.get("em_partida"):
                        print("‚ö†Ô∏è Jogador j√° est√° em partida. Mostrando placeholder...")
                        self.mostrar_tela_jogo()
                        return
                    elif data.get("em_fila"):
                        print("‚ö†Ô∏è Jogador j√° est√° na fila. Reexibindo overlay...")
                        # Opcional: reconectar ao estado da fila
                        # self._reconectar_a_fila(data)
                        pass
                else:
                    print(f"üü° [DEBUG] on_icone_play: /jogo/estado retornou status {response.status_code}")
            except requests.exceptions.ConnectionError:
                print("üî¥ [DEBUG] on_icone_play: Falha de conex√£o com o servidor. Assumindo estado limpo.")
            except requests.exceptions.Timeout:
                print("üî¥ [DEBUG] on_icone_play: Tempo de resposta excedido. Assumindo estado limpo.")
            except requests.exceptions.RequestException as e:
                print(f"üî¥ [DEBUG] on_icone_play: Falha de rede ao consultar estado: {e}")
            except Exception as e:
                print(f"üî¥ [DEBUG] on_icone_play: Erro ao processar resposta de /jogo/estado: {e}")

            # ‚úÖ 3. SE LIVRE, LIMPAR ESTADO E CONTINUAR
            print("üîµ [DEBUG] on_icone_play: Limpando estado do usu√°rio no servidor...")
            try:
                response = requests.post(
                    "http://localhost:5000/jogo/limpar_usuario",
                    json={"username": username},
                    timeout=3
                )
                print(
                    f"üßπ Estado do usu√°rio '{username}' limpo no servidor. Resposta: {response.status_code} - {response.text}")
            except requests.exceptions.ConnectionError:
                print("üü† [DEBUG] on_icone_play: Servidor offline. Continuando sem limpeza.")
            except requests.exceptions.Timeout:
                print("üü† [DEBUG] on_icone_play: Timeout ao limpar estado. Continuando.")
            except Exception as e:
                print(f"‚ö†Ô∏è Falha ao limpar estado no servidor: {e}")

            # ‚úÖ 4. MOSTRAR DI√ÅLOGO DE MODOS
            print("üü¢ [DEBUG] on_icone_play: Mostrando di√°logo de escolha de modo (offline/online)")
            self._mostrar_dialogo_modos()

        except Exception as e:
            print(f"‚ùå Erro inesperado em on_icone_play: {e}")
            QMessageBox.critical(self, "Erro", f"Erro inesperado: {e}")
            self._mostrar_dialogo_modos()

        print("üü¢ [DEBUG] on_icone_play: Execu√ß√£o conclu√≠da")

    def _iniciar_offline(self, escolha, dialog):
        escolha[0] = "offline"
        dialog.accept()

    def _iniciar_online(self, escolha, dialog):
        escolha[0] = "online"
        dialog.accept()

        # Verifica login
        if not self.usuario_logado:
            print("Usu√°rio n√£o logado. Abrindo di√°logo de autentica√ß√£o...")
            self._abrir_dialogo_autenticacao_completo(success_callback=self._on_login_sucesso_pre_jogo)
        else:
            self._ir_para_tela_pre_jogo(offline=False)

    def _on_login_sucesso_pre_jogo(self, username: str):
        """Callback chamado ap√≥s login bem-sucedido no fluxo de 'play online'."""
        print(f"‚úÖ Login bem-sucedido. Iniciando pr√©-jogo online para {username}.")
        self._ir_para_tela_pre_jogo(offline=False)

    def _ir_para_tela_pre_jogo(self, offline: bool):
        if offline:
            self._mostrar_overlay_offline()  # ‚úÖ Mostra o overlay de configura√ß√£o
        else:
            self._entrar_na_fila()

    def on_icone_sair(self):
        """Action triggered by the 'Exit' icon: shows contextual dialog based on current state."""
        print("Action: 'Exit' icon clicked.")

        # ‚úÖ Stop render loop (safe to call always)
        self.parar_loop()

        username = self._ler_username()
        if not username:
            # Se n√£o est√° logado, fecha direto
            self.close()
            return

        # üî• Caso 1: Jogador est√° em partida ativa ‚Üí di√°logo avan√ßado
        if self.partida_iniciada:
            self._mostrar_dialogo_saida_partida(username)
            return

        # üîπ Caso 2: N√£o est√° em partida, mas est√° em sala de espera ‚Üí perguntar antes de sair
        if hasattr(self, 'overlay_sala') and self.overlay_sala is not None:
            reply = QMessageBox.question(
                self,
                "Sair da Sala de Espera",
                "Voc√™ est√° em uma sala de espera. Sair agora cancelar√° sua participa√ß√£o.\n\n"
                "Deseja realmente sair?",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                QMessageBox.StandardButton.No
            )
            if reply == QMessageBox.StandardButton.No:
                return  # Cancela o fechamento

        # ‚úÖ Limpar estado no servidor (em todos os casos)
        self._limpar_estado_servidor(username)

        # ‚úÖ Limpeza local
        self._limpeza_local()

        # ‚úÖ Fechar o programa
        self.close()

    def _limpar_estado_servidor(self, username: str):
        """Limpa o estado do jogador no servidor."""
        try:
            response = requests.post(
                "http://localhost:5000/jogo/limpar_usuario",
                json={"username": username},
                timeout=3
            )
            print(f"üßπ Estado do usu√°rio '{username}' limpo no servidor ao sair. {response.text}")
        except requests.exceptions.RequestException as e:
            print(f"‚ö†Ô∏è Falha ao limpar estado ao sair: {e}")

    def _limpeza_local(self):
        """Remove overlays, para timers, limpa o estado do OpenGL e restaura UI ao voltar ao menu."""
        print("üßπ [DEBUG] _limpeza_local: Iniciando limpeza completa...")

        # 1. Esconder overlay da sala de espera (se existir)
        try:
            if hasattr(self, 'overlay_sala') and self.overlay_sala is not None:
                print("üîµ [DEBUG] _limpeza_local: Escondendo overlay da sala de espera")
                self._esconder_overlay_sala_espera()
            else:
                print("üü° [DEBUG] _limpeza_local: overlay_sala j√° removido ou inexistente")
        except Exception as e:
            print(f"‚ö†Ô∏è Falha ao remover overlay da sala: {e}")

        # 2. Parar e limpar polling_timer
        try:
            if hasattr(self, 'polling_timer') and self.polling_timer:
                self.polling_timer.stop()
                self.polling_timer.deleteLater()
                self.polling_timer = None
                print("‚è∏Ô∏è Polling de status da sala interrompido.")
            else:
                print("üü° [DEBUG] _limpeza_local: polling_timer j√° parado ou inexistente")
        except Exception as e:
            print(f"‚ö†Ô∏è Falha ao parar polling: {e}")

        # 3. Limpar o mundo do OpenGLWidget (planeta, VAOs, VBOs)
        try:
            if hasattr(self, 'opengl_widget') and self.opengl_widget is not None:
                print("üßπ [DEBUG] _limpeza_local: Limpando mundo do OpenGLWidget")
                self.opengl_widget.limpar_mundo()  # Remove geometria, desativa modo jogo
            else:
                print("üü° [DEBUG] _limpeza_local: opengl_widget n√£o encontrado ou j√° destru√≠do")
        except Exception as e:
            print(f"‚ö†Ô∏è Falha ao limpar opengl_widget: {e}")

        # 4. Esconder overlay de a√ß√µes da partida (se existir)
        try:
            if hasattr(self, 'overlay_partida') and self.overlay_partida is not None:
                self.overlay_partida.hide()
                # ‚úÖ Resetar exibi√ß√£o do overlay
                if hasattr(self.overlay_partida, 'label_turno'):
                    self.overlay_partida.label_turno.setText("Turno: 0")
                if hasattr(self.overlay_partida, 'label_pop'):
                    self.overlay_partida.label_pop.setText("Pop: 0")
                print("‚úÖ [DEBUG] _limpeza_local: overlay_partida escondido e resetado.")
            else:
                print("üü° [DEBUG] _limpeza_local: overlay_partida j√° removido ou inexistente")
        except Exception as e:
            print(f"‚ö†Ô∏è Falha ao esconder overlay_partida: {e}")

        # 5. Restaurar overlay de boas-vindas (se n√£o estiver em modo jogo)
        try:
            if hasattr(self, 'overlay_widget') and self.overlay_widget is not None:
                # Mostrar apenas se N√ÉO estamos em uma partida
                if not (hasattr(self, 'partida_iniciada') and self.partida_iniciada):
                    self.overlay_widget.show()
                    self.overlay_widget.raise_()
                    print("‚úÖ [DEBUG] _limpeza_local: Overlay de boas-vindas restaurado")
                else:
                    print("üü° [DEBUG] _limpeza_local: Partida ainda ativa, n√£o restaura overlay")
            else:
                print("üü° [DEBUG] _limpeza_local: overlay_widget n√£o encontrado")
        except Exception as e:
            print(f"‚ö†Ô∏è Falha ao restaurar overlay de boas-vindas: {e}")

        # 6. Resetar estado de partida
        self.partida_iniciada = False
        self.mundo = None  # ‚úÖ Nova linha
        self.civ_jogador = None  # ‚úÖ Nova linha
        print("‚úÖ [DEBUG] _limpeza_local: Estado de partida resetado (partida_iniciada = False)")
        print("‚úÖ [DEBUG] _limpeza_local: Refer√™ncias ao mundo e jogador local limpas.")

        print("‚úÖ [DEBUG] _limpeza_local: Limpeza conclu√≠da com sucesso.")

    def _mostrar_dialogo_saida_partida(self, username: str):
        """Mostra di√°logo com Cancel, Main Menu, Quit quando em partida."""
        dialog = QDialog(self)
        dialog.setWindowTitle("Sair do Jogo")
        dialog.setModal(True)
        dialog.setFixedSize(320, 150)
        dialog.setStyleSheet("""
            QDialog { background-color: #2c3e50; font-family: Arial; }
            QLabel { color: #ecf0f1; font-size: 14px; }
            QPushButton {
                background-color: #3498db; color: white; border: none;
                padding: 8px 16px; border-radius: 6px; font-size: 13px;
                min-width: 90px;
            }
            QPushButton:hover { background-color: #2980b9; }
            QPushButton#quit { background-color: #e74c3c; }
            QPushButton#quit:hover { background-color: #c0392b; }
        """)

        layout = QVBoxLayout()
        label = QLabel("O que voc√™ gostaria de fazer?")
        label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        layout.addWidget(label)

        button_layout = QHBoxLayout()
        btn_cancel = QPushButton("Cancel")
        btn_menu = QPushButton("Main Menu")
        btn_quit = QPushButton("Quit")
        btn_quit.setObjectName("quit")

        button_layout.addWidget(btn_cancel)
        button_layout.addWidget(btn_menu)
        button_layout.addWidget(btn_quit)
        layout.addLayout(button_layout)
        dialog.setLayout(layout)

        # A√ß√µes
        btn_cancel.clicked.connect(dialog.reject)
        btn_menu.clicked.connect(lambda: self._sair_para_menu(dialog, username))
        btn_quit.clicked.connect(lambda: self._sair_do_jogo(dialog, username))

        dialog.exec()

    def _sair_para_menu(self, dialog, username: str):
        """Volta ao menu principal, limpa estado, mas n√£o fecha o jogo."""
        dialog.accept()

        self._limpar_estado_servidor(username)
        self._limpeza_local()

        self.partida_iniciada = False  # ‚úÖ Resetar flag

        # Restaurar overlay inicial
        if hasattr(self, 'overlay_widget') and self.overlay_widget:
            self.overlay_widget.show()
            self.overlay_widget.raise_()

        print("‚úÖ Retornou ao menu principal.")

    def _sair_do_jogo(self, dialog, username: str):
        """Fecha o aplicativo ap√≥s limpar estado."""
        dialog.accept()

        self._limpar_estado_servidor(username)
        self._limpeza_local()

        self.close()

    def _abrir_dialogo_autenticacao_completo(self, success_callback=None):
        """Abre o di√°logo completo de autentica√ß√£o (login + registro)."""
        dialog = DialogoAutenticacao(parent=self)

        def on_login_sucesso(username: str):
            with open("session.txt", "w") as f:
                f.write(username)
            self.usuario_logado = True
            self.gerenciador_icones.atualizar_estado_login(True, username)
            if success_callback:
                success_callback(username)
            dialog.accept()  # Fecha o di√°logo

        def tentar_login():
            username = dialog.username_login.text().strip()
            password = dialog.senha_login.text()
            if not username or not password:
                QMessageBox.warning(dialog, "Erro", "Usu√°rio e senha s√£o obrigat√≥rios.")
                return
            try:
                response = requests.post("http://localhost:5000/auth/login",
                                         json={"username": username, "password": password})
                data = response.json()
                if response.status_code == 200 and data.get("success"):
                    on_login_sucesso(username)
                else:
                    QMessageBox.critical(dialog, "Erro", data.get("message", "Login falhou."))
            except requests.exceptions.ConnectionError:
                QMessageBox.critical(dialog, "Erro", "N√£o foi poss√≠vel conectar ao servidor.")
            except Exception as e:
                QMessageBox.critical(dialog, "Erro", f"Erro: {str(e)}")

        def tentar_registro():
            username = dialog.username_registro.text().strip()
            password = dialog.senha_registro.text()
            confirmar = dialog.confirmar_senha.text()
            if not username or not password or not confirmar:
                QMessageBox.warning(dialog, "Erro", "Todos os campos s√£o obrigat√≥rios.")
                return
            if password != confirmar:
                QMessageBox.warning(dialog, "Erro", "As senhas n√£o coincidem.")
                return
            if len(password) < 6:
                QMessageBox.warning(dialog, "Erro", "A senha deve ter pelo menos 6 caracteres.")
                return
            try:
                response = requests.post("http://localhost:5000/auth/registrar",
                                         json={"username": username, "password": password})
                data = response.json()
                if response.status_code == 200 and data.get("success"):
                    QMessageBox.information(dialog, "Sucesso", "Conta criada com sucesso! Fa√ßa login.")
                    # Preenche o campo de login e muda para aba de login
                    dialog.username_login.setText(username)
                    dialog.abas.setCurrentIndex(0)
                else:
                    QMessageBox.critical(dialog, "Erro", data.get("message", "Falha no registro."))
            except requests.exceptions.ConnectionError:
                QMessageBox.critical(dialog, "Erro", "N√£o foi poss√≠vel conectar ao servidor.")
            except Exception as e:
                QMessageBox.critical(dialog, "Erro", f"Erro: {str(e)}")

        # üîÅ Conecta os bot√µes do QDialogButtonBox ao comportamento correto
        # Remover conex√£o anterior (se houver)
        try:
            dialog.buttons.accepted.disconnect()
        except TypeError:
            pass  # J√° desconectado

        # Conecta "OK" ao comportamento da aba atual
        dialog.buttons.accepted.connect(
            lambda: tentar_login() if dialog.abas.currentIndex() == 0 else tentar_registro()
        )

        # "Cancel" j√° chama reject() ‚Üí fecha o di√°logo
        dialog.exec()

    def _abrir_tela_login(self):
        """Abre um di√°logo de login com campos de usu√°rio e senha."""

        dialog = QDialog(self)
        dialog.setWindowTitle("Entrar")
        dialog.setModal(True)
        dialog.resize(300, 120)

        layout = QFormLayout()

        username_input = QLineEdit()
        password_input = QLineEdit()
        password_input.setEchoMode(QLineEdit.EchoMode.Password)

        layout.addRow("Usu√°rio:", username_input)
        layout.addRow("Senha:", password_input)

        buttons = QDialogButtonBox(QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel)
        layout.addRow(buttons)

        dialog.setLayout(layout)

        def tentar_login():
            username = username_input.text().strip()
            password = password_input.text()

            if not username or not password:
                QMessageBox.warning(dialog, "Erro", "Usu√°rio e senha s√£o obrigat√≥rios.")
                return

            # Enviar requisi√ß√£o ao backend Flask
            try:
                response = requests.post(
                    "http://localhost:5000/auth/login",
                    json={"username": username, "password": password}
                )
                data = response.json()

                if response.status_code == 200 and data.get("success"):
                    # Login bem-sucedido
                    with open("session.txt", "w") as f:
                        f.write(username)
                    self.usuario_logado = True
                    # Atualiza UI: √≠cone + nome
                    self.gerenciador_icones.atualizar_estado_login(True, username)
                    QMessageBox.information(dialog, "Sucesso", f"Bem-vindo, {username}!")
                    dialog.accept()
                else:
                    QMessageBox.critical(dialog, "Erro", data.get("message", "Login falhou."))
            except requests.exceptions.ConnectionError:
                QMessageBox.critical(dialog, "Erro", "N√£o foi poss√≠vel conectar ao servidor.")
            except Exception as e:
                QMessageBox.critical(dialog, "Erro", f"Erro inesperado: {e}")

        buttons.accepted.connect(tentar_login)
        buttons.rejected.connect(dialog.reject)

        dialog.exec()

    def _entrar_na_fila(self):
        """Tenta entrar na fila de matchmaking e mostra a tela de espera como overlay.
        Garante limpeza proativa de estado anterior (servidor e cliente).
        """
        print("üìû Chamando /jogo/entrar...")

        # ‚úÖ Evita m√∫ltiplas execu√ß√µes simult√¢neas
        if hasattr(self, 'entrando_na_fila') and self.entrando_na_fila:
            print("‚ö†Ô∏è J√° est√° entrando na fila. Opera√ß√£o ignorada.")
            return
        self.entrando_na_fila = True

        username = None
        try:
            # 1. Ler o username
            with open("session.txt", "r") as f:
                username = f.read().strip()
            if not username:
                raise FileNotFoundError("Arquivo de sess√£o vazio.")

            # 2. ‚úÖ Limpeza proativa no servidor: for√ßa sa√≠da e limpa estado
            try:
                requests.post(
                    "http://localhost:5000/jogo/limpar_usuario",
                    json={"username": username},
                    timeout=3
                )
                print(f"üßπ Estado do usu√°rio '{username}' limpo no servidor.")
            except Exception as e:
                print(f"‚ö†Ô∏è Falha ao limpar estado no servidor (servidor offline?): {e}")
                # Continua mesmo assim ‚Äî pode ser um teste local

            # 3. ‚úÖ Limpeza local: parar polling e remover overlays
            if hasattr(self, 'polling_timer') and self.polling_timer:
                self.polling_timer.stop()
                self.polling_timer.deleteLater()
                self.polling_timer = None

            # 4. ‚úÖ For√ßar remo√ß√£o do overlay existente
            if hasattr(self, 'overlay_sala') and self.overlay_sala is not None:
                self._esconder_overlay_sala_espera()
            self.overlay_sala = None  # Garante que ser√° recriado

            # 5. ‚úÖ Entrar na fila
            response = requests.post(
                "http://localhost:5000/jogo/entrar",
                json={"modo": "online", "username": username},
                timeout=5
            )
            data = response.json()

            if data.get("success"):
                max_jogadores = data.get("max_jogadores")

                # 6. ‚úÖ Mostrar overlay da sala de espera
                self._mostrar_overlay_sala_espera(username, max_jogadores)

                # 7. ‚úÖ Iniciar polling para atualizar status
                self._iniciar_polling_sala()

                print(f"‚úÖ {username} entrou na fila. Overlay exibido.")
            else:
                QMessageBox.critical(self, "Erro", data.get("message", "Falha ao entrar na fila."))

        except FileNotFoundError:
            QMessageBox.critical(self, "Erro", "Voc√™ n√£o est√° logado.")
        except requests.exceptions.ConnectionError:
            QMessageBox.critical(self, "Erro", "N√£o foi poss√≠vel conectar ao servidor.")
        except requests.exceptions.Timeout:
            QMessageBox.critical(self, "Erro", "Tempo de resposta excedido.")
        except Exception as e:
            QMessageBox.critical(self, "Erro", f"Erro inesperado: {e}")
            print(f"‚ùå Erro em _entrar_na_fila: {e}")
        finally:
            self.entrando_na_fila = False

    def on_partida_iniciada(self):
        """Chamado quando a partida come√ßa (online ou offline).
        Realiza limpeza de UI, para polling, mostra overlay de a√ß√µes
        e marca o estado de partida ativa.
        A cria√ß√£o do mundo e ativa√ß√£o do OpenGL devem ser feitas antes.
        """
        print("üîµ [DEBUG] on_partida_iniciada: In√≠cio da execu√ß√£o")

        # ‚úÖ Evitar duplica√ß√£o
        if hasattr(self, 'partida_iniciada') and self.partida_iniciada:
            print("üü° [DEBUG] on_partida_iniciada: J√° foi chamado. Ignorando.")
            return
        self.partida_iniciada = True
        print("üü¢ [DEBUG] on_partida_iniciada: Flag 'partida_iniciada' definido como True")

        print("üéÆ Partida iniciada: removendo overlays, status e parando polling...")

        # 1. Remover widget de status da barra lateral
        try:
            if hasattr(self, 'gerenciador_icones') and self.gerenciador_icones:
                print("üîµ [DEBUG] on_partida_iniciada: Removendo widget de status da barra lateral")
                self.gerenciador_icones.remover_status_sala()
                print("üóëÔ∏è Widget de status da sala removido.")
            else:
                print("üü° [DEBUG] on_partida_iniciada: gerenciador_icones n√£o encontrado")
        except Exception as e:
            print(f"‚ö†Ô∏è Falha ao remover status da sala: {e}")

        # 2. Esconder overlay da sala de espera
        try:
            if hasattr(self, 'overlay_sala') and self.overlay_sala is not None:
                print("üîµ [DEBUG] on_partida_iniciada: Removendo overlay da sala de espera")
                if hasattr(self.overlay_sala, 'fade_out'):
                    self.overlay_sala.fade_out()
                    from PyQt6.QtCore import QTimer
                    QTimer.singleShot(300, self._esconder_overlay_sala_espera)
                else:
                    self._esconder_overlay_sala_espera()
            else:
                print("üü° [DEBUG] on_partida_iniciada: overlay_sala n√£o encontrado")
        except Exception as e:
            print(f"‚ö†Ô∏è Falha ao esconder overlay da sala: {e}")

        # 3. Parar polling
        try:
            if hasattr(self, 'polling_timer') and self.polling_timer:
                self.polling_timer.stop()
                self.polling_timer.deleteLater()
                self.polling_timer = None
                print("‚è∏Ô∏è Polling de status da sala interrompido.")
            else:
                print("üü° [DEBUG] on_partida_iniciada: polling_timer j√° parado")
        except Exception as e:
            print(f"‚ö†Ô∏è Falha ao parar polling: {e}")

        # 4. Ativar modo de jogo no OpenGLWidget
        try:
            if hasattr(self, 'opengl_widget') and self.opengl_widget:
                self.opengl_widget.ativar_modo_jogo()
                self.opengl_widget.update()
                print("üîµ [DEBUG] OpenGLWidget ativado e atualizado.")
            else:
                print("‚ö†Ô∏è [WARN] opengl_widget n√£o encontrado ao ativar modo de jogo.")
        except Exception as e:
            print(f"‚ö†Ô∏è Falha ao ativar OpenGLWidget: {e}")

        # 5. ‚úÖ CRIAR/MOSTRAR OVERLAY DE A√á√ïES NA BARRA ESQUERDA
        try:
            from client.widgets.match_overlay import OverlayPartida
            if not hasattr(self, 'overlay_partida'):
                self.overlay_partida = OverlayPartida(parent=self.barra_esquerda)
                self.overlay_partida.hide()
                print("üü¢ [DEBUG] OverlayPartida criado e anexado √† barra_esquerda.")
            else:
                self.overlay_partida.update_position()

            self.overlay_partida.show()
            self.overlay_partida.raise_()
            print("‚úÖ Overlay de a√ß√µes de partida exibido e elevado na barra esquerda.")

            # üîó Conectar o mundo ao overlay
            self.overlay_partida.conectar_mundo(self.mundo)
            print("üîó OverlayPartida conectado ao mundo.")

            # ‚úÖ Conectar resizeEvent para ajuste autom√°tico
            if not hasattr(self.barra_esquerda, '_original_resize'):
                self.barra_esquerda._original_resize = self.barra_esquerda.resizeEvent

                def _new_resize(event):
                    self.barra_esquerda._original_resize(event)
                    if hasattr(self, 'overlay_partida'):
                        self.overlay_partida.update_position()

                self.barra_esquerda.resizeEvent = _new_resize

        except ImportError as e:
            print(f"‚ùå Falha ao importar OverlayPartida: {e}")
            print(
                "üí° Verifique se o arquivo 'client/widgets/match_overlay.py' existe e cont√©m a classe 'OverlayPartida'.")
        except Exception as e:
            print(f"‚ùå Falha ao criar ou exibir OverlayPartida: {e}")
            import traceback
            traceback.print_exc()

        # 6. Finaliza√ß√£o
        print("‚úÖ Transi√ß√£o para partida iniciada com sucesso.")
        print("üü¢ [DEBUG] on_partida_iniciada: Execu√ß√£o conclu√≠da")

    def mudar_modo_mapa(self, modo: str):
        """
        Recebe o comando do OverlayPartida e repassa ao OpenGLWidget.
        Este m√©todo precisa estar aqui porque o OverlayPartida usa 'parent_widget' como refer√™ncia.
        """
        print(f"üîÅ [DEBUG] JanelaPrincipal.mudar_modo_mapa chamado com modo='{modo}'")

        if hasattr(self, 'opengl_widget') and self.opengl_widget:
            if modo in ["fisico", "politico"]:
                self.opengl_widget.mudar_modo_mapa(modo)
            else:
                print(f"‚ùå Modo desconhecido: {modo}")
        else:
            print("‚ùå [ERRO] opengl_widget n√£o dispon√≠vel em JanelaPrincipal")

    def _mostrar_overlay_sala_espera(self, username: str, max_jogadores: int):
        """
        Mostra o overlay da sala de espera como sobreposi√ß√£o flutuante sobre o OpenGL,
        substituindo o 'Welcome to Global Arena', sem afetar o layout do OpenGL.
        """
        print("üîµ [DEBUG] _mostrar_overlay_sala_espera: In√≠cio da execu√ß√£o")
        print(
            f"üü¢ [DEBUG] _mostrar_overlay_sala_espera: Tentando mostrar overlay para {username} | max_jogadores: {max_jogadores}")

        # 1. Se j√° existe um overlay da sala, remova-o corretamente
        if self.overlay_sala is not None:
            print(
                "üü° [DEBUG] _mostrar_overlay_sala_espera: overlay_sala j√° existe. Chamando _esconder_overlay_sala_espera()")
            self._esconder_overlay_sala_espera()
        else:
            print("üü¢ [DEBUG] _mostrar_overlay_sala_espera: Nenhum overlay existente. Continuando...")

        # 2. Esconder o overlay de boas-vindas
        if self.overlay_widget:
            self.overlay_widget.hide()
            print("üé® [DEBUG] _mostrar_overlay_sala_espera: overlay_widget (boas-vindas) escondido")
        else:
            print("üü° [DEBUG] _mostrar_overlay_sala_espera: overlay_widget n√£o encontrado")

        # 3. Criar o novo overlay da sala de espera
        try:
            print("üîµ [DEBUG] _mostrar_overlay_sala_espera: Criando nova inst√¢ncia de WaitingRoomOverlay")
            self.overlay_sala = WaitingRoomOverlay(username, max_jogadores, parent=self.opengl_container)
            print("üü¢ [DEBUG] _mostrar_overlay_sala_espera: WaitingRoomOverlay criado com sucesso")
        except Exception as e:
            print(f"‚ùå Falha ao criar WaitingRoomOverlay: {e}")
            if self.overlay_widget:
                self.overlay_widget.show()  # Restaura se falhar
            return

        # 4. Adicionar como widget filho direto (sem usar layout) ‚Üí evita interfer√™ncia no OpenGL
        self.overlay_sala.setParent(self.opengl_container)
        print("üîµ [DEBUG] _mostrar_overlay_sala_espera: overlay_sala definido como filho de opengl_container")

        self.overlay_sala.hide()  # Inicialmente oculto para ajustar posi√ß√£o primeiro
        print("üü° [DEBUG] _mostrar_overlay_sala_espera: overlay_sala inicialmente oculto para ajuste de posi√ß√£o")

        # 5. Ajustar posi√ß√£o e tamanho com base no container (ser√° refinado ap√≥s renderiza√ß√£o)
        print("üîµ [DEBUG] _mostrar_overlay_sala_espera: Ajustando posi√ß√£o inicial do overlay")
        self._ajustar_overlay_sala()

        # 6. Exibir o overlay
        self.overlay_sala.show()
        self.overlay_sala.raise_()  # Garante que fique na frente
        print("üü¢ [DEBUG] _mostrar_overlay_sala_espera: overlay_sala exibido e trazido para frente (raise_)")

        # 7. Conectar o bot√£o Cancelar com a l√≥gica de sa√≠da
        def on_cancel():
            print(f"üîµ [DEBUG] on_cancel: {username} clicou em Cancelar")
            try:
                import requests
                response = requests.post(
                    "http://localhost:5000/jogo/sair",
                    json={"username": username},
                    timeout=3
                )
                print(f"üì§ {username} saiu da fila via cancelamento. Resposta: {response.status_code}")
            except Exception as e:
                print(f"‚ùå Falha ao sair da fila: {e}")
            finally:
                # Sempre esconder o overlay ap√≥s tentar sair
                print("üîµ [DEBUG] on_cancel: Chamando _esconder_overlay_sala_espera()")
                self._esconder_overlay_sala_espera()

        # Conectar o callback ao bot√£o Cancelar
        self.overlay_sala.connect_cancel(on_cancel)
        print("üü¢ [DEBUG] _mostrar_overlay_sala_espera: Callback de cancelamento conectado")

        # 8. üëâ Garantir posicionamento p√≥s-renderiza√ß√£o (evita geometria 0x0)
        from PyQt6.QtCore import QTimer
        QTimer.singleShot(30, self._ajustar_overlay_sala)
        print("üîµ [DEBUG] _mostrar_overlay_sala_espera: QTimer.singleShot(30) agendado para _ajustar_overlay_sala")

        QTimer.singleShot(60, lambda: self.overlay_sala.raise_() if self.overlay_sala else None)
        print("üîµ [DEBUG] _mostrar_overlay_sala_espera: QTimer.singleShot(60) agendado para garantir raise_()")

        print("üü¢ [DEBUG] _mostrar_overlay_sala_espera: Execu√ß√£o conclu√≠da")

    def _esconder_overlay_sala_espera(self):
        """Esconde o overlay da sala de espera e restaura o estado inicial."""
        print("üîµ [DEBUG] _esconder_overlay_sala_espera: In√≠cio da execu√ß√£o")

        # 1. Parar polling
        if hasattr(self, 'polling_timer') and self.polling_timer:
            self.polling_timer.stop()
            self.polling_timer = None
            print("üü° [DEBUG] _esconder_overlay_sala_espera: polling_timer j√° parado ou inexistente")

        # 2. Remover overlay da sala
        if hasattr(self, 'overlay_sala') and self.overlay_sala:
            self.overlay_sala.setParent(None)
            self.overlay_sala.deleteLater()
            self.overlay_sala = None
            print("üé® [DEBUG] _esconder_overlay_sala_espera: overlay_sala j√° removido ou inexistente")

        # 3. ‚úÖ Mostrar overlay_widget (boas-vindas) s√≥ se N√ÉO estiver em modo jogo
        if hasattr(self, 'opengl_widget') and not self.opengl_widget.modulo_jogo:
            if hasattr(self, 'overlay_widget') and self.overlay_widget:
                self.overlay_widget.show()
                self.overlay_widget.raise_()
                print("üé® [DEBUG] _esconder_overlay_sala_espera: overlay_widget (boas-vindas) restaurado")
        else:
            # ‚úÖ Se estiver em modo jogo, N√ÉO mostre o overlay de boas-vindas
            if hasattr(self, 'overlay_widget') and self.overlay_widget:
                self.overlay_widget.hide()
                print("üé® [DEBUG] _esconder_overlay_sala_espera: overlay_widget escondido (modo jogo ativo)")

        print("üü¢ [DEBUG] _esconder_overlay_sala_espera: Execu√ß√£o conclu√≠da")

    def _ajustar_overlay_sala(self):
        """Ajusta posi√ß√£o e tamanho do overlay da sala de espera, garantindo centraliza√ß√£o e responsividade.
        Protegido contra chamadas prematuras (ex: geometria 0x0)."""
        if not self.overlay_sala or not self.opengl_container:
            return

        container_rect = self.opengl_container.rect()

        # ‚úÖ Prote√ß√£o contra chamadas prematuras (tamanho inv√°lido)
        if container_rect.width() < 10 or container_rect.height() < 10:
            print("‚ö†Ô∏è _ajustar_overlay_sala adiado: container ainda n√£o tem dimens√µes v√°lidas.")
            from PyQt6.QtCore import QTimer
            QTimer.singleShot(20, self._ajustar_overlay_sala)  # Tenta novamente em breve
            return

        # ‚úÖ Calcular dimens√µes responsivas
        max_width = 500
        min_width = 300
        padding_horizontal = 60
        target_width = min(max_width, container_rect.width() - padding_horizontal)
        width = max(min_width, target_width)  # Garante largura m√≠nima

        height = 300  # Altura fixa suficiente para o conte√∫do

        # ‚úÖ Centralizar
        x = (container_rect.width() - width) // 2
        y = (container_rect.height() - height) // 2

        # ‚úÖ Aplicar geometria
        self.overlay_sala.setGeometry(x, y, width, height)
        self.overlay_sala.raise_()  # Garante que fique na frente

        print(f"üé® Overlay ajustado: ({x}, {y}, {width}x{height}) dentro de {container_rect.size()}")

    def _iniciar_polling_sala(self):
        """Inicia o polling para atualizar o status da sala de espera a cada 1 segundo."""
        from PyQt6.QtCore import QTimer

        print("üîµ [DEBUG] _iniciar_polling_sala: Iniciando ou reiniciando polling")

        # 1. Parar qualquer timer anterior
        if hasattr(self, 'polling_timer') and self.polling_timer:
            print("‚è∏Ô∏è [DEBUG] _iniciar_polling_sala: Parando polling_timer existente")
            self.polling_timer.stop()
            self.polling_timer.deleteLater()
            self.polling_timer = None

        # 2. Criar novo timer
        self.polling_timer = QTimer(self)

        # 3. Conectar ao novo m√©todo de atualiza√ß√£o
        self.polling_timer.timeout.connect(self._atualizar_status_sala)

        # 4. Iniciar polling
        self.polling_timer.start(1000)  # A cada 1 segundo
        print("üü¢ [DEBUG] _iniciar_polling_sala: polling_timer iniciado (1s)")

        # 5. Atualiza√ß√£o imediata
        self._atualizar_status_sala()
        print("üü¢ [DEBUG] _iniciar_polling_sala: Primeira atualiza√ß√£o de status disparada")

    def _atualizar_status_sala(self):
        """Atualiza o status da sala com base na sala do jogador."""
        try:
            username = self._ler_username()
            if not username:
                print("üü° [DEBUG] _atualizar_status_sala: Nenhum usu√°rio logado. Ignorando.")
                return

            print(f"üîµ [DEBUG] _atualizar_status_sala: Consultando /jogo/minha_sala para {username}")
            response = requests.post(
                "http://localhost:5000/jogo/minha_sala",
                json={"username": username},
                timeout=3
            )
            if response.status_code == 200:
                data = response.json()
                print(f"üü¢ [DEBUG] _atualizar_status_sala: Estado recebido: {data}")

                if data.get("em_fila"):
                    jogadores = data["jogadores_na_sala"]
                    vagas = data["vagas"]
                    esta_cheia = data["esta_cheia"]

                    # Atualiza o overlay da sala de espera
                    if hasattr(self, 'overlay_sala') and self.overlay_sala is not None:
                        print(f"üé® [DEBUG] _atualizar_status_sala: Atualizando overlay para {len(jogadores)}/{vagas}")
                        self.overlay_sala.atualizar_status(len(jogadores), vagas)
                    else:
                        print("üü° [DEBUG] _atualizar_status_sala: overlay_sala n√£o encontrado")

                    # Se a sala encheu, inicia a partida
                    if esta_cheia:
                        print(
                            f"‚úÖ [DEBUG] _atualizar_status_sala: Sala cheia detectada ({len(jogadores)}/{vagas}). Iniciando partida.")
                        self._esconder_overlay_sala_espera()
                        if hasattr(self, 'polling_timer') and self.polling_timer:
                            self.polling_timer.stop()
                            self.polling_timer.deleteLater()
                            self.polling_timer = None
                            print("‚è∏Ô∏è [DEBUG] _atualizar_status_sala: polling_timer parado")
                        self.on_partida_iniciada()
                else:
                    # Jogador n√£o est√° mais na fila
                    print("üü° [DEBUG] _atualizar_status_sala: Jogador n√£o est√° na fila. Escondendo overlay.")
                    self._esconder_overlay_sala_espera()
            else:
                print(f"üî¥ [DEBUG] _atualizar_status_sala: /jogo/minha_sala retornou status {response.status_code}")

        except requests.exceptions.ConnectionError:
            print("üî¥ [DEBUG] _atualizar_status_sala: Falha de conex√£o com o servidor.")
        except requests.exceptions.Timeout:
            print("üî¥ [DEBUG] _atualizar_status_sala: Tempo de resposta excedido.")
        except requests.exceptions.RequestException as e:
            print(f"üî¥ [DEBUG] _atualizar_status_sala: Erro de rede: {e}")
        except Exception as e:
            print(f"‚ùå Erro inesperado em _atualizar_status_sala: {e}")

    def sair_da_partida(self):
        """Sai da partida e volta para o menu principal."""
        if self.game_placeholder:
            self.game_placeholder.setParent(None)
            self.game_placeholder.deleteLater()
            self.game_placeholder = None

        # Restaurar overlay de boas-vindas
        if self.overlay_widget:
            self.overlay_widget.show()
            self.overlay_widget.raise_()

        print("‚úÖ Retornou ao menu principal.")

    def _ler_username(self) -> str:
        """L√™ o username do arquivo session.txt. Retorna string vazia se n√£o encontrado."""
        try:
            with open("session.txt", "r", encoding="utf-8") as f:
                username = f.read().strip()
            if username:
                return username
            else:
                print("‚ö†Ô∏è Arquivo session.txt encontrado, mas vazio.")
                return ""
        except FileNotFoundError:
            print("‚ö†Ô∏è Arquivo session.txt n√£o encontrado.")
            return ""
        except Exception as e:
            print(f"‚ùå Erro ao ler session.txt: {e}")
            return ""

    def resizeEvent(self, event):
        super().resizeEvent(event)

        # Ajustar overlay de boas-vindas
        if hasattr(self, 'overlay_widget') and self.overlay_widget:
            self.overlay_widget.setGeometry(self.opengl_container.rect())
            self.overlay_widget.raise_()

        # Ajustar overlay da sala de espera (se existir)
        if hasattr(self, 'overlay_sala') and self.overlay_sala:
            self._ajustar_overlay_sala()  # Este m√©todo j√° existe
            self.overlay_sala.raise_()

        # Ajustar barra direita (se for flutuante)
        if hasattr(self, 'barra_direita') and self.barra_direita.parent() == self.opengl_container:
            w = self.barra_direita.width()
            h = self.opengl_container.height()
            self.barra_direita.setGeometry(self.opengl_container.width() - w, 0, w, h)
            self.barra_direita.raise_()

        # For√ßar atualiza√ß√£o do OpenGL
        if hasattr(self, 'opengl_widget'):
            self.opengl_widget.update()

    def _mostrar_overlay_offline(self):
        """Mostra o overlay de configura√ß√£o offline sobre o OpenGL."""
        print("üîµ [DEBUG] _mostrar_overlay_offline: Exibindo overlay de configura√ß√£o offline")

        # ‚úÖ Esconder overlay de boas-vindas ANTES de mostrar o offline
        if hasattr(self, 'overlay_widget') and self.overlay_widget:
            self.overlay_widget.hide()

        # Criar ou reutilizar overlay
        if not hasattr(self, 'offline_overlay'):
            self.offline_overlay = OfflineSetupOverlay(parent=self.opengl_container)
            self.offline_overlay.setParent(self.opengl_container)

            # üî• CONECTAR O SINAL AQUI, logo ap√≥s a cria√ß√£o
            self.offline_overlay.on_start.connect(self.on_offline_setup_confirmed)
            print("‚úÖ [DEBUG] Sinal 'on_start' conectado a 'on_offline_setup_confirmed'")
        else:
            self.offline_overlay.show()

        self.offline_overlay.raise_()
        self.offline_overlay.show()

    def on_offline_setup_confirmed(self, fator, bioma):
        """Configura√ß√£o confirmada. Inicia a partida offline."""
        print(f"üü¢ [DEBUG] on_offline_setup_confirmed: Iniciando partida offline | fator={fator}, bioma='{bioma}'")
        # ‚ùå REMOVA: self.on_partida_iniciada()
        # ‚úÖ APENAS inicia a partida
        self._iniciar_partida("offline", fator=fator, bioma=bioma)

    def on_offline_setup_canceled(self):
        """Chamado ao cancelar. Restaura o overlay de boas-vindas."""
        print("üü° [DEBUG] Modo offline cancelado. Restaurando overlay de boas-vindas.")

        # Esconder o overlay offline
        if hasattr(self, 'offline_overlay') and self.offline_overlay:
            self.offline_overlay.hide()

        # Mostrar e trazer para frente o overlay de boas-vindas
        if hasattr(self, 'overlay_widget') and self.overlay_widget:
            self.overlay_widget.show()
            self.overlay_widget.raise_()

        # Opcional: for√ßar update do OpenGL (para garantir render)
        if hasattr(self, 'opengl_widget'):
            self.opengl_widget.update()


# --- Ponto de Entrada da Aplica√ß√£o ---
def main():
    print("üéÆ Inicializando cliente gr√°fico com PyQt6...")

    # Configurar o formato OpenGL padr√£o globalmente
    fmt = QSurfaceFormat()
    fmt.setVersion(3, 3)
    fmt.setProfile(QSurfaceFormat.OpenGLContextProfile.CoreProfile)
    fmt.setDepthBufferSize(24)  # ‚úÖ Ativado: necess√°rio para 3D
    fmt.setStencilBufferSize(8)  # ‚úÖ Adicionado: √∫til para efeitos futuros
    fmt.setSamples(4)  # ‚úÖ Ativado: 4x MSAA para suaviza√ß√£o
    fmt.setSwapBehavior(QSurfaceFormat.SwapBehavior.DoubleBuffer)
    fmt.setAlphaBufferSize(8)
    fmt.setRedBufferSize(8)
    fmt.setGreenBufferSize(8)
    fmt.setBlueBufferSize(8)

    QSurfaceFormat.setDefaultFormat(fmt)

    app = QApplication(sys.argv)

    try:
        janela = JanelaPrincipal()
        janela.show()  # Garante que a janela ser√° exibida
        print("‚úÖ Janela principal exibida.")
        sys.exit(app.exec())
    except Exception as e:
        print(f"‚ùå Erro ao criar/iniciar a janela: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)


if __name__ == "__main__":
    # üî• Ativar suporte a alto DPI ANTES de criar QApplication
    from PyQt6.QtWidgets import QApplication
    from PyQt6.QtCore import Qt
    QApplication.setAttribute(Qt.AA_EnableHighDpiScaling)
    QApplication.setAttribute(Qt.AA_UseHighDpiPixmaps)

    # (Opcional) Para testar o √≠cone de login logado
    # with open("session.txt", "w") as f:
    #     f.write("usuario_teste_logado")

    main()  # Chama a fun√ß√£o principal

================================================================================
üìÑ client/widgets/match_overlay.py
================================================================================
# client/widgets/match_overlay.py
from PyQt6.QtWidgets import (
    QWidget, QVBoxLayout, QLabel, QPushButton, QHBoxLayout
)
from PyQt6.QtCore import Qt
from client.utils.scaling import scale, scale_font  # Importa as fun√ß√µes de escala


class OverlayPartida(QWidget):
    """
    Overlay flutuante dentro da barra esquerda, exibido apenas durante a partida.
    Cont√©m:
    - Bot√£o para avan√ßar o turno
    - Exibi√ß√£o de turno e popula√ß√£o
    - Bot√£o para alternar modo de mapa (f√≠sico/pol√≠tico)
    """

    def __init__(self, parent=None):
        super().__init__(parent)
        self.parent_widget = parent  # Refer√™ncia ao widget pai (barra_esquerda)
        self.setAttribute(Qt.WidgetAttribute.WA_TranslucentBackground)
        self.setStyleSheet("""
            background-color: rgba(40, 40, 55, 220);
            border-radius: 12px;
            border: 1px solid #3498db;
            color: #ecf0f1;
            font-family: Arial, sans-serif;
            font-size: 13px;
        """)
        self.setup_ui()
        self.update_position()

    def setup_ui(self):
        """Configura a interface com bot√µes e labels."""
        layout = QVBoxLayout(self)
        layout.setContentsMargins(scale(15), scale(15), scale(15), scale(15))
        layout.setSpacing(scale(12))
        layout.setAlignment(Qt.AlignmentFlag.AlignTop)

        # --- T√≠tulo ---
        titulo = QLabel("üïπÔ∏è A√ß√µes da Partida")
        titulo.setStyleSheet("font-size: 16px; font-weight: bold; color: #ffffff;")
        titulo.setAlignment(Qt.AlignmentFlag.AlignCenter)
        layout.addWidget(titulo)

        # --- Display de Turno ---
        self.label_turno = QLabel("Turno: 0")
        self.label_turno.setStyleSheet("font-size: 14px; color: #cccccc; font-weight: bold;")
        self.label_turno.setAlignment(Qt.AlignmentFlag.AlignCenter)
        layout.addWidget(self.label_turno)

        # --- Display de Popula√ß√£o ---
        self.label_pop = QLabel("Popula√ß√£o: 0")
        self.label_pop.setStyleSheet("font-size: 13px; color: #aaaaaa;")
        self.label_pop.setAlignment(Qt.AlignmentFlag.AlignCenter)
        layout.addWidget(self.label_pop)

        # --- Bot√£o de Avan√ßar Turno ---
        self.botao_turno = QPushButton("‚è≠Ô∏è Avan√ßar Turno")
        self.botao_turno.setStyleSheet(self._estilo_botao("#4CAF50", "#45a049", "#3d8b40"))
        self.botao_turno.clicked.connect(self.on_avancar_turno)
        layout.addWidget(self.botao_turno)

        # --- Bot√£o de Modo de Mapa ---
        self.btn_modo_mapa = QPushButton("üåç")  # Come√ßa no modo f√≠sico
        self.btn_modo_mapa.setFixedSize(scale(60), scale(40))
        self.btn_modo_mapa.setToolTip("Alternar modo de mapa (F√≠sico/Pol√≠tico)")
        self.btn_modo_mapa.setStyleSheet(self._estilo_botao("#2c3e50", "#34495e", "#1abc9c"))
        self.btn_modo_mapa.clicked.connect(self.alternar_modo_mapa)
        layout.addWidget(self.btn_modo_mapa, alignment=Qt.AlignmentFlag.AlignCenter)

        self.setLayout(layout)

    def _estilo_botao(self, bg, hover, pressed):
        """Retorna string de estilo para bot√µes com cores personalizadas."""
        return f"""
            QPushButton {{
                background-color: {bg};
                color: white;
                border: 1px solid #3498db;
                border-radius: {scale(8)}px;
                padding: {scale(8)}px;
                font-size: {scale_font(13)}px;
                font-weight: bold;
            }}
            QPushButton:hover {{
                background-color: {hover};
                border-color: #1abc9c;
            }}
            QPushButton:pressed {{
                background-color: {pressed};
            }}
        """

    def on_avancar_turno(self):
        """Avan√ßa o turno no mundo atual."""
        print("üü¢ [OverlayPartida] Bot√£o 'Avan√ßar Turno' clicado.")

        # Buscar JanelaPrincipal subindo na hierarquia
        janela_principal = self._obter_janela_principal()
        if not janela_principal:
            print("‚ùå [OverlayPartida] JanelaPrincipal n√£o encontrada.")
            return

        if not hasattr(janela_principal, 'mundo') or not janela_principal.mundo:
            print("‚ö†Ô∏è [OverlayPartida] Mundo n√£o dispon√≠vel.")
            return

        mundo = janela_principal.mundo

        # Avan√ßa o turno
        try:
            mundo.turno.avancar(mundo)
            self.atualizar_display(mundo)
            print(f"‚úÖ Turno {mundo.turno.numero} avan√ßado com sucesso.")
        except Exception as e:
            print(f"‚ùå Erro ao avan√ßar turno: {e}")

    def atualizar_display(self, mundo):
        """Atualiza os labels de turno e popula√ß√£o."""
        self.label_turno.setText(f"Turno: {mundo.turno.numero}")
        h, m, t = mundo.get_populacao_global()
        pop_formatada = self._formatar_numero(t)
        homens_formatado = self._formatar_numero(h)
        mulheres_formatado = self._formatar_numero(m)
        self.label_pop.setText(f"Pop: {pop_formatada} (H={homens_formatado}, M={mulheres_formatado})")

    def conectar_mundo(self, mundo):
        """Conecta o overlay a um mundo e atualiza o display inicial."""
        self.atualizar_display(mundo)

    def alternar_modo_mapa(self):
        """Alterna entre modo f√≠sico e pol√≠tico e atualiza o √≠cone do bot√£o."""
        novo_modo = "politico" if self.btn_modo_mapa.text() == "üåç" else "fisico"
        novo_icone = "üèõÔ∏è" if novo_modo == "politico" else "üåç"

        self.btn_modo_mapa.setText(novo_icone)
        self.btn_modo_mapa.setToolTip(f"Modo: {'Pol√≠tico' if novo_modo == 'politico' else 'F√≠sico'}")
        print(f"üîÑ Modo de mapa alterado para: {novo_modo}")

        # === NAVEGAR PELA HIERARQUIA AT√â A JANELA PRINCIPAL ===
        widget_atual = self.parent_widget
        while widget_atual is not None:
            if hasattr(widget_atual, 'mudar_modo_mapa'):
                widget_atual.mudar_modo_mapa(novo_modo)
                return
            widget_atual = widget_atual.parent()

        print("‚ö†Ô∏è OverlayPartida: 'mudar_modo_mapa' n√£o encontrado em nenhum ancestral.")

    def update_position(self):
        """Atualiza posi√ß√£o e tamanho com base no widget pai (barra_esquerda)."""
        if not self.parent():
            return

        parent_rect = self.parent().rect()
        parent_width = parent_rect.width()
        parent_height = parent_rect.height()

        # Largura: 85% da barra
        width = int(parent_width * 0.85)

        # Altura: at√© 50% da altura da barra, com limites
        max_height = scale(300)
        min_height = scale(120)
        height = min(max_height, int(parent_height * 0.5))
        height = max(min_height, height)

        # Centralizar verticalmente
        x = (parent_width - width) // 2
        y = (parent_height - height) // 2

        self.setGeometry(x, y, width, height)
        self.setFixedWidth(width)
        self.setFixedHeight(height)

    def _obter_janela_principal(self):
        """Obt√©m a inst√¢ncia de JanelaPrincipal subindo na hierarquia."""
        widget_atual = self.parent_widget
        while widget_atual is not None:
            if hasattr(widget_atual, 'mudar_modo_mapa'):  # Assumindo que √© √∫nico da JanelaPrincipal
                return widget_atual
            widget_atual = widget_atual.parent()
        return None

    def _formatar_numero(self, valor: int) -> str:
        """
        Formata n√∫mero grande com sufixos: K (mil), M (milh√£o), B (bilh√£o), T (trilh√£o)
        Ex: 1500 ‚Üí "1.5k", 2300000 ‚Üí "2.3m"
        """
        if valor < 1000:
            return str(valor)
        elif valor < 1_000_000:
            return f"{valor / 1000:.1f}k"
        elif valor < 1_000_000_000:
            return f"{valor / 1_000_000:.1f}m"
        elif valor < 1_000_000_000_000:
            return f"{valor / 1_000_000_000:.1f}b"
        else:
            return f"{valor / 1_000_000_000_000:.1f}t"

================================================================================
üìÑ client/widgets/waiting_room_overlay.py
================================================================================
# client/widgets/waiting_room_overlay.py
from PyQt6.QtWidgets import (
    QWidget, QVBoxLayout, QLabel, QPushButton, QFrame, QSizePolicy
)
from PyQt6.QtCore import Qt
from PyQt6.QtGui import QFont


class WaitingRoomOverlay(QWidget):
    """
    Overlay flutuante para exibir a sala de espera no centro da √°rea principal,
    entre as barras laterais, substituindo o 'Welcome to Global Arena'.
    """

    def __init__(self, username: str, max_jogadores: int, parent=None):
        super().__init__(parent)
        self.username = username
        self.max_jogadores = max_jogadores
        self.setup_ui()

    def setup_ui(self):
        # Fundo transl√∫cido escuro
        self.setStyleSheet("background-color: rgba(0, 0, 0, 180);")
        self.setAttribute(Qt.WidgetAttribute.WA_TranslucentBackground)
        self.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)

        # Layout principal com centraliza√ß√£o vertical
        layout = QVBoxLayout(self)
        layout.setContentsMargins(20, 15, 20, 15)
        layout.setSpacing(12)
        layout.setAlignment(Qt.AlignmentFlag.AlignCenter)

        # ‚úÖ Adicionar stretch acima para centralizar
        layout.addStretch()

        # --- T√çTULO: Waiting Room ---
        self.label_titulo = QLabel("Waiting Room")
        font_titulo = QFont()
        font_titulo.setPointSize(20)
        font_titulo.setBold(True)
        self.label_titulo.setFont(font_titulo)
        self.label_titulo.setStyleSheet("color: #3498db;")
        self.label_titulo.setAlignment(Qt.AlignmentFlag.AlignCenter)
        layout.addWidget(self.label_titulo)

        # --- SUBT√çTULO: Players: X / 4 ---
        self.label_subtitulo = QLabel(f"Players: 1 / {self.max_jogadores}")
        font_sub = QFont()
        font_sub.setPointSize(14)
        self.label_subtitulo.setFont(font_sub)
        self.label_subtitulo.setStyleSheet("color: #ecf0f1;")
        self.label_subtitulo.setAlignment(Qt.AlignmentFlag.AlignCenter)
        layout.addWidget(self.label_subtitulo)

        # --- CAIXA: Nome do jogador ---
        self.content_frame = QFrame()
        self.content_frame.setStyleSheet("""
            background-color: #2c3e50;
            border: 2px solid #3498db;
            border-radius: 16px;
            padding: 20px;
        """)
        content_layout = QVBoxLayout()
        content_layout.setSpacing(10)

        # ‚úÖ REMOVIDO: self.label_icon = QLabel("üéÆ") ‚Üí N√£o queremos o emoji

        self.label_user = QLabel(f"You: {self.username}")
        self.label_user.setStyleSheet("font-size: 14px; color: #bdc3c7;")
        self.label_user.setAlignment(Qt.AlignmentFlag.AlignCenter)
        content_layout.addWidget(self.label_user)

        self.content_frame.setLayout(content_layout)
        layout.addWidget(self.content_frame)

        # --- BOT√ÉO CANCEL ---
        self.btn_cancel = QPushButton("Cancel")
        self.btn_cancel.setStyleSheet("""
            QPushButton {
                background-color: #e74c3c;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 6px;
                font-weight: bold;
                font-size: 13px;
            }
            QPushButton:hover {
                background-color: #c0392b;
            }
        """)
        self.btn_cancel.setFixedHeight(35)
        layout.addWidget(self.btn_cancel)

        # ‚úÖ Adicionar stretch abaixo para centralizar
        layout.addStretch()

    def atualizar_status(self, total_na_sala: int, vagas: int):
        """Atualiza o subt√≠tulo com o n√∫mero de jogadores na sala."""
        self.label_subtitulo.setText(f"Players: {total_na_sala} / {vagas}")

    def connect_cancel(self, callback):
        """Conecta o bot√£o Cancelar a uma fun√ß√£o."""
        if callable(callback):
            self.btn_cancel.clicked.connect(callback)

================================================================================
üìÑ client/widgets/offline_setup_overlay.py
================================================================================
# client/widgets/offline_setup_overlay.py
from PyQt6.QtWidgets import (
    QWidget, QVBoxLayout, QLabel, QPushButton, QComboBox, QSpinBox, QHBoxLayout
)
from PyQt6.QtCore import Qt, pyqtSignal


class OfflineSetupOverlay(QWidget):
    """
    Overlay flutuante para configurar partida offline: escolher fator e bioma.
    Emite sinal `on_start(fator, bioma)` ao clicar em "Iniciar".
    """

    on_start = pyqtSignal(int, str)

    def __init__(self, parent=None):
        super().__init__(parent)
        self.parent_widget = parent
        self.setup_ui()

    def setup_ui(self):
        self.setAttribute(Qt.WidgetAttribute.WA_TranslucentBackground)
        self.setStyleSheet("""
            background-color: rgba(30, 30, 40, 220);
            border-radius: 16px;
            border: 1px solid #3498db;
            color: white;
        """)

        layout = QVBoxLayout()
        layout.setContentsMargins(30, 20, 30, 20)
        layout.setSpacing(20)

        # T√≠tulo
        title = QLabel("üéÆ Modo Offline")
        title.setStyleSheet("font-size: 24px; font-weight: bold; color: #ffffff;")
        title.setAlignment(Qt.AlignmentFlag.AlignCenter)
        layout.addWidget(title)

        # Formul√°rio
        form_layout = QVBoxLayout()
        form_layout.setSpacing(15)

        # Fator
        fator_layout = QHBoxLayout()
        fator_label = QLabel("Fator:")
        fator_label.setStyleSheet("min-width: 80px;")
        self.spin_fator = QSpinBox()
        self.spin_fator.setMinimum(4)  # fator >= 4
        self.spin_fator.setMaximum(99)  # limite t√©cnico alto
        self.spin_fator.setValue(4)  # valor inicial
        self.spin_fator.setAccelerated(True)  # rolagem r√°pida
        self.spin_fator.setStyleSheet("padding: 6px;")
        fator_layout.addWidget(fator_label)
        fator_layout.addWidget(self.spin_fator)
        form_layout.addLayout(fator_layout)

        # Bioma
        bioma_layout = QHBoxLayout()
        bioma_label = QLabel("Bioma:")
        bioma_label.setStyleSheet("min-width: 80px;")
        self.combo_bioma = QComboBox()
        biomas_permitidos = ["Meadow", "Forest", "Savanna", "Desert", "Hills", "Mountains"]
        self.combo_bioma.addItems(biomas_permitidos)
        self.combo_bioma.setCurrentText("Meadow")
        self.combo_bioma.setStyleSheet("padding: 6px;")
        bioma_layout.addWidget(bioma_label)
        bioma_layout.addWidget(self.combo_bioma)
        form_layout.addLayout(bioma_layout)

        layout.addLayout(form_layout)

        # Bot√µes
        btn_layout = QHBoxLayout()
        self.btn_cancel = QPushButton("Cancelar")
        self.btn_start = QPushButton("Iniciar")

        self.btn_cancel.clicked.connect(self.on_cancel)
        self.btn_start.clicked.connect(self.on_confirm)

        btn_layout.addWidget(self.btn_cancel)
        btn_layout.addWidget(self.btn_start)
        layout.addLayout(btn_layout)

        self.setLayout(layout)

        # Tamanho fixo
        self.setFixedSize(400, 300)

    def on_confirm(self):
        fator = self.spin_fator.value()
        bioma = self.combo_bioma.currentText()
        self.on_start.emit(fator, bioma)  # ‚úÖ Emite o sinal
        self.hide()

    def on_cancel(self):
        if hasattr(self.parent(), 'on_offline_setup_canceled'):
            self.parent().on_offline_setup_canceled()
        self.hide()

    def showEvent(self, event):
        super().showEvent(event)
        if self.parent_widget:
            x = (self.parent_widget.width() - self.width()) // 2
            y = (self.parent_widget.height() - self.height()) // 2
            self.move(x, y)

================================================================================
üìÑ client/shaders/basic.frag
================================================================================
#version 330 core
in vec3 fragColor;
out vec4 FragColor;

void main() {
    FragColor = vec4(fragColor, 1.0);
}

================================================================================
üìÑ client/shaders/basic.vert
================================================================================
#version 330 core
layout(location = 0) in vec3 aPos;
layout(location = 1) in vec3 aColor;

uniform mat4 MVP;
uniform bool modo_politico;
uniform vec3 cor_uniforme;

out vec3 fragColor;

void main() {
    gl_Position = MVP * vec4(aPos, 1.0);
    if (modo_politico) {
        fragColor = cor_uniforme;
    } else {
        fragColor = aColor;
    }
}

================================================================================
üìÑ client/states/waiting_room.py
================================================================================
# client/states/waiting_room.py
from PyQt6.QtWidgets import (
    QWidget, QVBoxLayout, QLabel, QFrame
)
from PyQt6.QtCore import Qt, QTimer, pyqtProperty, QPropertyAnimation, QEasingCurve
from PyQt6.QtGui import QCursor
import requests


class OverlaySalaEspera(QWidget):
    """
    Widget de sobreposi√ß√£o (overlay) para exibir a sala de espera
    diretamente sobre o OpenGL, mantendo a barra de √≠cones, fundo e estrutura.
    N√£o substitui a janela principal.
    """

    def __init__(self, username: str, max_jogadores: int, parent=None):
        super().__init__(parent)
        self.username = username
        self.max_jogadores = max_jogadores
        self.parent_widget = parent  # Refer√™ncia ao widget pai (ex: opengl_container)
        self.timer = None
        self._opacity = 0.0
        self.setCursor(QCursor(Qt.CursorShape.WaitCursor))
        self.setup_ui()
        self.iniciar_polling()

    def _get_opacity(self):
        return self._opacity

    def _set_opacity(self, opacity):
        self._opacity = opacity
        # Atualiza fundo com transpar√™ncia
        self.setStyleSheet(
            f"background-color: rgba(44, 62, 80, {int(opacity * 180)}); "
            "border-radius: 15px; border: 1px solid #3498db;"
        )

    opacity = pyqtProperty(float, _get_opacity, _set_opacity)

    def setup_ui(self):
        # Layout principal
        layout = QVBoxLayout()
        layout.setSpacing(15)
        layout.setContentsMargins(20, 20, 20, 20)
        layout.setAlignment(Qt.AlignmentFlag.AlignCenter)

        # T√≠tulo
        titulo = QLabel("üéÆ Sala de Espera")
        titulo.setStyleSheet("font-size: 18px; font-weight: bold; color: #ecf0f1;")
        titulo.setAlignment(Qt.AlignmentFlag.AlignCenter)
        layout.addWidget(titulo)

        # Subt√≠tulo
        subtitulo = QLabel("Aguardando outros jogadores entrarem...")
        subtitulo.setStyleSheet("font-size: 13px; color: #bdc3c7;")
        subtitulo.setAlignment(Qt.AlignmentFlag.AlignCenter)
        layout.addWidget(subtitulo)

        # Linha separadora
        linha = QFrame()
        linha.setFrameShape(QFrame.Shape.HLine)
        linha.setFrameShadow(QFrame.Shadow.Sunken)
        linha.setStyleSheet("color: #34495e;")
        layout.addWidget(linha)

        # Status: jogadores na fila
        self.label_status = QLabel("Voc√™ entrou na fila...")
        self.label_status.setStyleSheet(
            "font-size: 16px; color: #ecf0f1; background-color: #2c3e50; "
            "padding: 10px; border-radius: 8px;"
        )
        self.label_status.setAlignment(Qt.AlignmentFlag.AlignCenter)
        layout.addWidget(self.label_status)

        # Informa√ß√£o do usu√°rio
        self.label_usuario = QLabel(f"Seu nome: {self.username}")
        self.label_usuario.setStyleSheet("font-size: 13px; color: #95a5a6;")
        self.label_usuario.setAlignment(Qt.AlignmentFlag.AlignCenter)
        layout.addWidget(self.label_usuario)

        self.setLayout(layout)

        # Estilo geral
        self.setFixedWidth(360)
        self.setFixedHeight(220)
        self.setStyleSheet("background-color: rgba(44, 62, 80, 180); border-radius: 15px; border: 1px solid #3498db;")
        self.setAttribute(Qt.WidgetAttribute.WA_TranslucentBackground)
        self.hide()  # Come√ßa oculto

    def iniciar_polling(self):
        """Inicia atualiza√ß√£o peri√≥dica do status da fila."""
        self.timer = QTimer(self)
        self.timer.timeout.connect(self.atualizar_status)
        self.timer.start(1000)  # A cada 1 segundo
        self.atualizar_status()  # Primeira atualiza√ß√£o imediata

    def atualizar_status(self):
        try:
            response = requests.get("http://localhost:5000/status", timeout=3)
            if response.status_code == 200:
                data = response.json()
                total_na_fila = data.get("total_na_fila", 0)
                self.label_status.setText(f"Jogadores na fila: {total_na_fila} / {self.max_jogadores}")
                print(f"üìä Status atual: {total_na_fila} / {self.max_jogadores}")

                if total_na_fila >= self.max_jogadores:
                    self.partida_iniciada()
        except requests.exceptions.ConnectionError:
            self.label_status.setText("‚ùå Erro de conex√£o")
        except Exception as e:
            self.label_status.setText(f"‚ùå Erro: {str(e)}")

    def partida_iniciada(self):
        """Chamado quando a sala est√° cheia. Evita chamadas duplicadas e garante transi√ß√£o segura."""
        print("üîµ [DEBUG] WaitingRoomOverlay.partida_iniciada: In√≠cio da execu√ß√£o")

        # 1. Parar o timer de atualiza√ß√£o
        if self.timer:
            print("‚è∏Ô∏è [DEBUG] WaitingRoomOverlay.partida_iniciada: Parando timer de atualiza√ß√£o")
            self.timer.stop()
        else:
            print("üü° [DEBUG] WaitingRoomOverlay.partida_iniciada: Timer j√° parado ou inexistente")

        # 2. Atualizar o status visual
        print("üé® [DEBUG] WaitingRoomOverlay.partida_iniciada: Atualizando texto do status")
        self.label_status.setText("‚úÖ Partida iniciada! Carregando mundo...")

        # 3. Verificar se a partida j√° foi iniciada (evitar duplica√ß√£o)
        parent = self.parent_widget
        if hasattr(parent, 'game_placeholder') and parent.game_placeholder is not None:
            print(
                "üî¥ [DEBUG] WaitingRoomOverlay.partida_iniciada: game_placeholder j√° existe. Partida j√° iniciada. Ignorando.")
            self.hide()
            return
        else:
            print("üü¢ [DEBUG] WaitingRoomOverlay.partida_iniciada: Nenhum game_placeholder detectado. Continuando...")

        # 4. Chamar a fun√ß√£o da janela principal com anima√ß√£o
        if hasattr(parent, 'on_partida_iniciada'):
            print(
                "üîµ [DEBUG] WaitingRoomOverlay.partida_iniciada: on_partida_iniciada encontrado no parent. Iniciando fade_out")

            # Iniciar anima√ß√£o de sa√≠da
            self.fade_out()

            # Chamar on_partida_iniciada ap√≥s a anima√ß√£o
            print("üü° [DEBUG] WaitingRoomOverlay.partida_iniciada: Agendando parent.on_partida_iniciada em 300ms")
            QTimer.singleShot(300, parent.on_partida_iniciada)
        else:
            print(
                "üî¥ [DEBUG] WaitingRoomOverlay.partida_iniciada: parent.on_partida_iniciada n√£o encontrado. Escondendo overlay.")
            # Caso n√£o exista callback, apenas esconder
            self.hide()

        print("üü¢ [DEBUG] WaitingRoomOverlay.partida_iniciada: Execu√ß√£o conclu√≠da")

    def fade_in(self):
        """Anima√ß√£o de entrada suave."""
        self._opacity = 0.0
        self.show()
        self.raise_()

        anim = QPropertyAnimation(self, b"opacity")
        anim.setDuration(250)
        anim.setStartValue(0.0)
        anim.setEndValue(1.0)
        anim.setEasingCurve(QEasingCurve.Type.InOutCubic)
        anim.start(QPropertyAnimation.DeletionPolicy.DeleteWhenStopped)

    def fade_out(self):
        """Anima√ß√£o de sa√≠da suave."""
        anim = QPropertyAnimation(self, b"opacity")
        anim.setDuration(200)
        anim.setStartValue(1.0)
        anim.setEndValue(0.0)
        anim.setEasingCurve(QEasingCurve.Type.InOutCubic)
        anim.start(QPropertyAnimation.DeletionPolicy.DeleteWhenStopped)

    def showEvent(self, event):
        """Reposiciona o overlay no centro do pai ao aparecer."""
        super().showEvent(event)
        if self.parent_widget:
            x = (self.parent_widget.width() - self.width()) // 2
            y = (self.parent_widget.height() - self.height()) // 2
            self.move(x, y)
        # Inicia anima√ß√£o de entrada
        QTimer.singleShot(10, self.fade_in)

    def resizeEvent(self, event):
        """Reposiciona ao redimensionar."""
        super().resizeEvent(event)
        if self.isVisible() and self.parent_widget:
            x = (self.parent_widget.width() - self.width()) // 2
            y = (self.parent_widget.height() - self.height()) // 2
            self.move(x, y)

================================================================================
üìÑ client/utils/scaling.py
================================================================================
# utils/scaling.py
from PyQt6.QtWidgets import QApplication

# Base DPI (assumimos 96 como padr√£o)
BASE_DPI = 96

# Fator de escala global
def get_scale_factor():
    screen = QApplication.primaryScreen()
    dpi = screen.logicalDotsPerInch()
    return dpi / BASE_DPI

# Fun√ß√µes de ajuda para dimensionamento
def scale(value: int) -> int:
    """Escalona um valor em pixels com base no DPI."""
    return int(value * get_scale_factor())

def scale_font(size: int) -> int:
    """Escalona tamanho de fonte (opcional: pode ser mais suave)."""
    return int(size * get_scale_factor())

================================================================================
üìÑ client/rendering/planet_renderer.py
================================================================================
pass

================================================================================
üìÑ client/rendering/camera.py
================================================================================
# client/rendering/camera.py
from pyglm import glm

class Camera:
    """
    C√¢mera orbital 3D para visualiza√ß√£o de planetas.
    Permite rota√ß√£o (orbit), zoom e atualiza√ß√£o da matriz de view/projection.
    """

    def __init__(self):
        # Posi√ß√£o inicial: olhando para a origem
        self.center = glm.vec3(0.0, 0.0, 0.0)  # Ponto central (planeta)
        self.distance = 5.0                   # Dist√¢ncia do centro
        self.theta = 0.0                      # Rota√ß√£o horizontal (Y)
        self.phi = glm.radians(10.0)          # Rota√ß√£o vertical (X), evita singularity

        self.fov = 45.0                       # Campo de vis√£o
        self.aspect = 1.0                     # Ser√° atualizado com o resize
        self.near = 0.1
        self.far = 100.0

        # Limites
        self.min_distance = 2.0
        self.max_distance = 20.0

    def orbit(self, dtheta: float, dphi: float, dzoom: float = 0.0):
        """
        Atualiza a c√¢mera com varia√ß√µes em theta, phi e zoom.
        Args:
            dtheta: varia√ß√£o em rota√ß√£o horizontal (mouse x)
            dphi: varia√ß√£o em rota√ß√£o vertical (mouse y)
            dzoom: varia√ß√£o de zoom (scroll)
        """
        self.theta += dtheta
        self.phi = glm.clamp(self.phi + dphi, 0.01, glm.pi() - 0.01)  # Evita polos

        # Atualiza dist√¢ncia com zoom
        self.distance = glm.clamp(self.distance + dzoom, self.min_distance, self.max_distance)

    def update_position(self):
        """
        Atualiza a posi√ß√£o da c√¢mera com base em theta, phi e dist√¢ncia.
        """
        # Coordenadas esf√©ricas ‚Üí cartesianas
        x = self.distance * glm.sin(self.phi) * glm.cos(self.theta)
        y = self.distance * glm.cos(self.phi)
        z = self.distance * glm.sin(self.phi) * glm.sin(self.theta)

        self.position = glm.vec3(x, y, z) + self.center

    def view_matrix(self):
        """
        Retorna a matriz de view (modelo de c√¢mera).
        Chamado em paintGL.
        """
        self.update_position()
        return glm.lookAt(self.position, self.center, glm.vec3(0.0, 1.0, 0.0))

    def projection_matrix(self):
        """
        Retorna a matriz de proje√ß√£o perspectiva.
        """
        return glm.perspective(self.fov, self.aspect, self.near, self.far)

    def set_aspect(self, aspect: float):
        """
        Atualiza o aspect ratio (largura/altura da janela).
        Chamado em resizeGL.
        """
        self.aspect = aspect

    def resetar(self, fator: float):
        """Reposiciona a c√¢mera para enxergar todo o planeta.
        A c√¢mera √© colocada a 4√ó o raio do planeta do centro.
        """
        # Raio do planeta: fator / (2 * sin(œÄ/5))
        raio_planeta = fator / (2 * glm.sin(glm.pi() / 5))

        # Dist√¢ncia do centro: 4√ó o raio (3√ó acima da superf√≠cie)
        self.distance = 3.0 * raio_planeta

        # √Çngulos iniciais
        self.theta = 0.0
        self.phi = glm.radians(30.0)  # Evita olhar diretamente de cima

        # Atualiza posi√ß√£o
        self.update_position()

================================================================================
üìÑ client/rendering/opengl_widget.py
================================================================================
# client/rendering/opengl_widget.py
import OpenGL.GL as gl
import ctypes
import numpy as np
from pyglm import glm
from PyQt6.QtOpenGLWidgets import QOpenGLWidget
from PyQt6.QtCore import Qt
from client.rendering.camera import Camera


class OpenGLWidget(QOpenGLWidget):
    def __init__(self):
        super().__init__()

        # --- Estado de Renderiza√ß√£o ---
        self.modulo_jogo = False  # Ativa renderiza√ß√£o do planeta
        self.mundo = None  # Refer√™ncia ao mundo atual
        self._geometria_necessaria = False  # Flag: geometria precisa ser criada em paintGL
        self.modo_renderizacao = "fisico"  # Modo de visualiza√ß√£o do mapa ('fisico' ou 'politico')

        # --- Recursos OpenGL ---
        self.shader_program = None  # Programa de shader ativo
        self.VAO = None  # VAO tempor√°rio (tri√¢ngulo de teste)
        self.VBO = None  # VBO tempor√°rio (tri√¢ngulo de teste)

        # --- Geometria do Planeta ---
        self.vaos = {}  # {coord: vao} ‚Äì um VAO por pol√≠gono
        self.vbos = {}  # {coord: vbo} ‚Äì um VBO por pol√≠gono

        # --- C√¢mera 3D ---
        self.camera = Camera()  # C√¢mera orbital (posi√ß√£o, rota√ß√£o, zoom)

        # --- Entrada do Usu√°rio ---
        self.setFocusPolicy(Qt.FocusPolicy.StrongFocus)  # Para eventos de teclado/mouse

        # --- Debug e Estado Interno ---
        # Pronto para expans√£o (ex: modo de depura√ß√£o, FPS, etc)

    def mudar_modo_mapa(self, modo: str):
        if modo in ["fisico", "politico"]:
            self.modo_renderizacao = modo
            self.update()
            print(f"‚úÖ [DEBUG] Modo alterado para '{modo}' e update() chamado")
        else:
            print(f"‚ùå [DEBUG] Modo inv√°lido: {modo}")

    def definir_modo_renderizacao(self, modo: str):
        """Muda o modo de renderiza√ß√£o: 'fisico' ou 'politico'"""
        if modo not in ["fisico", "politico"]:
            return
        self.modo_renderizacao = modo
        self.update()  # for√ßa redesenhar

    def initializeGL(self):
        """Configura√ß√£o inicial do contexto OpenGL.
        - Define estado padr√£o do pipeline
        - Compila shaders
        - Configura geometria inicial (tempor√°ria ou do planeta)
        """
        # === 1. Estado inicial do OpenGL ===
        gl.glClearColor(0.0, 0.0, 0.0, 1.0)  # Fundo preto
        gl.glEnable(gl.GL_DEPTH_TEST)  # Teste de profundidade
        gl.glDepthFunc(gl.GL_LESS)  # Z-test padr√£o
        gl.glEnable(gl.GL_BLEND)  # Blend para transpar√™ncia
        gl.glBlendFunc(gl.GL_SRC_ALPHA, gl.GL_ONE_MINUS_SRC_ALPHA)
        #gl.glEnable(gl.GL_CULL_FACE)  # Otimiza√ß√£o: cull back-face
        #gl.glCullFace(gl.GL_BACK)

        print("üéÆ Inicializando OpenGL...")

        # === 2. Compilar Shader Program ===
        try:
            with open("client/shaders/basic.vert", "r") as f:
                vertex_source = f.read()
            with open("client/shaders/basic.frag", "r") as f:
                fragment_source = f.read()

            from client.rendering.shader import ShaderProgram
            self.shader_program = ShaderProgram(vertex_source, fragment_source)

            if not self.shader_program.program_id:
                raise RuntimeError("Falha ao criar o programa de shader")

        except Exception as e:
            print(f"‚ùå Erro ao compilar shaders: {e}")
            self.shader_program = None
            return

        # === 3. Configurar Geometria Inicial ===
        try:
            # Se j√° temos um mundo carregado (ex: durante hot-reload), renderizamos ele
            if hasattr(self, 'mundo') and self.mundo:
                self._criar_geometria_planeta()
            else:
                # Caso contr√°rio, usamos um tri√¢ngulo tempor√°rio para teste
                self._criar_geometria_triangulo()

            print("‚úÖ OpenGL inicializado com sucesso: shaders e geometria prontos.")
        except Exception as e:
            print(f"‚ùå Erro ao configurar geometria: {e}")
            self.shader_program = None
            self.VAO = None
            self.VBO = None

    def _criar_geometria_triangulo(self):
        vertices = np.array([
            -0.5, -0.5, 0.0,  1.0, 0.0, 0.0,
             0.5, -0.5, 0.0,  0.0, 1.0, 0.0,
             0.0,  0.5, 0.0,  0.0, 0.0, 1.0,
        ], dtype=np.float32)

        self.VAO = gl.glGenVertexArrays(1)
        self.VBO = gl.glGenBuffers(1)

        gl.glBindVertexArray(self.VAO)
        gl.glBindBuffer(gl.GL_ARRAY_BUFFER, self.VBO)
        gl.glBufferData(gl.GL_ARRAY_BUFFER, vertices.nbytes, vertices, gl.GL_STATIC_DRAW)

        stride = 6 * 4  # 3 pos + 3 cor
        gl.glVertexAttribPointer(0, 3, gl.GL_FLOAT, False, stride, None)
        gl.glEnableVertexAttribArray(0)
        gl.glVertexAttribPointer(1, 3, gl.GL_FLOAT, False, stride, ctypes.c_void_p(3 * 4))
        gl.glEnableVertexAttribArray(1)

        gl.glBindBuffer(gl.GL_ARRAY_BUFFER, 0)
        gl.glBindVertexArray(0)

    def resizeGL(self, w: int, h: int):
        """Atualiza viewport e aspecto da c√¢mera."""
        if h > 0:
            self.camera.set_aspect(w / h)
        gl.glViewport(0, 0, w, h)

    def paintGL(self):
        """Renderiza o frame atual.
        - Modo jogo: renderiza o planeta com MVP e c√¢mera orbital
            ‚Üí Escolhe entre modo f√≠sico ou pol√≠tico com base em self.modo_renderizacao
        - Modo espera: apenas limpa o fundo (overlay est√° por cima)
        """
        # === 1. Limpar buffers ===
        gl.glClear(gl.GL_COLOR_BUFFER_BIT | gl.GL_DEPTH_BUFFER_BIT)

        # === 2. Modo Jogo: Renderizar o planeta ===
        if self.modulo_jogo and self.mundo and self.shader_program and self.shader_program.program_id:
            try:
                print(f"üîß [DEBUG] paintGL: Iniciando renderiza√ß√£o. Modo='{self.modo_renderizacao}'")

                # --- Atualizar c√¢mera ---
                if self.width() > 0 and self.height() > 0:
                    self.camera.set_aspect(self.width() / self.height())
                else:
                    print("‚ö†Ô∏è [DEBUG] Tamanho inv√°lido para atualizar c√¢mera")
                    return

                # --- Calcular MVP ---
                view = self.camera.view_matrix()
                proj = self.camera.projection_matrix()
                model = glm.mat4(1.0)
                mvp = proj * view * model

                # --- Ativar shader e enviar uniforms ---
                self.shader_program.usar()
                self.shader_program.set_uniform_mat4("MVP", glm.value_ptr(mvp))

                # --- Criar geometria, se necess√°rio ---
                if self._geometria_necessaria:
                    print("üîß [DEBUG] Criando geometria do planeta...")
                    self._criar_geometria_planeta()
                    self._geometria_necessaria = False
                    print(f"‚úÖ Geometria criada: {len(self.vaos)} pol√≠gonos")

                # --- üîÅ ROTEAMENTO DE RENDERIZA√á√ÉO ---
                if self.modo_renderizacao == "fisico":
                    # Desativar modo pol√≠tico no shader
                    if hasattr(self.shader_program, 'set_uniform_bool'):
                        self.shader_program.set_uniform_bool("modo_politico", False)
                    self._renderizar_planeta_fisico()

                elif self.modo_renderizacao == "politico":
                    # Ativar modo pol√≠tico no shader
                    if hasattr(self.shader_program, 'set_uniform_bool'):
                        self.shader_program.set_uniform_bool("modo_politico", True)
                    else:
                        print("‚ùå [DEBUG] set_uniform_bool n√£o dispon√≠vel no shader_program")
                    self._renderizar_planeta_politico()

                else:
                    print(f"‚ö†Ô∏è [DEBUG] Modo desconhecido: '{self.modo_renderizacao}'. Usando 'fisico' como fallback.")
                    if hasattr(self.shader_program, 'set_uniform_bool'):
                        self.shader_program.set_uniform_bool("modo_politico", False)
                    self._renderizar_planeta_fisico()

                # --- Limpeza final ---
                self.shader_program.limpar()

            except Exception as e:
                print(f"‚ùå Erro cr√≠tico em paintGL: {e}")
                import traceback
                traceback.print_exc()
                # Fundo vermelho para indicar falha
                gl.glClearColor(0.2, 0.0, 0.0, 1.0)
                gl.glClear(gl.GL_COLOR_BUFFER_BIT)

        # === 3. Modo Espera ou Estado Inv√°lido ===
        else:
            # Apenas limpa com fundo escuro ‚Äî o overlay est√° por cima
            gl.glClearColor(0.1, 0.1, 0.1, 1.0)
            gl.glClear(gl.GL_COLOR_BUFFER_BIT)

    def _renderizar_planeta_fisico(self):
        """Renderiza o planeta no modo f√≠sico, usando cores por v√©rtice (biomas, altitude, etc)."""
        print("üé® [DEBUG] Iniciando renderiza√ß√£o F√çSICA do planeta")

        # === 1. Atualizar c√¢mera ===
        if self.width() > 0 and self.height() > 0:
            self.camera.set_aspect(self.width() / self.height())
            print(f"üîß [DEBUG] Aspecto da c√¢mera atualizado: {self.width()}x{self.height()} ‚Üí {self.camera.aspect:.3f}")
        else:
            print("‚ö†Ô∏è [DEBUG] Tamanho inv√°lido para atualizar c√¢mera")
            return

        # === 2. Calcular MVP ===
        try:
            view = self.camera.view_matrix()
            proj = self.camera.projection_matrix()
            model = glm.mat4(1.0)
            mvp = proj * view * model
            print(f"üìê [DEBUG] MVP calculado. Posi√ß√£o da c√¢mera: ({view[3][0]:.2f}, {view[3][1]:.2f}, {view[3][2]:.2f})")
        except Exception as e:
            print(f"‚ùå [DEBUG] Falha ao calcular MVP: {e}")
            return

        # === 3. Ativar shader e configurar para modo f√≠sico ===
        try:
            self.shader_program.usar()
            self.shader_program.set_uniform_mat4("MVP", glm.value_ptr(mvp))
            self.shader_program.set_uniform_bool("modo_politico", False)  # üîµ Modo f√≠sico ativo
            print("‚úÖ [DEBUG] Shader ativado, MVP enviado, modo f√≠sico definido")
        except Exception as e:
            print(f"‚ùå [DEBUG] Erro ao usar shader ou enviar uniform: {e}")
            return

        # === 4. Validar geometria ===
        if not self.vaos:
            print("‚ùå [DEBUG] self.vaos est√° vazio! Nenhum VAO para desenhar.")
            return

        print(f"üìä [DEBUG] Renderizando {len(self.vaos)} pol√≠gonos no modo f√≠sico...")

        # === 5. Iterar e desenhar cada pol√≠gono ===
        for i, (coords, vao) in enumerate(self.vaos.items()):
            try:
                # Log detalhado apenas para os primeiros pol√≠gonos
                if i < 5:
                    num_vertices = len(self.mundo.planeta.poligonos[coords])
                    print(f"   ‚Üí Pol√≠gono {coords}: VAO={vao}, v√©rtices={num_vertices}")
                elif i == 5:
                    print("   ‚Üí (mais pol√≠gonos...)")

                gl.glBindVertexArray(vao)
                num_vertices = len(self.mundo.planeta.poligonos[coords])
                gl.glDrawArrays(gl.GL_TRIANGLE_FAN, 0, num_vertices)

            except Exception as e:
                print(f"‚ùå [DEBUG] Erro ao renderizar pol√≠gono {coords}: {e}")
                continue  # Tenta o pr√≥ximo

        # === 6. Limpeza final ===
        gl.glBindVertexArray(0)
        self.shader_program.limpar()
        print("‚úÖ [DEBUG] Renderiza√ß√£o F√çSICA conclu√≠da com sucesso")

    def _renderizar_planeta_politico(self):
        """Renderiza o planeta no modo pol√≠tico:
        - Oceano, mar, costa ‚Üí cinza escuro
        - Territ√≥rios de civiliza√ß√µes ‚Üí cor da civiliza√ß√£o (RGB convertido)
        - Terra sem dono ‚Üí cinza claro
        """
        print("üé® [DEBUG] Iniciando renderiza√ß√£o POL√çTICA do planeta")

        # === 1. Validar estado ===
        if not self.mundo or not self.mundo.planeta or not self.shader_program:
            print("‚ùå [DEBUG] _renderizar_planeta_politico: Dados insuficientes (mundo, planeta ou shader)")
            return

        # === 2. Atualizar c√¢mera ===
        if self.width() > 0 and self.height() > 0:
            self.camera.set_aspect(self.width() / self.height())
            print(f"üîß [DEBUG] Aspecto da c√¢mera atualizado: {self.width()}x{self.height()} ‚Üí {self.camera.aspect:.3f}")
        else:
            print("‚ö†Ô∏è [DEBUG] Tamanho inv√°lido para atualizar c√¢mera")
            return

        # === 3. Calcular MVP ===
        try:
            view = self.camera.view_matrix()
            proj = self.camera.projection_matrix()
            model = glm.mat4(1.0)
            mvp = proj * view * model
            print(f"üìê [DEBUG] MVP calculado. Posi√ß√£o da c√¢mera: ({view[3][0]:.2f}, {view[3][1]:.2f}, {view[3][2]:.2f})")
        except Exception as e:
            print(f"‚ùå [DEBUG] Falha ao calcular MVP: {e}")
            return

        # === 4. Ativar shader e configurar para modo pol√≠tico ===
        try:
            self.shader_program.usar()
            self.shader_program.set_uniform_mat4("MVP", glm.value_ptr(mvp))  # compat√≠vel com shader
            self.shader_program.set_uniform_bool("modo_politico", True)  # üîµ Ativa modo uniforme
            print("‚úÖ [DEBUG] Shader ativado, MVP enviado, modo pol√≠tico ativo")
        except Exception as e:
            print(f"‚ùå [DEBUG] Erro ao usar shader ou enviar uniform: {e}")
            return

        # === 5. Refer√™ncias ===
        G = self.mundo.planeta.geografia
        desenhadas = set()  # Pol√≠gonos j√° renderizados

        # === 6. Desenhar OCEANOS (prioridade alta) ===
        cor_oceano = (0.2, 0.2, 0.2)
        self.shader_program.set_uniform_vec3("cor_uniforme", cor_oceano)
        print("üåä [DEBUG] Renderizando oceanos, mares e costas...")

        for coords, dados in G.nodes(data=True):
            bioma = dados.get("bioma")
            if bioma in ["Ocean", "Sea", "Coast"] and coords in self.vaos:
                try:
                    gl.glBindVertexArray(self.vaos[coords])
                    num_vertices = len(self.mundo.planeta.poligonos[coords])
                    gl.glDrawArrays(gl.GL_TRIANGLE_FAN, 0, num_vertices)
                    desenhadas.add(coords)
                except Exception as e:
                    print(f"‚ùå [DEBUG] Erro ao renderizar oceano {coords}: {e}")

        # === 7. Desenhar CIVILIZA√á√ïES (tem prioridade sobre terra neutra) ===
        print(f"üèõÔ∏è [DEBUG] Renderizando territ√≥rios de {len(self.mundo.civs)} civiliza√ß√µes...")
        for civ in self.mundo.civs:
            try:
                # Converter cor de (0-255) para (0.0-1.0)
                r, g, b = civ.cor
                cor_civ = (r / 255.0, g / 255.0, b / 255.0)
                self.shader_program.set_uniform_vec3("cor_uniforme", cor_civ)

                print(f"   ‚Üí Renderizando {len(civ.provincias)} prov√≠ncias de {civ.nome} com cor {cor_civ}")

                for provincia in civ.provincias:
                    coords = provincia.coordenadas
                    if coords in self.vaos and coords not in desenhadas:
                        try:
                            gl.glBindVertexArray(self.vaos[coords])
                            num_vertices = len(self.mundo.planeta.poligonos[coords])
                            gl.glDrawArrays(gl.GL_TRIANGLE_FAN, 0, num_vertices)
                            desenhadas.add(coords)
                        except Exception as e:
                            print(f"‚ùå [DEBUG] Erro ao renderizar prov√≠ncia {coords} de {civ.nome}: {e}")
            except Exception as e:
                print(f"‚ùå [DEBUG] Erro ao processar civiliza√ß√£o {civ.nome}: {e}")

        # === 8. Desenhar TERRA NEUTRA (apenas o que sobrou) ===
        cor_neutra = (0.6, 0.6, 0.6)
        self.shader_program.set_uniform_vec3("cor_uniforme", cor_neutra)
        print("üü® [DEBUG] Renderizando terra neutra...")

        for coords in G.nodes:
            if coords in desenhadas or coords not in self.vaos:
                continue
            try:
                node_data = G.nodes[coords]
                bioma = node_data.get("bioma")
                if bioma not in ["Ocean", "Sea", "Coast"]:  # Apenas terra
                    gl.glBindVertexArray(self.vaos[coords])
                    num_vertices = len(self.mundo.planeta.poligonos[coords])
                    gl.glDrawArrays(gl.GL_TRIANGLE_FAN, 0, num_vertices)
                    desenhadas.add(coords)
            except Exception as e:
                print(f"‚ùå [DEBUG] Erro ao renderizar terra neutra {coords}: {e}")

        # === 9. Limpeza final ===
        gl.glBindVertexArray(0)
        self.shader_program.limpar()
        print("‚úÖ [DEBUG] Renderiza√ß√£o POL√çTICA conclu√≠da com sucesso")

    def _criar_geometria_planeta(self):
        """Gera VAOs/VBOs para todos os pol√≠gonos do planeta."""
        self.vaos.clear()
        self.vbos.clear()

        print("üîß [DEBUG] Iniciando _criar_geometria_planeta")
        if not self.mundo or not self.mundo.planeta:
            print("‚ùå [DEBUG] Erro: self.mundo ou self.mundo.planeta √© None")
            return

        planeta = self.mundo.planeta
        print(f"üîß [DEBUG] Criando geometria para {len(planeta.poligonos)} pol√≠gonos")

        for coords, vertices_3d in planeta.poligonos.items():
            node_data = planeta.geografia.nodes[coords]
            cor_bioma = [c / 255.0 for c in node_data.get('cor_bioma', [128, 128, 128])]

            # Converter v√©rtices para array NumPy
            vertex_data = []
            for v in vertices_3d:
                vertex_data.extend(v)  # v √© [x, y, z]
                vertex_data.extend(cor_bioma)

            vertex_array = np.array(vertex_data, dtype=np.float32)

            # Gerar VAO e VBO
            vao = gl.glGenVertexArrays(1)
            vbo = gl.glGenBuffers(1)

            # ‚úÖ Bind completo: VAO ‚Üí VBO ‚Üí atributos ‚Üí desvincular
            gl.glBindVertexArray(vao)
            gl.glBindBuffer(gl.GL_ARRAY_BUFFER, vbo)
            gl.glBufferData(
                gl.GL_ARRAY_BUFFER,
                vertex_array.nbytes,
                vertex_array,
                gl.GL_STATIC_DRAW
            )

            stride = 6 * 4  # pos(3) + cor(3) = 6 floats

            # Layout: posi√ß√£o (0), cor (1)
            gl.glEnableVertexAttribArray(0)
            gl.glVertexAttribPointer(0, 3, gl.GL_FLOAT, False, stride, None)

            gl.glEnableVertexAttribArray(1)
            gl.glVertexAttribPointer(1, 3, gl.GL_FLOAT, False, stride, ctypes.c_void_p(3 * 4))

            # ‚úÖ Desvincular VBO antes do VAO
            gl.glBindBuffer(gl.GL_ARRAY_BUFFER, 0)
            gl.glBindVertexArray(0)

            self.vaos[coords] = vao
            self.vbos[coords] = vbo

        print(f"‚úÖ Geometria do planeta criada: {len(self.vaos)} pol√≠gonos")

    def carregar_mundo(self, mundo):
        """
        Carrega um novo mundo e prepara o OpenGL para renderiz√°-lo.
        Reseta estado visual e for√ßa recria√ß√£o da geometria.
        """
        self.mundo = mundo
        self.modulo_jogo = True
        self.vaos.clear()
        self.vbos.clear()
        self._geometria_necessaria = True

        # ‚úÖ Resetar c√¢mera com base no fator do novo mundo
        self.camera.resetar(mundo.planeta.fator)

        # ‚úÖ Sincronizar modo de renderiza√ß√£o com o mundo
        self.modo_renderizacao = mundo.modo_renderizacao

        # ‚úÖ For√ßar redraw
        self.update()

        print(f"üåç Mundo carregado. Modo: {self.modo_renderizacao}, Geometria ser√° criada em paintGL.")

    def ativar_modo_jogo(self):
        self.modulo_jogo = True
        self.update()

    def limpar_mundo(self):
        """Limpa o mundo atual, remove geometria OpenGL e para de renderizar o planeta."""
        self.mundo = None
        self.modulo_jogo = False  # Desativa modo jogo
        self.vaos.clear()
        self.vbos.clear()
        self._geometria_necessaria = True  # For√ßa recria√ß√£o futura, se necess√°rio
        self.update()  # Atualiza a tela (chama paintGL)
        print("üßπ Mundo limpo: geometria OpenGL removida e modo jogo desativado.")

    def centralizar_em(self, coords):
        """
        Reposiciona a c√¢mera para olhar diretamente para um hex√°gono.
        - Mant√©m o centro orbital em (0,0,0)
        - Usa a mesma dist√¢ncia definida em `resetar()`
        - Ajusta theta e phi para focar no tile
        """
        if not hasattr(self, 'mundo') or not self.mundo:
            print(f"‚ùå [centralizar_em] Mundo n√£o carregado. N√£o √© poss√≠vel centralizar em {coords}")
            return

        planeta = self.mundo.planeta

        if coords not in planeta.poligonos:
            print(f"‚ùå [centralizar_em] Coordenada {coords} n√£o encontrada em poligonos.")
            return

        vertices = planeta.poligonos[coords]
        if len(vertices) == 0:
            print(f"‚ùå [centralizar_em] Pol√≠gono {coords} sem v√©rtices.")
            return

        # === 1. Calcular centro 3D do hex√°gono ===
        centro = [sum(v[i] for v in vertices) / len(vertices) for i in range(3)]
        cx, cy, cz = float(centro[0]), float(centro[1]), float(centro[2])

        # Normalizar para dire√ß√£o unit√°ria
        norm = (cx ** 2 + cy ** 2 + cz ** 2) ** 0.5
        if norm == 0:
            print("‚ùå [centralizar_em] Norma zero, imposs√≠vel calcular dire√ß√£o.")
            return

        dx, dy, dz = cx / norm, cy / norm, cz / norm

        # === 2. Calcular theta e phi ===
        import math
        theta = math.atan2(dz, dx)  # Rota√ß√£o horizontal
        phi = math.acos(dy)  # Rota√ß√£o vertical

        # === 3. Calcular dist√¢ncia igual √† do `resetar()` ===
        fator = self.mundo.planeta.fator
        raio_planeta = fator / (2 * math.sin(math.pi / 5))  # mesma f√≥rmula de resetar()
        distance = 3.0 * raio_planeta  # mesma dist√¢ncia

        # === 4. Aplicar na c√¢mera ===
        camera = self.camera
        camera.center = glm.vec3(0.0, 0.0, 0.0)  # orbita ainda √© no centro do planeta
        camera.distance = distance
        camera.theta = theta
        camera.phi = phi
        camera.update_position()
        self.update()

        print(f"üìç C√¢mera reposicionada para olhar {coords}")
        print(f"   ‚Üí dist√¢ncia={distance:.2f}, theta={math.degrees(theta):.1f}¬∞, phi={math.degrees(phi):.1f}¬∞")

================================================================================
üìÑ client/rendering/shader.py
================================================================================
# client/rendering/shader.py
import OpenGL.GL as gl
from typing import Dict, Optional
import ctypes


class ShaderProgram:
    """
    Wrapper para programas de shader OpenGL.
    Compila vertex/fragment shaders e gerencia o programa linkado.
    """

    def __init__(self, vertex_source: str, fragment_source: str):
        self.program_id = None
        self.vertex_source = vertex_source
        self.fragment_source = fragment_source
        self._uniform_locations: Dict[str, int] = {}
        self._compile_and_link()

    def _compile_shader(self, source: str, shader_type) -> int:
        shader = gl.glCreateShader(shader_type)
        gl.glShaderSource(shader, source)
        gl.glCompileShader(shader)

        success = gl.glGetShaderiv(shader, gl.GL_COMPILE_STATUS)
        if not success:
            log = gl.glGetShaderInfoLog(shader).decode('utf-8')
            raise RuntimeError(f"Erro ao compilar shader ({shader_type}):\n{log}")

        return shader

    def _compile_and_link(self):
        """Compila e linka os shaders."""
        try:
            vertex_shader = self._compile_shader(self.vertex_source, gl.GL_VERTEX_SHADER)
            fragment_shader = self._compile_shader(self.fragment_source, gl.GL_FRAGMENT_SHADER)

            self.program_id = gl.glCreateProgram()
            gl.glAttachShader(self.program_id, vertex_shader)
            gl.glAttachShader(self.program_id, fragment_shader)
            gl.glLinkProgram(self.program_id)

            # Verifica link
            success = gl.glGetProgramiv(self.program_id, gl.GL_LINK_STATUS)
            if not success:
                log = gl.glGetProgramInfoLog(self.program_id).decode('utf-8')
                raise RuntimeError(f"Erro ao linkar shader program:\n{log}")

            # Limpa shaders intermedi√°rios
            gl.glDeleteShader(vertex_shader)
            gl.glDeleteShader(fragment_shader)

            print("‚úÖ Shader program criado com sucesso.")

        except Exception as e:
            print(f"‚ùå Falha ao criar shader program: {e}")
            self.program_id = None
            if vertex_shader:
                gl.glDeleteShader(vertex_shader)
            if fragment_shader:
                gl.glDeleteShader(fragment_shader)

    def usar(self):
        """Ativa o programa de shader."""
        if self.program_id:
            gl.glUseProgram(self.program_id)
        else:
            raise RuntimeError("Tentando usar shader inv√°lido.")

    def obter_localizacao_uniform(self, nome: str) -> int:
        """Cache da localiza√ß√£o de uniforms."""
        if nome not in self._uniform_locations:
            loc = gl.glGetUniformLocation(self.program_id, nome)
            if loc == -1:
                print(f"‚ö†Ô∏è Uniform '{nome}' n√£o encontrado no shader.")
            self._uniform_locations[nome] = loc
        return self._uniform_locations[nome]

    def set_uniform_mat4(self, nome: str, mat4):
        """Envia uma matriz 4x4 para o shader."""
        loc = self.obter_localizacao_uniform(nome)
        if loc != -1:
            gl.glUniformMatrix4fv(loc, 1, False, mat4)

    def set_uniform_int(self, nome: str, valor: int):
        """Envia um inteiro para o shader."""
        loc = self.obter_localizacao_uniform(nome)
        if loc != -1:
            gl.glUniform1i(loc, valor)

    def limpar(self):
        """Desativa o programa."""
        gl.glUseProgram(0)

    def deletar(self):
        """Libera o recurso de GPU."""
        if self.program_id:
            gl.glDeleteProgram(self.program_id)
            self.program_id = None

    def set_uniform_bool(self, nome: str, valor: bool):
        """Envia um booleano para o shader (como int)."""
        loc = gl.glGetUniformLocation(self.program_id, nome)
        if loc != -1:
            gl.glUniform1i(loc, 1 if valor else 0)
        else:
            print(f"‚ùå Uniform '{nome}' n√£o encontrado!")

    def set_uniform_vec3(self, nome: str, valor: tuple):
        """Envia um vetor 3D (ex: cor RGB) para o shader."""
        loc = gl.glGetUniformLocation(self.program_id, nome)
        if loc != -1:
            gl.glUniform3f(loc, valor[0], valor[1], valor[2])
        else:
            print(f"‚ùå Uniform '{nome}' n√£o encontrado!")

================================================================================
üìÑ client/dialogs/auth_dialog.py
================================================================================
# client/dialogs/auth_dialog.py
from PyQt6.QtWidgets import (
    QDialog, QTabWidget, QWidget, QFormLayout, QLineEdit,
    QDialogButtonBox, QMessageBox, QVBoxLayout
)
import requests


class DialogoAutenticacao(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Autentica√ß√£o")
        self.setModal(True)
        self.resize(350, 200)

        layout_principal = QVBoxLayout(self)

        # Abas: Login e Registro
        self.abas = QTabWidget()  # Salvando como atributo para acesso futuro
        self.abas.addTab(self.criar_aba_login(), "Entrar")
        self.abas.addTab(self.criar_aba_registro(), "Registrar")
        layout_principal.addWidget(self.abas)

        # Bot√µes comuns ‚Üí AGORA salvo como atributo: self.buttons
        self.buttons = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel
        )
        self.buttons.accepted.connect(self.on_ok)
        self.buttons.rejected.connect(self.reject)
        layout_principal.addWidget(self.buttons)

    def criar_aba_login(self):
        widget = QWidget()
        layout = QFormLayout()

        self.username_login = QLineEdit()
        self.username_login.setPlaceholderText("seu_username ou email")
        self.username_login.setToolTip("Digite seu username ou email para login.")
        layout.addRow("Username:", self.username_login)  # ‚Üê Aqui tamb√©m

        self.senha_login = QLineEdit()
        self.senha_login.setEchoMode(QLineEdit.EchoMode.Password)
        layout.addRow("Senha:", self.senha_login)

        widget.setLayout(layout)
        return widget

    def criar_aba_registro(self):
        widget = QWidget()
        layout = QFormLayout()

        self.username_registro = QLineEdit()
        self.username_registro.setPlaceholderText("ex: jogador_42")
        self.username_registro.setToolTip("Seu nome de usu√°rio √∫nico. Usado para login.")
        layout.addRow("Username:", self.username_registro)  # ‚Üê Alterado de "Usu√°rio"

        self.senha_registro = QLineEdit()
        self.senha_registro.setEchoMode(QLineEdit.EchoMode.Password)
        layout.addRow("Senha:", self.senha_registro)

        self.confirmar_senha = QLineEdit()
        self.confirmar_senha.setEchoMode(QLineEdit.EchoMode.Password)
        layout.addRow("Confirmar:", self.confirmar_senha)

        widget.setLayout(layout)
        return widget

    def on_ok(self):
        """Chamado quando o bot√£o OK √© pressionado. Executa login ou registro conforme aba ativa."""
        aba_atual = self.abas.currentIndex()  # ‚úÖ Acesso direto ao QTabWidget
        if aba_atual == 0:
            self.tentar_login()
        else:
            self.tentar_registro()

    def tentar_login(self):
        username = self.username_login.text().strip()
        password = self.senha_login.text()

        if not username or not password:
            QMessageBox.warning(self, "Erro", "Usu√°rio e senha s√£o obrigat√≥rios.")
            return

        try:
            response = requests.post(
                "http://localhost:5000/auth/login",
                json={"username": username, "password": password}
            )
            data = response.json()

            if response.status_code == 200 and data.get("success"):
                with open("session.txt", "w") as f:
                    f.write(username)
                QMessageBox.information(self, "Sucesso", f"Bem-vindo, {username}!")
                self.accept()  # Fecha o di√°logo com sucesso
            else:
                QMessageBox.critical(self, "Erro", data.get("message", "Falha no login."))
        except requests.exceptions.ConnectionError:
            QMessageBox.critical(self, "Erro", "N√£o foi poss√≠vel conectar ao servidor.")
        except Exception as e:
            QMessageBox.critical(self, "Erro", f"Erro inesperado: {e}")

    def tentar_registro(self):
        username = self.username_registro.text().strip()
        password = self.senha_registro.text()
        confirmar = self.confirmar_senha.text()

        if not username or not password or not confirmar:
            QMessageBox.warning(self, "Erro", "Todos os campos s√£o obrigat√≥rios.")
            return
        if password != confirmar:
            QMessageBox.warning(self, "Erro", "As senhas n√£o coincidem.")
            return
        if len(password) < 6:
            QMessageBox.warning(self, "Erro", "A senha deve ter pelo menos 6 caracteres.")
            return

        try:
            response = requests.post(
                "http://localhost:5000/auth/registrar",
                json={"username": username, "password": password}
            )
            data = response.json()

            if response.status_code == 200 and data.get("success"):
                QMessageBox.information(self, "Sucesso", "Conta criada com sucesso! Fa√ßa login.")
                # Podemos mudar para aba de login automaticamente
                self.parent().findChild(QTabWidget).setCurrentIndex(0)
                self.username_login.setText(username)
            else:
                QMessageBox.critical(self, "Erro", data.get("message", "Falha no registro."))
        except requests.exceptions.ConnectionError:
            QMessageBox.critical(self, "Erro", "N√£o foi poss√≠vel conectar ao servidor.")
        except Exception as e:
            QMessageBox.critical(self, "Erro", f"Erro inesperado: {e}")

================================================================================
üìÑ client/components/icon_manager.py
================================================================================
# client/components/icon_manager.py
"""Componentes para gerenciar √≠cones interativos na barra lateral esquerda."""

import os
from PyQt6.QtWidgets import QLabel, QVBoxLayout, QWidget, QHBoxLayout
from PyQt6.QtCore import Qt, pyqtSignal
from PyQt6.QtGui import QPixmap, QCursor

# --- Sistema de Escala para DPI ---
from client.utils.scaling import scale

class IconeInterativo(QLabel):
    """
    Um QLabel que exibe uma imagem e emite um sinal quando clicado.
    """
    clicado = pyqtSignal(str)  # Sinal emitido ao ser clicado, passando um identificador

    def __init__(self, icone_path, identificador, tamanho_base=(64, 64), parent=None):
        """
        :param icone_path: Caminho para o arquivo PNG do √≠cone.
        :param identificador: String √∫nica ("login", "play", "sair").
        :param tamanho_base: Tamanho base em pixels (ser√° escalonado por DPI).
        :param parent: Widget pai.
        """
        super().__init__(parent)
        self.identificador = identificador
        self.tamanho_base = tamanho_base
        self.tamanho = (scale(tamanho_base[0]), scale(tamanho_base[1]))
        self.setAlignment(Qt.AlignmentFlag.AlignCenter)

        # Estilo para feedback visual
        self.setStyleSheet("""
            IconeInterativo {
                border: 2px solid transparent;
                border-radius: 5px;
            }
            IconeInterativo:hover {
                border: 2px solid #3498db;
                background-color: rgba(52, 152, 219, 30);
            }
        """)
        self.setCursor(QCursor(Qt.CursorShape.PointingHandCursor))

        self.carregar_icone(icone_path)
        self.setFixedSize(*self.tamanho)

    def carregar_icone(self, caminho):
        """Carrega e escala a imagem com suporte a placeholder."""
        print(f"[DEBUG] [IconeInterativo] Carregando √≠cone '{self.identificador}' de: '{caminho}'")

        pixmap = None
        if caminho and os.path.isfile(caminho):
            try:
                pixmap = QPixmap(caminho)
                if pixmap.isNull():
                    print(f"‚ö†Ô∏è Falha ao carregar QPixmap de '{caminho}'. Usando placeholder.")
                    pixmap = None
                else:
                    print(f"[DEBUG] [IconeInterativo] Carregado: {pixmap.width()}x{pixmap.height()}")
            except Exception as e:
                print(f"‚ùå Erro ao carregar √≠cone '{caminho}': {e}")
        else:
            print(f"‚ö†Ô∏è Arquivo n√£o encontrado: '{caminho}'. Usando placeholder.")

        if pixmap is None:
            # Placeholder
            pixmap = QPixmap(self.tamanho[0], self.tamanho[1])
            pixmap.fill(Qt.GlobalColor.gray)
            print(f"[DEBUG] [IconeInterativo] Placeholder criado para '{self.identificador}'.")
        else:
            # Escala com propor√ß√£o
            pixmap = pixmap.scaled(
                self.tamanho[0],
                self.tamanho[1],
                Qt.AspectRatioMode.KeepAspectRatio,
                Qt.TransformationMode.SmoothTransformation
            )

        self.setPixmap(pixmap)
        print(f"[DEBUG] [IconeInterativo] Pixmap definida para '{self.identificador}'.")

    def mousePressEvent(self, event):
        if event.button() == Qt.MouseButton.LeftButton:
            print(f"üñ±Ô∏è √çcone '{self.identificador}' clicado.")
            self.clicado.emit(self.identificador)
        super().mousePressEvent(event)


class GerenciadorIconesEsquerda(QWidget):
    """
    Widget que cont√©m e organiza os √≠cones interativos na barra esquerda.
    """
    icone_clicado = pyqtSignal(str)

    def __init__(self, caminho_recursos="client/resources", parent=None):
        super().__init__(parent)
        self.caminho_recursos = caminho_recursos
        self.icones = {}
        self.TAMANHO_ICONE_BASE = (36, 36)  # Base para escala DPI

        layout = QVBoxLayout(self)
        layout.setContentsMargins(
            scale(10), scale(10), scale(10), scale(10)
        )
        layout.setSpacing(scale(20))
        layout.setAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft)

        # --- √çcone de Login + Nome ---
        self.icone_login = IconeInterativo(
            os.path.join(self.caminho_recursos, "log-in.png"),
            "login",
            tamanho_base=self.TAMANHO_ICONE_BASE
        )
        self.icone_login.clicado.connect(self._ao_clicar_icone)

        self.label_nome_usuario = QLabel()
        self.label_nome_usuario.setStyleSheet("""
            color: #ecf0f1;
            background: transparent;
            border: none;
            font-size: """ + str(scale(14)) + """px;
            font-weight: bold;
        """)
        self.label_nome_usuario.hide()

        # Layout horizontal √∫nico
        self.login_layout = QHBoxLayout()
        self.login_layout.setContentsMargins(0, 0, 0, 0)
        self.login_layout.setSpacing(scale(8))
        self.login_layout.setAlignment(Qt.AlignmentFlag.AlignLeft)

        self.login_layout.addWidget(self.icone_login)
        self.login_layout.addWidget(self.label_nome_usuario)

        self.login_container = QWidget()
        self.login_container.setLayout(self.login_layout)
        layout.addWidget(self.login_container)

        self.icones["login"] = self.icone_login

        # --- √çcone de Play ---
        self.icone_play = IconeInterativo(
            os.path.join(self.caminho_recursos, "play.png"),
            "play",
            tamanho_base=self.TAMANHO_ICONE_BASE
        )
        self.icone_play.clicado.connect(self._ao_clicar_icone)
        layout.addWidget(self.icone_play)
        self.icones["play"] = self.icone_play

        # --- Espa√ßo para empurrar o √≠cone de sair para baixo ---
        layout.addStretch()

        # --- √çcone de Sair ---
        self.icone_sair = IconeInterativo(
            os.path.join(self.caminho_recursos, "arrow-left.png"),
            "sair",
            tamanho_base=self.TAMANHO_ICONE_BASE
        )
        self.icone_sair.clicado.connect(self._ao_clicar_icone)
        layout.addWidget(self.icone_sair)
        self.icones["sair"] = self.icone_sair

    def atualizar_estado_login(self, esta_logado: bool, nome_usuario: str = None):
        if esta_logado and nome_usuario:
            caminho = os.path.join(self.caminho_recursos, "smile.png")
            self.icone_login.carregar_icone(caminho)
            self.label_nome_usuario.setText(nome_usuario)
            self.label_nome_usuario.show()
        else:
            caminho = os.path.join(self.caminho_recursos, "log-in.png")
            self.icone_login.carregar_icone(caminho)
            self.label_nome_usuario.hide()

    def _ao_clicar_icone(self, identificador):
        print(f"üì° GerenciadorIconesEsquerda: √çcone '{identificador}' acionado.")
        self.icone_clicado.emit(identificador)

    def atualizar_icone(self, identificador, novo_caminho):
        if identificador in self.icones:
            self.icones[identificador].carregar_icone(novo_caminho)
        else:
            print(f"‚ö†Ô∏è √çcone '{identificador}' n√£o encontrado.")

    def remover_status_sala(self):
        if hasattr(self, 'widget_status_sala') and self.widget_status_sala is not None:
            layout = self.layout()
            if layout and self.widget_status_sala in layout:
                layout.removeWidget(self.widget_status_sala)
            self.widget_status_sala.deleteLater()
            self.widget_status_sala = None
            print("üóëÔ∏è Widget de status da sala removido da barra lateral.")

================================================================================
üìÑ shared/polygons.py
================================================================================
import math
import numpy

def dicionario_poligonos(fator):

    def icosaedro():
        
        def triangulo_original():
            
            def primeira_definicao_pontos():
                lista_pontos = []
                for x in range(fator ** 2):
                    if x % 2 == 0:
                        coord_x = x / 2 + 0.5
                        coord_y = math.sin(math.pi / 6)
                    else:
                        coord_x = x / 2 + 0.5
                        coord_y = math.sqrt(3) / 3
                    lista_pontos.append((round(coord_x, 15), round(coord_y, 15)))
                return lista_pontos
            
            def ponto_por_linha():
                lista_pontos = [0]
                ppf = fator * 2 - 1
                una = fator * 2 - 1
                while una != 1:
                    lista_pontos.append(ppf)
                    ppf += una - 2
                    una -= 2
                return lista_pontos

            def processar_coordenadas(coordenadas, indices):
                r = math.sqrt(3) / 3
                h = math.sqrt(0.75) * fator
                coords = []
                for i in range(len(indices)):
                    if i == len(indices) - 1:
                        segmento = [coordenadas[-1]]
                    else:
                        inicio, fim = indices[i], indices[i + 1]
                        segmento = coordenadas[inicio:fim]
                    for x in range(len(segmento)):
                        coefy = math.sin(math.pi / 6) * r
                        cx = (0.5 * i + 0.5 * x) + 0.5 - fator / 2
                        if x % 2 == 0:
                            cy = 0 + math.sqrt(0.75) * i + coefy - h / 2
                        else:
                            cy = r - coefy + math.sqrt(0.75) * i + coefy - h / 2
                        coords.append((cx, cy))
                return coords
            return processar_coordenadas(primeira_definicao_pontos(), ponto_por_linha())

        to = triangulo_original()

        def triangulos_equatoriais_em_pe():
            raio = fator / (2 * math.sin(math.pi / 5))
            apotema = fator / (2 * math.tan(math.pi / 5))
            theta = math.asin((raio - apotema) / fator)
            h = fator * math.sqrt(0.75)
            t1 = [(x, math.cos(theta) * y, math.sin(theta) * y) for x, y in to]
            t1 = [(x, y, z + apotema + math.sin(theta) * h / 2) for x, y, z in t1]
            return t1

        t1 = triangulos_equatoriais_em_pe()

        def rotacionar_em_torno_do_eixo_y(coordenadas, angulo_graus):
            angulo_radianos = math.radians(angulo_graus)
            cos_theta = math.cos(angulo_radianos)
            sin_theta = math.sin(angulo_radianos)
            coordenadas_rotacionadas = []
            for x, y, z in coordenadas:
                x_novo = cos_theta * x + sin_theta * z
                y_novo = y
                z_novo = -sin_theta * x + cos_theta * z
                coordenadas_rotacionadas.append((x_novo, y_novo, z_novo))
            return coordenadas_rotacionadas

        t2 = rotacionar_em_torno_do_eixo_y(t1, 72)
        t3 = rotacionar_em_torno_do_eixo_y(t1, 144)
        t4 = rotacionar_em_torno_do_eixo_y(t1, 216)
        t5 = rotacionar_em_torno_do_eixo_y(t1, 288)

        def triangulos_equatoriais_invertidos():
            raio = fator / (2 * math.sin(math.pi / 5))
            apotema = fator / (2 * math.tan(math.pi / 5))
            theta = math.asin((raio - apotema) / fator)
            h = fator * math.sqrt(0.75)
            t6 = [(x, -y) for x, y in to]
            t6 = [(x, math.cos(theta) * y, math.sin(theta) * -y) for x, y in t6]
            t6 = [(x, y, z + apotema + math.sin(theta) * h / 2) for x, y, z in t6]
            return t6

        tr = triangulos_equatoriais_invertidos()
        t6 = rotacionar_em_torno_do_eixo_y(tr, 36)
        t7 = rotacionar_em_torno_do_eixo_y(tr, 108)
        t8 = rotacionar_em_torno_do_eixo_y(tr, 180)
        t9 = rotacionar_em_torno_do_eixo_y(tr, 252)
        t10 = rotacionar_em_torno_do_eixo_y(tr, 324)

        def triangulos_polares_norte():
            alpha = math.acos(1 / (2 * math.tan(math.pi / 5) * math.sqrt(0.75)))
            apotema = fator / (2 * math.tan(math.pi / 5))
            h = fator * math.sqrt(0.75)
            deslocamento = apotema - math.cos(alpha) * h / 2
            raio = fator / (2 * math.sin(math.pi / 5))
            theta = math.asin((raio - apotema) / fator)
            deslocamento_vertical = (math.cos(theta) * h / 2) + (math.sin(alpha) * h / 2)
            tr = [(x, 0, -y) for x, y in to]
            tr = [(x, math.sin(alpha) * -z + deslocamento_vertical,
                z * math.cos(alpha) + deslocamento) for x, y, z in tr]
            return tr

        tr = triangulos_polares_norte()

        t11 = rotacionar_em_torno_do_eixo_y(tr, 36)
        t12 = rotacionar_em_torno_do_eixo_y(tr, 108)
        t13 = rotacionar_em_torno_do_eixo_y(tr, 180)
        t14 = rotacionar_em_torno_do_eixo_y(tr, 252)
        t15 = rotacionar_em_torno_do_eixo_y(tr, 324)

        def triangulos_polares_sul():
            alpha = math.acos(1 / (2 * math.tan(math.pi / 5) * math.sqrt(0.75)))
            apotema = fator / (2 * math.tan(math.pi / 5))
            h = fator * math.sqrt(0.75)
            deslocamento = apotema - math.cos(alpha) * h / 2
            raio = fator / (2 * math.sin(math.pi / 5))
            theta = math.asin((raio - apotema) / fator)
            deslocamento_vertical = (math.cos(theta) * h / 2) + (math.sin(alpha) * h / 2)
            t16 = [(x, 0, -y) for x, y in to]
            t16 = [(x, math.sin(alpha) * z - deslocamento_vertical,
                    z * math.cos(alpha) + deslocamento) for x, y, z in t16]
            return t16

        t16 = triangulos_polares_sul()
        t17 = rotacionar_em_torno_do_eixo_y(t16, 72)
        t18 = rotacionar_em_torno_do_eixo_y(t16, 144)
        t19 = rotacionar_em_torno_do_eixo_y(t16, 216)
        t20 = rotacionar_em_torno_do_eixo_y(t16, 288)
        return [t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20]

    def esfera(pontos, raio):

        def projetar_ponto_na_esfera(ponto, raio):
            x, y, z = ponto
            magnitude = math.sqrt(x**2 + y**2 + z**2)
            return (
                raio * x / magnitude,
                raio * y / magnitude,
                raio * z / magnitude
            )

        return [[projetar_ponto_na_esfera(ponto, raio) for ponto in lista] for lista in pontos]

    esfera = esfera(icosaedro(), fator)

    def poligonos():
        poligonos = []
        
        def ponto_por_linha():
            lista_pontos = [0]
            ppf = fator * 2 - 1
            una = fator * 2 - 1
            while una != 1:
                lista_pontos.append(ppf)
                ppf += una - 2
                una -= 2
            return lista_pontos

        p = ponto_por_linha()

        def hexagonos_centrais():
            hexagonos = []
            for t in esfera:
                i = 0
                for x in range(fator - 2, 0, -1):
                    for y in range(x):
                        hexagonos.append(numpy.array([
                            t[p[y] + i * 2 + 1],
                            t[p[y] + i * 2 + 2],
                            t[p[y] + i * 2 + 3],
                            t[p[y + 1] + i * 2 + 2],
                            t[p[y + 1] + i * 2 + 1],
                            t[p[y + 1] + i * 2]
                        ]))
                    i += 1
            return hexagonos

        poligonos.append(hexagonos_centrais())

        def hexagonos_tropicais_sul():
            hexagonos = []
            for x in range(5):
                for y in range(fator - 1):
                    hexagonos.append(numpy.array([
                        esfera[x][y * 2],
                        esfera[x][y * 2 + 1],
                        esfera[x][y * 2 + 2],
                        esfera[x + 15][y * 2 + 2],
                        esfera[x + 15][y * 2 + 1],
                        esfera[x + 15][y * 2]
                    ]))
            return hexagonos

        poligonos.append(hexagonos_tropicais_sul())

        def hexagonos_tropicais_norte():
            hexagonos = []
            for x in range(5, 10, 1):
                for y in range(fator - 1):
                    hexagonos.append(numpy.array([
                        esfera[x][y * 2],
                        esfera[x][y * 2 + 1],
                        esfera[x][y * 2 + 2],
                        esfera[x + 5][y * 2 + 2],
                        esfera[x + 5][y * 2 + 1],
                        esfera[x + 5][y * 2]
                    ]))
            return hexagonos

        poligonos.append(hexagonos_tropicais_norte())

        def hexagonos_equatoriais_ascendentes():
            hexagonos = []
            for x in range(5):
                for y in range(fator - 1):
                    if x == 0:
                        hexagonos.append(numpy.array([
                            esfera[x][p[y]],
                            esfera[x][p[y] + 1],
                            esfera[x][p[y + 1]],
                            esfera[x + 9][p[fator - y - 1] - 1],
                            esfera[x + 9][p[fator - y - 1] - 2],
                            esfera[x + 9][p[fator - y - 1] + 2 * y]
                        ]))
                    else:
                        hexagonos.append(numpy.array([
                            esfera[x][p[y]],
                            esfera[x][p[y] + 1],
                            esfera[x][p[y + 1]],
                            esfera[x + 4][p[fator - y - 1] - 1],
                            esfera[x + 4][p[fator - y - 1] - 2],
                            esfera[x + 4][p[fator - y - 1] + 2 * y]
                        ]))
            return hexagonos

        poligonos.append(hexagonos_equatoriais_ascendentes())

        def hexagonos_equatoriais_descendentes():
            hexagonos = []
            for x in range(5):
                for y in range(fator - 1):
                    hexagonos.append(numpy.array([
                        esfera[x][p[fator - 1 - y] + 2 * y],
                        esfera[x][p[fator - 1 - y] - 2],
                        esfera[x][p[fator - 1 - y] - 1],
                        esfera[x + 5][p[y + 1]],
                        esfera[x + 5][p[y] + 1],
                        esfera[x + 5][p[y]]
                    ]))
            return hexagonos

        poligonos.append(hexagonos_equatoriais_descendentes())

        def hexagonos_polares_norte():
            hexagonos = []
            for x in range(10, 15, 1):
                for y in range(fator - 1):
                    if x == 10:
                        hexagonos.append(numpy.array([
                            esfera[x][p[y]],
                            esfera[x][p[y] + 1],
                            esfera[x][p[y + 1]],
                            esfera[x + 4][p[y + 1] + (fator - y - 2) * 2],
                            esfera[x + 4][p[y + 1] - 2],
                            esfera[x + 4][p[y + 1] - 1]
                        ]))
                    else:
                        hexagonos.append(numpy.array([
                            esfera[x][p[y]],
                            esfera[x][p[y] + 1],
                            esfera[x][p[y + 1]],
                            esfera[x - 1][p[y + 1] + (fator - y - 2) * 2],
                            esfera[x - 1][p[y + 1] - 2],
                            esfera[x - 1][p[y + 1] - 1]
                        ]))
            return hexagonos

        poligonos.append(hexagonos_polares_norte())

        def hexagonos_polares_sul():
            hexagonos = []
            for x in range(15, 20):
                for y in range(fator - 1):
                    if x == 15:
                        hexagonos.append(numpy.array([
                            esfera[x][p[y]],
                            esfera[x][p[y] + 1],
                            esfera[x][p[y + 1]],
                            esfera[x + 4][p[y + 1] + (fator - y - 2) * 2],
                            esfera[x + 4][p[y + 1] - 2],
                            esfera[x + 4][p[y + 1] - 1]
                        ]))
                    else:
                        hexagonos.append(numpy.array([
                            esfera[x][p[y]],
                            esfera[x][p[y] + 1],
                            esfera[x][p[y + 1]],
                            esfera[x - 1][p[y + 1] + (fator - y - 2) * 2],
                            esfera[x - 1][p[y + 1] - 2],
                            esfera[x - 1][p[y + 1] - 1]
                        ]))
            return hexagonos

        poligonos.append(hexagonos_polares_sul())

        def pentagonos():

            pentagonos = []

            def pentagonos_tropicais_sul():
                pentagonos = []
                for x in range(5):
                    if x == 0:
                        pentagonos.append(numpy.array([
                            esfera[0][0],
                            esfera[9][p[fator - 1]],
                            esfera[4][p[1] - 1],
                            esfera[19][p[1] - 1],
                            esfera[15][0]
                        ]))
                    else:
                        pentagonos.append(numpy.array([
                            esfera[x][0],
                            esfera[x + 4][p[fator - 1]],
                            esfera[x - 1][p[1] - 1],
                            esfera[x + 14][p[1] - 1],
                            esfera[x + 15][0]
                        ]))
                return pentagonos

            pentagonos.extend(pentagonos_tropicais_sul())

            def pentagonos_tropicais_norte():
                pentagonos = []
                for x in range(5):
                    if x == 0:
                        pentagonos.append(numpy.array([
                            esfera[0][p[fator - 1]],
                            esfera[5][0],
                            esfera[10][0],
                            esfera[14][p[1] - 1],
                            esfera[9][p[1] - 1]
                        ]))
                    else:
                        pentagonos.append(numpy.array([
                            esfera[x][p[fator - 1]],
                            esfera[x + 5][0],
                            esfera[x + 10][0],
                            esfera[x + 9][p[1] - 1],
                            esfera[x + 4][p[1] - 1]
                        ]))
                return pentagonos

            pentagonos.extend(pentagonos_tropicais_norte())

            def pentagono_polo_norte():
                return numpy.array([
                    esfera[10][p[fator - 1]],
                    esfera[11][p[fator - 1]],
                    esfera[12][p[fator - 1]],
                    esfera[13][p[fator - 1]],
                    esfera[14][p[fator - 1]]
                ])

            pentagonos.append(pentagono_polo_norte())

            def pentagono_polo_sul():
                return numpy.array([
                    esfera[15][p[fator - 1]],
                    esfera[16][p[fator - 1]],
                    esfera[17][p[fator - 1]],
                    esfera[18][p[fator - 1]],
                    esfera[19][p[fator - 1]]
                ])

            pentagonos.append(pentagono_polo_sul())
            
            return pentagonos

        poligonos.append(pentagonos())

        return poligonos

    poligonos = poligonos()

    def dic_pol():
        coord_vert = {}
        h = 0
        for x in range(5):        
            for i, z in enumerate(range(fator - 2, 0, -1)):
                n = fator * 2 - 1
                for a in range(z):
                    coord_vert[(n - a, fator * x + i + 1)] = poligonos[0][h]
                    h += 1

        for x in range(5):
            for i, z in enumerate(range(fator - 2, 0, -1)):
                n = fator + 1
                for a in range(z):
                    coord_vert[(n + a, fator * x + 2 + i + a)] = poligonos[0][h]
                    h += 1

        for x in range(5):
            for i, z in enumerate(range(fator - 2, 0, -1)):
                n = fator - 1
                for a in range(z):
                    coord_vert[(n - a, fator * x + 1 - x * (a + 1) + i)] = poligonos[0][h]
                    h += 1

        for x in range(5):
            b = fator * x + 1 - x
            for i, z in enumerate(range(fator - 2, 0, -1)):
                n = fator * 2 + 1
                for a in range(z):
                    coord_vert[(n + a, b + i - a * x)] = poligonos[0][h]
                    h += 1
        h = 0
        for x in range(5):
            for z in range(fator - 1):
                coord_vert[(fator * 2, fator * x + z + 1)] = poligonos[1][h]
                h += 1
        h = 0
        for x in range(5):
            for z in range(fator - 1):
                coord_vert[(fator, fator * x + z + 1)] = poligonos[2][h]
                h += 1
        h = 0
        for x in range(5):
            for z in range(fator - 1):
                coord_vert[(fator * 2 - z - 1, fator * x)] = poligonos[3][h]
                h += 1
        h = 0
        for x in range(5):
            for z in range(fator - 1):
                coord_vert[(fator + z + 1, fator * x + z + 1)] = poligonos[4][h]
                h += 1
        h = 0
        for x in range(5):
            for z in range(fator - 1):
                coord_vert[(fator - z - 1, (fator - z - 1) * x)] = poligonos[5][h]
                h += 1
        h = 0
        for x in range(5):
            for i, z in enumerate(range(fator - 1, 0, -1)):
                coord_vert[(fator * 2 + i + 1, z * x)] = poligonos[6][h]
                h += 1
        h = 0
        for x in range(5):
            coord_vert[(fator * 2, fator * x)] = poligonos[7][h]
            h += 1
        for x in range(5):
            coord_vert[(fator, fator * x)] = poligonos[7][h]
            h += 1
        coord_vert[(0, 0)] = poligonos[7][h]
        h += 1
        coord_vert[(fator * 3, 0)] = poligonos[7][h]

        return coord_vert
    
    return dic_pol()

if __name__ == "__main__":
    import numpy as np
    import json
    import os

    # === CONFIGURE AQUI OS PAR√ÇMETROS ===
    fator_teste = 4
    # ====================================

    print(f"\nüîß Gerando dicion√°rio de pol√≠gonos com fator={fator_teste}...")
    poligonos = dicionario_poligonos(fator_teste)

    print(f"‚úÖ Gerado: {len(poligonos)} pol√≠gonos.")
    print("\nüîç Exibindo as primeiras 5 coordenadas e seus v√©rtices:")
    for i, (coords, vertices) in enumerate(poligonos.items()):
        if i >= 5:
            break
        print(f"   {coords}: {vertices.shape}")
        print(f"     {np.round(vertices, 3).tolist()}")

    # === SALVAR EM ARQUIVO ===

    # 1. Salvar como .npy (seguro, eficiente)
    npy_file = f"poligonos_fator{fator_teste}.npy"
    np.save(npy_file, poligonos)
    print(f"\nüíæ Dados salvos em: {os.path.abspath(npy_file)}")

    # 2. Preparar dicion√°rio para JSON (chaves como string, valores convertidos)
    def convert_for_json(obj):
        if isinstance(obj, np.ndarray):
            return np.round(obj, 6).tolist()
        if isinstance(obj, tuple):
            return f"{obj[0]},{obj[1]}"  # (x,y) ‚Üí "x,y"
        if isinstance(obj, (np.integer, int)):
            return int(obj)
        if isinstance(obj, (np.floating, float)):
            return round(float(obj), 6)
        raise TypeError(f"Tipo {type(obj)} n√£o serializ√°vel")

    print("üìù Convertendo dados para JSON...")
    try:
        # Convers√£o expl√≠cita
        poligonos_json = {}
        for k, v in poligonos.items():
            key = convert_for_json(k)
            value = convert_for_json(v)
            poligonos_json[key] = value

        # Testar serializa√ß√£o (sem salvar)
        json_string = json.dumps(poligonos_json, ensure_ascii=False, indent=2)
        print(f"‚úÖ Convers√£o para JSON bem-sucedida! Tamanho: {len(json_string)} caracteres")

        # Salvar
        json_file = f"poligonos_fator{fator_teste}.json"
        with open(json_file, 'w', encoding='utf-8') as f:
            f.write(json_string)
        print(f"üìÑ Dados salvos em: {os.path.abspath(json_file)}")

    except Exception as e:
        print(f"‚ùå Falha ao gerar JSON: {e}")
        print("üí° Dica: Verifique se todos os dados s√£o serializ√°veis.")
        raise

    print("\nüéâ Gera√ß√£o e salvamento conclu√≠dos!")
    print("üí° Dica: Abra o arquivo .json em qualquer editor de texto para inspe√ß√£o.")

================================================================================
üìÑ shared/planet.py
================================================================================
import random
from shared.polygons import dicionario_poligonos
from shared.geography import definir_geografia

class Planeta:
    def __init__(self, fator, bioma):
        self.fator = fator
        self.bioma_inicial = bioma
        self.poligonos = dicionario_poligonos(fator)
        print(f"üåç [DEBUG] Planeta criado: {len(self.poligonos)} pol√≠gonos")
        print(f"   Exemplo: chave={list(self.poligonos.keys())[0]}, shape={list(self.poligonos.values())[0].shape}")
        self.geografia, self.capitais_players = definir_geografia(self.poligonos, fator, bioma) # capitais = [(int, int), ...]
        if len(self.capitais_players) > 24:
            self.capitais_players = random.sample(self.capitais_players, 24)
        random.shuffle(self.capitais_players)
        self.numero_de_jogadores = len(self.capitais_players)
        biomas_invalidos = {"Ice", "Sea", "Ocean", "Coast", bioma}
        capitais_player_set = set(self.capitais_players)
        nodos_validos = [
            n for n in self.geografia.nodes()
            if self.geografia.nodes[n]["bioma"] not in biomas_invalidos and n not in capitais_player_set
        ]
        npn = 24 - len(self.capitais_players)  # Lembrar de evitar npn (pa√≠ses neutros) negativo
        npn = min(npn, len(nodos_validos))  # Garante que npn <= len(nodos_validos)
        print(f"üåç [DEBUG] Planeta: {len(nodos_validos)} nodos v√°lidos para capitais neutras, solicitados: {npn}")
        self.capitais_neutros = []
        if npn > 0:
            self.capitais_neutros = random.sample(nodos_validos, npn)
        random.shuffle(self.capitais_neutros)
        self.civilizacoes = []

================================================================================
üìÑ shared/geography.py
================================================================================
import networkx
import random
import math
from statistics import mean
from random import choice

# CUSTOS BASE
CUSTOS_BASE = {
    'Ice': 20.0,
    'Mountains': 12.0,
    'Hills': 6.0,
    'Forest': 4.0,
    'Meadow': 3.0,
    'Savanna': 4.0,
    'Desert': 5.0,
    'Coast': 0.8,
    'Sea': 0.6,
    'Ocean': 0.4
}

PENALIDADE_TRANSICAO = 15.0

def letra_grega(placa):
    letras_gregas_dict = {
        "Alpha": "Œë", "Beta": "Œí", "Gamma": "Œì", "Delta": "Œî",
        "Epsilon": "Œï", "Zeta": "Œñ", "Eta": "Œó", "Theta": "Œò",
        "Iota": "Œô", "Kappa": "Œö", "Lambda": "Œõ", "Mu": "Œú",
        "Nu": "Œù", "Xi": "Œû", "Omicron": "Œü", "Pi": "Œ†",
        "Rho": "Œ°", "Sigma": "Œ£", "Tau": "Œ§", "Upsilon": "Œ•",
        "Phi": "Œ¶", "Chi": "Œß", "Psi": "Œ®", "Omega": "Œ©"
    }
    return letras_gregas_dict.get(placa)

def definir_geografia(poligonos, fator, bioma):

    geografia = networkx.DiGraph()

    for coordenadas in poligonos:
        geografia.add_node(coordenadas)

    def tipo_de_poligono(c):
        if c == (0, 0):
            geografia.nodes[c]['tipo'] = 'pn'
            return "pn"
        elif 0 < c[0] < fator and c[1] % c[0] == 0:
            geografia.nodes[c]['tipo'] = 'ipn'
            return "ipn"
        elif 0 < c[0] < fator and c[1] % c[0] != 0:
            geografia.nodes[c]['tipo'] = 'cpn'
            return "cpn"
        elif c[0] == fator and c[1] % c[0] == 0:
            geografia.nodes[c]['tipo'] = 'ntn'
            return "ntn"
        elif c[0] == fator and c[1] % c[0] != 0:
            geografia.nodes[c]['tipo'] = 'itn'
            return "itn"
        elif fator < c[0] < fator * 2:
            geografia.nodes[c]['tipo'] = 'e'
            return "e"
        elif c[0] == fator * 2 and c[1] % fator != 0:
            geografia.nodes[c]['tipo'] = 'its'
            return "its"
        elif c[0] == fator * 2 and c[1] % fator == 0:
            geografia.nodes[c]['tipo'] = 'nts'
            return "nts"
        elif fator * 2 < c[0] < fator * 3 and c[1] % (fator * 3 - c[0]) != 0:
            geografia.nodes[c]['tipo'] = 'cps'
            return "cps"
        elif fator * 2 < c[0] < fator * 3 and c[1] % (fator * 3 - c[0]) == 0:
            geografia.nodes[c]['tipo'] = 'ips'
            return "ips"
        elif c[0] == fator * 3:
            geografia.nodes[c]['tipo'] = 'ps'
            return "ps"

    for n in list(geografia.nodes):
        no = tipo_de_poligono(n)
        if no == "pn":
            for y in range(5):
                geografia.add_edge(n, (1, y), direcao=f'S{y+1}')
            continue
        if no == "ps":
            for y in range(5):
                geografia.add_edge(n, (fator * 3 - 1, y), direcao=f'N{y+1}')
            continue
        x = n[1] // n[0]
        y = n[1] // (fator * 3 - n[0])
        if no == "ipn":
            if n[1] != n[0] * 5 - 1:
                geografia.add_edge(n, (n[0] + 1, n[1] + x), direcao='S')
                geografia.add_edge(n, (n[0] + 1, n[1] + x + 1), direcao='SE')
                geografia.add_edge(n, (n[0], n[1] + 1), direcao='E')
                geografia.add_edge(n, (n[0] - 1, n[1] - x), direcao='N')
                geografia.add_edge(n, (n[0], n[1] - 1), direcao='W') if n[1] != 0 else geografia.add_edge(n, (n[0], n[0] * 5 - 1), direcao='W')
                geografia.add_edge(n, (n[0] + 1, n[1] + x - 1), direcao='SW') if n[1] != 0 else \
                                        geografia.add_edge(n, (n[0] + 1, (n[0] + 1) * 5 - 1), direcao='SW')
            else:
                geografia.add_edge(n, (n[0] + 1, n[1] + x), direcao='S')
                geografia.add_edge(n, (n[0] + 1, n[1] + x + 1), direcao='SE')
                geografia.add_edge(n, (n[0], 0), direcao='E')
                geografia.add_edge(n, (n[0] - 1, n[1] - x), direcao='N')
                geografia.add_edge(n, (n[0], n[1] - 1), direcao='W')
                geografia.add_edge(n, (n[0] + 1, n[1] + x - 1), direcao='SW')
        elif no == "cpn":
            if n[1] != n[0] * 5 - 1:
                geografia.add_edge(n, (n[0] + 1, n[1] + x + 1), direcao='SE')
                geografia.add_edge(n, (n[0], n[1] + 1), direcao='E')
                geografia.add_edge(n, (n[0] - 1, n[1] - x), direcao='NE')
                geografia.add_edge(n, (n[0] - 1, n[1] - x - 1), direcao='NW')
                geografia.add_edge(n, (n[0], n[1] - 1), direcao='W')
                geografia.add_edge(n, (n[0] + 1, n[1] + x), direcao='SW')
            else:
                geografia.add_edge(n, (n[0] + 1, n[1] + x + 1), direcao='SE')
                geografia.add_edge(n, (n[0], 0), direcao='E')
                geografia.add_edge(n, (n[0] - 1, 0), direcao='NE')
                geografia.add_edge(n, (n[0] - 1, n[1] - x - 1), direcao='NW')
                geografia.add_edge(n, (n[0], n[1] - 1), direcao='W')
                geografia.add_edge(n, (n[0] + 1, n[1] + x), direcao='SW')
        elif no == "ntn":
            geografia.add_edge(n, (n[0] + 1, n[1]), direcao='SW')
            geografia.add_edge(n, (n[0] + 1, n[1] + 1), direcao='SE')
            geografia.add_edge(n, (n[0], n[1] + 1), direcao='NE')
            geografia.add_edge(n, (n[0] - 1, n[1] - x), direcao='N')
            geografia.add_edge(n, (n[0], n[1] - 1), direcao='NW') if n[1] != 0 else geografia.add_edge(n, (n[0], n[0] * 5 - 1), direcao='NW')
        elif no == "itn":
            if n[1] != fator * 5 - 1:
                geografia.add_edge(n, (n[0] + 1, n[1]), direcao='SW')
                geografia.add_edge(n, (n[0] + 1, n[1] + 1), direcao='NE')
                geografia.add_edge(n, (n[0], n[1] + 1), direcao='E')
                geografia.add_edge(n, (n[0] - 1, n[1] - x), direcao='NE')
                geografia.add_edge(n, (n[0] - 1, n[1] - x - 1), direcao='NW')
                geografia.add_edge(n, (n[0], n[1] - 1), direcao='W')
            else:
                geografia.add_edge(n, (n[0] + 1, n[1]), direcao='SW')
                geografia.add_edge(n, (n[0] + 1, 0), direcao='NE')
                geografia.add_edge(n, (n[0], 0), direcao='E')
                geografia.add_edge(n, (n[0] - 1, 0), direcao='NE')
                geografia.add_edge(n, (n[0] - 1, n[1] - x - 1), direcao='NW')
                geografia.add_edge(n, (n[0], n[1] - 1), direcao='W')
        elif no == "e":
            if n[1] != fator * 5 - 1:
                geografia.add_edge(n, (n[0] + 1, n[1]), direcao='SW')
                geografia.add_edge(n, (n[0] + 1, n[1] + 1), direcao='SE')
                geografia.add_edge(n, (n[0], n[1] + 1), direcao='E')
                geografia.add_edge(n, (n[0] - 1, n[1]), direcao='NE')
                geografia.add_edge(n, (n[0] - 1, n[1] - 1), direcao='NW') if n[1] != 0 else geografia.add_edge(n, (n[0] - 1, fator * 5 - 1), direcao='NW')
                geografia.add_edge(n, (n[0], n[1] - 1), direcao='W') if n[1] != 0 else geografia.add_edge(n, (n[0], fator * 5 - 1), direcao='W')
            else:
                geografia.add_edge(n, (n[0] + 1, n[1]), direcao='SW')
                geografia.add_edge(n, (n[0] + 1, 0), direcao='SE')
                geografia.add_edge(n, (n[0], 0), direcao='E')
                geografia.add_edge(n, (n[0] - 1, n[1]), direcao='NE')
                geografia.add_edge(n, (n[0] - 1, n[1] - 1), direcao='NW')
                geografia.add_edge(n, (n[0], n[1] - 1), direcao='W')
        elif no == "its":
            if n[1] != fator * 5 - 1:
                geografia.add_edge(n, (n[0] + 1, n[1] - y), direcao='SE')
                geografia.add_edge(n, (n[0], n[1] + 1), direcao='E')
                geografia.add_edge(n, (n[0] - 1, n[1]), direcao='NE')
                geografia.add_edge(n, (n[0] - 1, n[1] - 1), direcao='NW')
                geografia.add_edge(n, (n[0], n[1] - 1), direcao='W')
                geografia.add_edge(n, (n[0] + 1, n[1] - y - 1), direcao='SW')
            else:
                geografia.add_edge(n, (n[0] + 1, 0), direcao='SE')
                geografia.add_edge(n, (n[0], 0), direcao='E')
                geografia.add_edge(n, (n[0] - 1, n[1]), direcao='NE')
                geografia.add_edge(n, (n[0] - 1, n[1] - 1), direcao='NW')
                geografia.add_edge(n, (n[0], n[1] - 1), direcao='W')
                geografia.add_edge(n, (n[0] + 1, n[1] - y - 1), direcao='SW')
        elif no == "nts":
            geografia.add_edge(n, (n[0] + 1, n[1] - y), direcao='S')
            geografia.add_edge(n, (n[0], n[1] + 1), direcao='SE')
            geografia.add_edge(n, (n[0] - 1, n[1]), direcao='NE')
            geografia.add_edge(n, (n[0] - 1, n[1] - 1), direcao='NW') if n[1] != 0 else geografia.add_edge(n, (n[0] - 1, fator * 5 - 1), direcao='NW')
            geografia.add_edge(n, (n[0], n[1] - 1), direcao='SW') if n[1] != 0 else geografia.add_edge(n, (n[0], fator * 5 - 1), direcao='SW')
        elif no == "cps":
            if n[1] != (fator * 3 - n[0]) * 5 - 1:
                geografia.add_edge(n, (n[0] + 1, n[1] - y), direcao='SE')
                geografia.add_edge(n, (n[0], n[1] + 1), direcao='E')
                geografia.add_edge(n, (n[0] - 1, n[1] + y + 1), direcao='NE')
                geografia.add_edge(n, (n[0] - 1, n[1] + y), direcao='NW')
                geografia.add_edge(n, (n[0], n[1] - 1), direcao='W')
                geografia.add_edge(n, (n[0] + 1, n[1] - y - 1), direcao='SW')
            else:
                geografia.add_edge(n, (n[0] + 1, 0), direcao='SE')
                geografia.add_edge(n, (n[0], 0), direcao='E')
                geografia.add_edge(n, (n[0] - 1, n[1] + y + 1), direcao='NE')
                geografia.add_edge(n, (n[0] - 1, n[1] + y), direcao='NW')
                geografia.add_edge(n, (n[0], n[1] - 1), direcao='W')
                geografia.add_edge(n, (n[0] + 1, n[1] - y - 1), direcao='SW')
        elif no == "ips":
            if n[1] != (fator * 3 - n[0]) * 5 - 1:
                geografia.add_edge(n, (n[0] + 1, n[1] - y), direcao='S')
                geografia.add_edge(n, (n[0], n[1] + 1), direcao='SE')
                geografia.add_edge(n, (n[0] - 1, n[1] + y + 1), direcao='NE')
                geografia.add_edge(n, (n[0] - 1, n[1] + y), direcao='N')
                geografia.add_edge(n, (n[0] - 1, n[1] + y - 1), direcao='NW') if n[1] != 0 else \
                                        geografia.add_edge(n, (n[0] - 1, (fator * 3 - n[0] + 1) * 5 - 1), direcao='NW')
                geografia.add_edge(n, (n[0], n[1] - 1), direcao='SW') if n[1] != 0 else \
                                        geografia.add_edge(n, (n[0], (fator * 3 - n[0]) * 5 - 1), direcao='SW')
            else:
                geografia.add_edge(n, (n[0] + 1, n[1] - y), direcao='S')
                geografia.add_edge(n, (n[0], 0), direcao='SE')
                geografia.add_edge(n, (n[0] - 1, n[1] + y + 1), direcao='NE')
                geografia.add_edge(n, (n[0] - 1, n[1] + y), direcao='N')
                geografia.add_edge(n, (n[0] - 1, n[1] + y - 1), direcao='NW')
                geografia.add_edge(n, (n[0], n[1] - 1), direcao='SW')

    areas = list(poligonos.keys())
    areas_sem_definicao = {}
    areas_definidas = {}
    referencias_relevo = random.sample(areas, fator * 20)

    for area in areas:
        areas_sem_definicao[area] = []
        areas_definidas[area] = []

    for n in range(fator * 3 // 2):
        if not areas_sem_definicao:
            break
        for node in referencias_relevo:
            altitude = random.randint(0, 12)
            areas_definidas[node].append(altitude)
            if node in areas_sem_definicao:
                del areas_sem_definicao[node]
            distancias = networkx.single_source_shortest_path_length(geografia, node)
            nos_a_n_arestas = [node for node, distance in distancias.items() if distance == n + 1]
            for neighbor in nos_a_n_arestas:
                if neighbor in areas_sem_definicao and neighbor not in referencias_relevo:
                    areas_sem_definicao[neighbor].append(altitude)
        for chave in list(areas_sem_definicao.keys()):
            if areas_sem_definicao[chave]:
                areas_definidas[chave].append(round(mean(areas_sem_definicao[chave]), 3))
                del areas_sem_definicao[chave]

    chaves = list(areas_definidas.keys())
    random.shuffle(chaves)
    chaves_ordenadas = sorted(chaves, key=lambda chave: areas_definidas[chave])
    percentual_terra = random.randint(35, 45)
    limite_abissal = (100 - percentual_terra) // 2
    limite_barreira = limite_abissal + (100 - percentual_terra) // 3
    nivel_do_mar = 100 - percentual_terra
    limite_planicie = nivel_do_mar + (100 - nivel_do_mar) * 4 // 6
    limite_planalto = limite_planicie + (100 - limite_planicie) // 2

    for i, chave in enumerate(chaves_ordenadas):
        if i <= len(chaves_ordenadas) * limite_abissal // 100:
            geografia.nodes[chave]['altitude'] = 'abissal'
        elif i <= len(chaves_ordenadas) * limite_barreira // 100:
            geografia.nodes[chave]['altitude'] = 'barreira'
        elif i <= len(chaves_ordenadas) * nivel_do_mar // 100:
            geografia.nodes[chave]['altitude'] = 'plataforma'
        elif i <= len(chaves_ordenadas) * limite_planicie // 100:
            geografia.nodes[chave]['altitude'] = 'planicie'
        elif i <= len(chaves_ordenadas) * limite_planalto // 100:
            geografia.nodes[chave]['altitude'] = 'planalto'
        else:
            geografia.nodes[chave]['altitude'] = 'cordilheira'

    areas_sem_definicao = {}
    areas_definidas = {}
    referencias_umidade = random.sample(areas, 60)

    for area in areas:
        areas_sem_definicao[area] = []
        areas_definidas[area] = []

    for n in range(fator * 3 // 2):
        if not areas_sem_definicao:
            break
        for node in referencias_umidade:
            altitude = random.randint(0, 12)
            areas_definidas[node].append(altitude)
            if node in areas_sem_definicao:
                del areas_sem_definicao[node]
            distancias = networkx.single_source_shortest_path_length(geografia, node)
            nos_a_n_arestas = [node for node, distance in distancias.items() if distance == n + 1]
            for neighbor in nos_a_n_arestas:
                if neighbor in areas_sem_definicao and neighbor not in referencias_umidade:
                    areas_sem_definicao[neighbor].append(altitude)
        for chave in list(areas_sem_definicao.keys()):
            if areas_sem_definicao[chave]:
                areas_definidas[chave].append(round(mean(areas_sem_definicao[chave]), 3))
                del areas_sem_definicao[chave]

    chaves = list(areas_definidas.keys())
    random.shuffle(chaves)
    chaves_ordenadas = sorted(chaves, key=lambda chave: areas_definidas[chave])

    for i, chave in enumerate(chaves_ordenadas):
        if i <= len(chaves_ordenadas) * 25 // 100:
            geografia.nodes[chave]['umidade'] = 'arido'
        elif i <= len(chaves_ordenadas) * 50 // 100:
            geografia.nodes[chave]['umidade'] = 'semi-arido'
        elif i <= len(chaves_ordenadas) * 75 // 100:
            geografia.nodes[chave]['umidade'] = 'fertil'
        else:
            geografia.nodes[chave]['umidade'] = 'umido'

    # Defini√ß√£o das placas com dois pontos de refer√™ncia cada
    placas = ['Alpha', 'Beta', 'Gamma', 'Delta', 'Epsilon', 'Zeta',
            'Eta', 'Theta', 'Iota', 'Kappa', 'Lambda', 'Mu',
            'Nu', 'Xi', 'Omicron', 'Pi', 'Rho', 'Sigma',
            'Tau', 'Upsilon', 'Phi', 'Chi', 'Psi', 'Omega']
    
    # Gerar duas refer√™ncias para cada placa (total 48)
    placas_duplicadas = placas * 2
    random.shuffle(placas_duplicadas)
    referencias_geologia = random.sample(areas, 48)

    # Atribuir cada refer√™ncia a uma placa
    areas_definidas = {area: None for area in areas}
    for i, node in enumerate(referencias_geologia):
        areas_definidas[node] = placas_duplicadas[i]

    # Calcular a placa para cada n√≥ baseado na proximidade
    for node in areas_definidas:
        if areas_definidas[node] is not None:
            continue  # Pula pontos de refer√™ncia j√° definidos
        
        # Encontrar todas as dist√¢ncias para pontos de refer√™ncia
        distancias = []
        for ref in referencias_geologia:
            try:
                dist = networkx.shortest_path_length(geografia, ref, node)
                distancias.append( (ref, dist) )
            except networkx.exception.NetworkXNoPath:
                continue
        
        if not distancias:
            areas_definidas[node] = random.choice(placas)
            continue
        
        # Encontrar a dist√¢ncia m√≠nima
        min_dist = min(d[1] for d in distancias)
        candidatos = [d[0] for d in distancias if d[1] == min_dist]
        
        # Escolher aleatoriamente entre candidatos equidistantes
        ref_escolhida = random.choice(candidatos)
        areas_definidas[node] = areas_definidas[ref_escolhida]
    
    coeficiente_movimento = 300

    # Gerar cores para as placas
    cores_placas = []
    for _ in range(24):
        while True:
            r = random.randint(0, 255)
            g = random.randint(0, 255)
            b = random.randint(0, 255)
            if (r + g + b) > 127.5:
                cores_placas.append((r, g, b))
                break

    latitude_equador = fator * 3 / 2

    for chave, valor in areas_definidas.items():
        geografia.nodes[chave]['placa'] = valor
        geografia.nodes[chave]['cor_placa'] = cores_placas[placas.index(valor)]
        geografia.nodes[chave]['letra_grega'] = letra_grega(geografia.nodes[chave]['placa'])
        if chave[0] < latitude_equador:
            distancia_para_equador = latitude_equador - chave[0]
            angulo = distancia_para_equador * 90 / latitude_equador
            incidencia_solar = math.cos(math.radians(angulo))
        elif chave[0] == latitude_equador:
            distancia_para_equador = 0
            angulo = distancia_para_equador * 90 / latitude_equador
            incidencia_solar = math.cos(math.radians(angulo))
        else:
            distancia_para_equador = chave[0] - latitude_equador
            angulo = distancia_para_equador * 90 / latitude_equador
            incidencia_solar = math.cos(math.radians(angulo))
        if geografia.nodes[chave]['altitude'] == 'abissal' \
        or geografia.nodes[chave]['altitude'] == 'barreira' \
        or geografia.nodes[chave]['altitude'] == 'plataforma':
            fator_altitude = 3
        elif geografia.nodes[chave]['altitude'] == 'planicie':
            fator_altitude = 1
        elif geografia.nodes[chave]['altitude'] == 'planalto':
            fator_altitude = -1
        elif geografia.nodes[chave]['altitude'] == 'cordilheira':
            fator_altitude = -3
        if geografia.nodes[chave]['umidade'] == 'umido':
            fator_umidade = 1.5
        elif geografia.nodes[chave]['umidade'] == 'fertil':
            fator_umidade = 0.5
        elif geografia.nodes[chave]['umidade'] == 'semi-arido':
            fator_umidade = -0.5
        elif geografia.nodes[chave]['umidade'] == 'arido':
            fator_umidade = -1.5
        geografia.nodes[chave]['temperatura'] = round(40 * incidencia_solar - 8 + fator_altitude + fator_umidade, 1) - 4

    for node, atributos in geografia.nodes(data=True):
        temperatura = atributos.get('temperatura')
        altitude = atributos.get('altitude')
        umidade = atributos.get('umidade')
        
        if temperatura < 0:
            atributos['bioma'] = 'Ice'
        else:
            if altitude == 'cordilheira':
                atributos['bioma'] = 'Mountains'
            elif altitude == 'planalto':
                atributos['bioma'] = 'Hills'
            elif altitude == 'planicie':
                if umidade == 'umido':
                    atributos['bioma'] = 'Forest'
                elif umidade == 'fertil':
                    atributos['bioma'] = 'Meadow'
                elif umidade == 'semi-arido':
                    atributos['bioma'] = 'Savanna'
                else:
                    atributos['bioma'] = 'Desert'
            elif altitude == 'plataforma':
                atributos['bioma'] = 'Coast'
            elif altitude == 'barreira':
                atributos['bioma'] = 'Sea'
            else:
                atributos['bioma'] = 'Ocean'
        
        # Aplica custo base diretamente do dicion√°rio
        atributos['cust_mob'] = CUSTOS_BASE[atributos['bioma']] * coeficiente_movimento

    for u, v in geografia.edges():
        mob_u = geografia.nodes[u]['cust_mob']
        mob_v = geografia.nodes[v]['cust_mob']
        
        u_maritimo = geografia.nodes[u]['bioma'] in ['Coast', 'Sea', 'Ocean']
        v_maritimo = geografia.nodes[v]['bioma'] in ['Coast', 'Sea', 'Ocean']
        
        if u_maritimo != v_maritimo:  # Transi√ß√£o terra-mar
            geografia[u][v]['cust_mob'] = max(mob_u, mob_v) * 2 + PENALIDADE_TRANSICAO * coeficiente_movimento
        else:
            geografia[u][v]['cust_mob'] = (mob_u + mob_v) / 2

        # B√¥nus para rotas oce√¢nicas longas
        if u_maritimo and v_maritimo:
            geografia[u][v]['cust_mob'] *= 0.7

    cores_biomas = {
        'Ocean': (0, 23, 98), 'Sea': (8, 33, 113), 'Coast': (12, 71, 108), 'Meadow': (91, 174, 70), 'Savanna': (231, 190, 141),
        'Forest': (75, 129, 66), 'Desert': (242, 242, 166), 'Hills': (201, 147, 121), 'Mountains': (158, 86, 86), 'Ice': (245, 255, 245)
    }

    bioma_escolhido = []

    for node in geografia.nodes:
        geografia.nodes[node]['cor_bioma'] = cores_biomas[geografia.nodes[node]['bioma']]
        if geografia.nodes[node]['bioma'] == f'{bioma}':
            bioma_escolhido.append(node)

    bioma_escolhido = [n for n, attr in geografia.nodes(data=True) if attr['bioma'] == f'{bioma}']
    lista_capitais = [choice(bioma_escolhido)]
    while len(lista_capitais) < len(bioma_escolhido) // 2:
        d2 = {}
        for candidato in bioma_escolhido:
            if candidato in lista_capitais:
                continue
            d = {}
            for capital in lista_capitais:
                d[capital] = networkx.shortest_path_length(geografia, source=candidato, target=capital, weight='custo_mobilidade')
            d2[candidato] = min(d.values())
        if not d2:  # Se n√£o houver candidatos poss√≠veis, o planeta n√£o comporta a quantidade desejada
            print("d2 vazio")
            raise ValueError("O planeta n√£o comporta essa quantidade de civiliza√ß√µes!")
        maior_valor = max(d2.values())
        chaves_maior_valor = [chave for chave, valor in d2.items() if valor == maior_valor]
        lista_capitais.append(choice(chaves_maior_valor))

    print(f"n√∫mero de {bioma}:", len(bioma_escolhido))
    return geografia, lista_capitais


================================================================================
üìÑ shared/civilization.py
================================================================================
# shared/civilization.py
import random
from shared.flags import bandeira


class Civilizacao:
    def __init__(self, ref, indice, nome, player=False, ponto_inicial=None):
        self.player = player
        self.nome = nome
        self.cultura = ref.culturas[indice % len(ref.culturas)]
        self.cor = ref.civs_cores[self.nome]
        self.modalidade_bandeira = random.randint(0, 82)
        self.cores_bandeira = bandeira(self.nome, self.modalidade_bandeira)
        self.ponto_inicial = ponto_inicial
        self.provincias = []
        self.unidades = []
        self.eh_jogador_local = False

        # ‚ùå Removido: popula√ß√£o agora √© por prov√≠ncia

    def get_populacao_total(self):
        """Calcula a popula√ß√£o total somando todas as prov√≠ncias."""
        return sum(p.get_populacao_total() for p in self.provincias)

    def get_genero_counts(self):
        """Retorna o total de homens e mulheres na civiliza√ß√£o."""
        homens = sum(p.homens for p in self.provincias)
        mulheres = sum(p.mulheres for p in self.provincias)
        return homens, mulheres

    def __repr__(self):
        h, m = self.get_genero_counts()
        return (f"Civiliza√ß√£o('{self.nome}', prov√≠ncias={len(self.provincias)}, "
                f"H={h}, M={m}, Total={h + m})")

================================================================================
üìÑ shared/province.py
================================================================================
# shared/province.py
from shared.naming import formar_nome


class Provincia:
    def __init__(self, civilizacao, coordenadas):
        self.civilizacao = civilizacao
        self.coordenadas = coordenadas
        self.nome = formar_nome(civilizacao.cultura)

        # üëâ Popula√ß√£o inicial: 1 homem e 1 mulher por prov√≠ncia
        self.homens = 1
        self.mulheres = 1

    def get_populacao_total(self):
        """Retorna a popula√ß√£o total da prov√≠ncia."""
        return self.homens + self.mulheres

    def aumentar_populacao(self):
        """
        Aumenta a popula√ß√£o da prov√≠ncia com base no n√∫mero de mulheres.
        Regra: nascimentos = n√∫mero de mulheres na prov√≠ncia.
        Distribui√ß√£o:
        - O g√™nero menos numeroso recebe o extra em caso de √≠mpar.
        - Se iguais, mulheres t√™m prefer√™ncia.
        """
        nascimentos = self.mulheres
        if nascimentos == 0:
            return

        if self.homens < self.mulheres:
            # Homens s√£o minoria ‚Üí recebem a maioria
            homens_novos = (nascimentos + 1) // 2
            mulheres_novas = nascimentos // 2
        elif self.mulheres < self.homens:
            # Mulheres s√£o minoria ‚Üí recebem a maioria
            mulheres_novas = (nascimentos + 1) // 2
            homens_novos = nascimentos // 2
        else:
            # Quantidades iguais ‚Üí mulheres levam o extra
            mulheres_novas = (nascimentos + 1) // 2
            homens_novos = nascimentos // 2

        self.homens += homens_novos
        self.mulheres += mulheres_novas

    def __repr__(self):
        return (f"Provincia({self.nome}, H={self.homens}, M={self.mulheres}, "
                f"Total={self.get_populacao_total()})")

================================================================================
üìÑ shared/world.py
================================================================================
# shared/world.py
import random
from uuid import uuid4
from shared.references import Referencias
from shared.planet import Planeta
from shared.civilization import Civilizacao
from shared.province import Provincia
from shared.turn import Turno  # ‚úÖ Importa a classe Turno


class Mundo:
    def __init__(self, fator=4, bioma='Meadow', id_mundo=None):
        self.id_mundo = id_mundo or str(uuid4())
        ref = Referencias()
        random.shuffle(ref.culturas)
        lista_de_cores = list(ref.civs_cores.keys())
        random.shuffle(lista_de_cores)
        self.planeta = Planeta(fator=fator, bioma=bioma)
        self.civs = []

        # Criar civiliza√ß√µes com capitais corretas
        for i, capital in enumerate(self.planeta.capitais_players):
            nome = lista_de_cores[i % len(lista_de_cores)]
            civ = Civilizacao(ref, i, nome, True, capital)
            self.civs.append(civ)

        for i, capital in enumerate(self.planeta.capitais_neutros):
            indice = i + len(self.planeta.capitais_players)
            nome = lista_de_cores[indice % len(lista_de_cores)]
            civ = Civilizacao(ref, indice, nome, False, capital)
            self.civs.append(civ)

        # Atribuir prov√≠ncia inicial usando o ponto_inicial de cada civ
        for civ in self.civs:
            provincia = Provincia(civ, civ.ponto_inicial)
            civ.provincias.append(provincia)

        # ‚úÖ Inicializa o sistema de turnos
        self.turno = Turno()

        # ‚úÖ Estado visual vinculado ao mundo (evita vazamento entre partidas)
        self.modo_renderizacao = "fisico"  # Pode ser "fisico" ou "politico"

    def get_populacao_global(self):
        """
        Retorna a popula√ß√£o total do mundo.
        :return: (homens, mulheres, total)
        """
        homens = sum(p.homens for civ in self.civs for p in civ.provincias)
        mulheres = sum(p.mulheres for civ in self.civs for p in civ.provincias)
        total = homens + mulheres
        return homens, mulheres, total

    def __repr__(self):
        h, m, t = self.get_populacao_global()
        return (f"<Mundo(id={self.id_mundo}, turno={self.turno.numero}, "
                f"Civiliza√ß√µes={len(self.civs)}, Popula√ß√£o={t} ‚Üí H={h}, M={m})>")

================================================================================
üìÑ shared/turn.py
================================================================================
# shared/turn.py
"""
M√≥dulo: shared/turn.py
Respons√°vel por gerenciar a l√≥gica de cada turno do jogo.
Atualmente: crescimento populacional por prov√≠ncia.
Futuramente: pode incluir produ√ß√£o, eventos, IA, etc.
"""


class Turno:
    def __init__(self):
        self.numero = 0  # Turno atual (0 = pr√©-jogo)
        self.historico = []  # Hist√≥rico de eventos por turno

    def avancar(self, mundo):
        """
        Avan√ßa um turno no mundo.
        Aplica todas as regras do jogo: crescimento populacional, etc.

        :param mundo: Inst√¢ncia de Mundo
        """
        self.numero += 1
        total_nascimentos = 0

        # Aplicar crescimento populacional em todas as prov√≠ncias
        for civ in mundo.civs:
            for provincia in civ.provincias:
                antes = provincia.get_populacao_total()
                provincia.aumentar_populacao()
                depois = provincia.get_populacao_total()
                total_nascimentos += (depois - antes)

        # Registrar no hist√≥rico
        registro = {
            "turno": self.numero,
            "nascimentos": total_nascimentos,
            "populacao_total": mundo.get_populacao_global()[2]
        }
        self.historico.append(registro)

        # Log opcional (pode ser removido ou controlado por DEBUG)
        # from shared.debug import DEBUG  # opcional
        # if DEBUG:
        print(f"\n--- Turno {self.numero} conclu√≠do ---")
        print(f"üìä +{total_nascimentos} nascimentos | Popula√ß√£o total: {registro['populacao_total']}")

    def resetar(self):
        """Reseta o contador de turnos (sem afetar o mundo)."""
        self.numero = 0
        self.historico.clear()
        print("üîÅ Turnos resetados.")

    def get_ultimo_registro(self):
        """Retorna o √∫ltimo registro do hist√≥rico, ou None."""
        return self.historico[-1] if self.historico else None

    def __repr__(self):
        return f"<Turno {self.numero} | Hist√≥rico: {len(self.historico)} turnos>"

================================================================================
üìÑ shared/references.py
================================================================================
class Referencias:
    def __init__(self):
        self.culturas = [
            'English', 'Chinese', 'Spanish',
            'French', 'Indian', 'Russian',
            'Vietnamese', 'Turkish', 'Arabic',
            'Indonesian', 'Persian', 'Hausa',
            'Swahili', 'Portuguese', 'Telugu',
            'Bengali', 'Japanese', 'Marathi',
            'Wu', 'Yue', 'Min',
            'Korean', 'Italian', 'German'
        ]
        self.civs_cores = {
            'Midnight Blue': (0, 0, 127), 'Blue': (0, 0, 255),
            'Dark Green': (0, 127, 0), 'Teal': (0, 127, 127), 'Sky Blue': (32, 127, 223),
            'Green': (0, 255, 0), 'Spring Green': (0, 255, 127), 'Cyan': (0, 223, 223),
            'Maroon': (127, 0, 0), 'Purple': (127, 0, 127), 'Violet': (127, 0, 255),
            'Olive': (127, 127, 0), 'Lavender': (127, 127, 255),
            'Chartreuse': (127, 255, 0), 'Light Green': (127, 223, 127), 'Pale Cyan': (127, 255, 255),
            'Red': (234, 33, 37), 'Rose': (255, 0, 127), 'Magenta': (255, 0, 255),
            'Orange': (223, 127, 32), 'Salmon': (255, 127, 127), 'Orchid': (255, 127, 255),
            'Yellow': (255, 255, 0), 'Light Yellow': (255, 255, 127)
        }

        self.tons_de_pele = [(245, 212, 205), (212, 160, 147), (163, 106, 95), (101, 61, 53)]
        self.tons_de_cabelo = [(209, 195, 2), (140, 106, 0), (99, 55, 26), (52, 48, 47)]

        self.produtividade_base = {
            'Meadow':     1.0,
            'Forest':     0.9,
            'Hills':      0.7,
            'Savanna':    0.6,
            'Coast':      0.5,
            'Desert':     0.3,
            'Mountains':  0.2,
            'Ice':        0.0,
            'Ocean':      0.0,
            'Sea':        0.0
        }


================================================================================
‚úÖ Total de 41 arquivos inclu√≠dos.
================================================================================