ARQUIVO DE CÃ“DIGO CONSOLIDADO
Gerado em: 2025-08-21 16:38:14
DiretÃ³rio: /home/mariagoreti/quan_qiu_wu_tai
ConteÃºdo dos scripts principais reunidos.

================================================================================

================================================================================
ğŸ“ ESTRUTURA DO PROJETO
================================================================================

ğŸ“ .
â”œâ”€â”€ server
â”‚   â”œâ”€â”€ routes
â”‚   â”‚   â”œâ”€â”€ auth.py
â”‚   â”‚   â””â”€â”€ game.py
â”‚   â”œâ”€â”€ saves
â”‚   â”‚   â””â”€â”€ mundo_5e946bdf-961d-43dd-8b5b-6284733ef02b.json
â”‚   â”œâ”€â”€ services
â”‚   â”‚   â”œâ”€â”€ matchmaking_service.py
â”‚   â”‚   â”œâ”€â”€ queue_service.py
â”‚   â”‚   â”œâ”€â”€ user_service.py
â”‚   â”‚   â””â”€â”€ world_pool.py
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ app.py
â”‚   â”œâ”€â”€ aws_loader.py
â”‚   â”œâ”€â”€ commander.py
â”‚   â”œâ”€â”€ config.py
â”‚   â”œâ”€â”€ extensions.py
â”‚   â”œâ”€â”€ initializer.py
â”‚   â”œâ”€â”€ interface.py
â”‚   â”œâ”€â”€ manager.py
â”‚   â”œâ”€â”€ registrar_players.py
â”‚   â”œâ”€â”€ sei_la_o_que.py
â”‚   â”œâ”€â”€ serialization.py
â”‚   â”œâ”€â”€ signals.py
â”‚   â””â”€â”€ simulador_players.py
â”œâ”€â”€ client
â”‚   â”œâ”€â”€ components
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â””â”€â”€ icon_manager.py
â”‚   â”œâ”€â”€ dialogs
â”‚   â”‚   â””â”€â”€ auth_dialog.py
â”‚   â”œâ”€â”€ resources
â”‚   â”‚   â”œâ”€â”€ arrow-left.png
â”‚   â”‚   â”œâ”€â”€ log-in.png
â”‚   â”‚   â”œâ”€â”€ play.png
â”‚   â”‚   â””â”€â”€ smile.png
â”‚   â”œâ”€â”€ states
â”‚   â”‚   â””â”€â”€ __init__.py
â”‚   â””â”€â”€ main.py
â”œâ”€â”€ shared
â”‚   â”œâ”€â”€ civilization.py
â”‚   â”œâ”€â”€ geography.py
â”‚   â”œâ”€â”€ planet.py
â”‚   â”œâ”€â”€ polygons.py
â”‚   â”œâ”€â”€ province.py
â”‚   â”œâ”€â”€ references.py
â”‚   â””â”€â”€ world.py

================================================================================
ğŸ“„ CONTEÃšDO DOS ARQUIVOS
================================================================================

================================================================================
ğŸ“„ server/commander.py
================================================================================
# server/commander.py
import queue
import threading
import time
import uuid
import random
from typing import Callable, Optional
from server.signals import WorkerSignals
from server.manager import Gerenciador
from server.initializer import InicializadorAWS


class Comando:
    def __init__(
        self,
        nome: str,
        callback: Callable,
        args=None,
        kwargs=None,
        on_success: Callable = None,
        on_error: Callable = None,
        signals: Optional[WorkerSignals] = None  # âœ… Novo: sinais PyQt6
    ):
        self.id = str(uuid.uuid4())[:8]
        self.nome = nome
        self.callback = callback
        self.args = args or ()
        self.kwargs = kwargs or {}
        self.on_success = on_success  # âš ï¸ Evite UI aqui
        self.on_error = on_error      # âš ï¸ Evite UI aqui
        self.signals = signals        # âœ… Use para UI segura
        self.timestamp = time.time()

    def __repr__(self):
        return f"<Comando(id={self.id}, nome='{self.nome}')>"


class Comandante:
    """
    Orquestrador de operaÃ§Ãµes de domÃ­nio.
    Deve ser usado pela interface grÃ¡fica para disparar aÃ§Ãµes assÃ­ncronas.
    Nunca deve conter lÃ³gica de UI.
    """
    def __init__(self, gerenciador: Gerenciador, aws_loader):
        self.gerenciador = gerenciador
        self.aws_loader = aws_loader
        self.fila = queue.Queue()
        self.ativo = True
        self.thread = threading.Thread(target=self._loop, daemon=True)
        # ğŸ” Estado da simulaÃ§Ã£o
        self.simulacao_ativa = False
        self.thread_simulacao: Optional[threading.Thread] = None

    def iniciar(self):
        """Inicia a thread de processamento de comandos."""
        self.thread.start()
        print("âœ… Comandante iniciado. Pronto para executar comandos.")

    def parar(self, timeout: float = 2.0):
        """Para o loop de comandos de forma segura."""
        self.ativo = False
        while not self.fila.empty():
            try:
                self.fila.get_nowait()
            except queue.Empty:
                break
        self.thread.join(timeout=timeout)
        if self.thread.is_alive():
            print("âš ï¸ Thread do Comandante nÃ£o encerrou a tempo.")
        else:
            print("ğŸ›‘ Comandante parado com sucesso.")

    def _loop(self):
        """Loop principal: executa comandos da fila."""
        while self.ativo:
            try:
                comando = self.fila.get(timeout=0.2)
                print(f"âš™ï¸ Executando [{comando.id}]: {comando.nome}")
                try:
                    resultado = comando.callback(*comando.args, **comando.kwargs)
                    print(f"âœ… [{comando.id}] {comando.nome} concluÃ­do.")

                    # âœ… Primeiro: emitir sinais (seguro para UI)
                    if comando.signals:
                        comando.signals.success.emit(resultado)
                        comando.signals.finished.emit()

                    # âš ï¸ Segundo: callbacks (cuidado! estÃ£o na thread secundÃ¡ria)
                    if comando.on_success:
                        try:
                            comando.on_success(resultado)
                        except Exception as cb_e:
                            print(f"âš ï¸ Erro no callback on_success: {cb_e}")

                except Exception as e:
                    print(f"âŒ [{comando.id}] Erro em '{comando.nome}': {e}")

                    # âœ… Sinais de erro
                    if comando.signals:
                        comando.signals.error.emit(str(e))
                        comando.signals.finished.emit()

                    # âš ï¸ Callbacks de erro
                    if comando.on_error:
                        try:
                            comando.on_error(str(e))
                        except Exception as cb_e:
                            print(f"âš ï¸ Erro no callback on_error: {cb_e}")

                finally:
                    self.fila.task_done()

            except queue.Empty:
                continue

    def _enviar_comando(self, nome: str, callback: Callable, *args, **kwargs):
        """
        MÃ©todo auxiliar para criar e enviar um comando.
        Aceita on_success, on_error e signals nos kwargs.
        """
        on_success = kwargs.pop('on_success', None)
        on_error = kwargs.pop('on_error', None)
        signals = kwargs.pop('signals', None)  # âœ… Extrai os sinais

        comando = Comando(
            nome=nome,
            callback=callback,
            args=args,
            kwargs=kwargs,
            on_success=on_success,
            on_error=on_error,
            signals=signals  # âœ… Passa os sinais
        )
        self.fila.put(comando)

    # â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
    # Comandos de DomÃ­nio
    # â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

    def criar_e_upload_mundo(
        self,
        fator: int,
        bioma: str,
        bucket_name: str = "global-arena-tiles",
        s3_prefix: str = "planetas/",
        dynamodb_table_name: str = "GlobalArena",
        on_success: Callable = None,
        on_error: Callable = None,
        signals: Optional[WorkerSignals] = None  # âœ… Novo parÃ¢metro
    ):
        """Comando: cria e faz upload de um novo mundo."""
        def task():
            sucesso, mundo = self.gerenciador.criar_e_upload_mundo_com_retorno(
                fator=fator,
                bioma=bioma,
                bucket_name=bucket_name,
                s3_prefix=s3_prefix,
                dynamodb_table_name=dynamodb_table_name
            )
            return sucesso, mundo

        self._enviar_comando(
            nome=f"Criar e Upload Mundo (fator={fator}, bioma={bioma})",
            callback=task,
            on_success=on_success,
            on_error=on_error,
            signals=signals  # âœ… Passa os sinais
        )

    def reinicializar_infra(
        self,
        confirmar: bool = False,
        on_success: Callable = None,
        on_error: Callable = None,
        signals: Optional[WorkerSignals] = None  # âœ… Novo parÃ¢metro
    ):
        """Comando: reinicializa a infra AWS (S3 + DynamoDB)."""
        def task():
            inicializador = InicializadorAWS(self.aws_loader)
            sucesso = inicializador.inicializar(confirmar=confirmar)
            return sucesso

        self._enviar_comando(
            nome="Reinicializar Infra AWS",
            callback=task,
            on_success=on_success,
            on_error=on_error,
            signals=signals  # âœ… Passa os sinais
        )

    def testar_conexao_aws(
        self,
        on_success: Callable = None,
        on_error: Callable = None,
        signals: Optional[WorkerSignals] = None  # âœ… Novo parÃ¢metro
    ):
        """Comando: testa conexÃ£o com AWS (conta, S3, DynamoDB)."""
        def task():
            try:
                account = self.aws_loader.get_account_info()
                buckets = self.aws_loader.list_s3_buckets()
                tables = self.aws_loader.list_dynamodb_tables()
                return {
                    'success': True,
                    'account': account,
                    'buckets': buckets,
                    'tables': tables
                }
            except Exception as e:
                raise e

        self._enviar_comando(
            nome="Testar ConexÃ£o AWS",
            callback=task,
            on_success=on_success,
            on_error=on_error,
            signals=signals  # âœ… Passa os sinais
        )

    def iniciar_simulacao_players(self, signals: Optional[WorkerSignals] = None):
        """Inicia a simulaÃ§Ã£o de players online."""
        def task():
            if self.simulacao_ativa:
                return

            self.simulacao_ativa = True
            contador = 0

            def entrar_na_fila(usuario):
                nonlocal contador
                try:
                    import requests
                    print(f"ğŸ”„ [Comandante] Tentando login com: {usuario['username']}")  # â† Novo log
                    response = requests.post("http://localhost:5000/auth/login", json=usuario)
                    if response.status_code == 200:
                        token = response.json().get("token")
                        headers = {"Authorization": f"Bearer {token}"} if token else {}
                        print(f"ğŸ”„ [Comandante] {usuario['username']} logado. Tentando entrar na fila...")  # â† Novo log

                        # Chamada para /jogo/entrar
                        response_entrar = requests.post(
                            "http://localhost:5000/jogo/entrar",
                            json={"modo": "online", "username": usuario["username"]},
                            headers=headers
                        )

                        # âœ… Log da resposta
                        print(
                            f"ğŸ“¨ Resposta de /jogo/entrar para {usuario['username']}: {response_entrar.status_code} - {response_entrar.text}")

                        if response_entrar.status_code == 200:
                            contador += 1
                            if signals:
                                signals.success.emit(f"âœ… {usuario['username']} entrou na fila ({contador})")
                        else:
                            print(f"âŒ Falha ao entrar na fila: {response_entrar.text}")
                    else:
                        print(f"âŒ Login falhou para {usuario['username']}: {response.text}")

                except Exception as e:
                    print(f"âŒ Erro ao processar {usuario['username']}: {e}")
                    if signals:
                        signals.error.emit(f"âŒ Falha com {usuario['username']}")

            USUARIOS_SIMULADOS = [{"username": f"player{i:03d}", "password": "senha123"} for i in range(1, 51)]

            while self.simulacao_ativa:
                usuario = random.choice(USUARIOS_SIMULADOS)
                thread = threading.Thread(target=entrar_na_fila, args=(usuario,), daemon=True)
                thread.start()
                time.sleep(random.uniform(1.0, 3.0))

            if signals:
                signals.success.emit("ğŸ›‘ SimulaÃ§Ã£o encerrada.")

        self._enviar_comando(
            nome="Simular Players Online",
            callback=task,
            on_success=lambda msg: signals.success.emit(msg) if signals else None,
            on_error=lambda err: signals.error.emit(err) if signals else None,
            signals=signals
        )

    def parar_simulacao_players(self):
        """Para a simulaÃ§Ã£o de players."""
        self.simulacao_ativa = False

================================================================================
ğŸ“„ server/initializer.py
================================================================================
# server/initializer.py
"""
MÃ³dulo para inicializar ou reinicializar a infraestrutura AWS:
- Cria/recria a tabela DynamoDB 'GlobalArena' com PK/SK.
- Limpa os dados no S3 nos prefixos usados.
- Garante que o bucket S3 exista.

Pode ser executado como script: python server/inicializador.py
"""

import boto3
from botocore.exceptions import ClientError
from typing import Dict
from server.aws_loader import AWSLoader


class InicializadorAWS:
    def __init__(self, aws_loader: AWSLoader):
        self.aws_loader = aws_loader
        self.dynamodb = self.aws_loader.get_client('dynamodb')
        self.s3 = self.aws_loader.get_client('s3')
        self.bucket_name = "global-arena-tiles"
        self.region = aws_loader.region_name

    def inicializar(self, confirmar: bool = True):
        """
        Inicializa ou reinicializa toda a infraestrutura.
        :param confirmar: Se True, pede confirmaÃ§Ã£o antes de apagar dados.
        """
        if confirmar:
            resposta = input(
                "âš ï¸  Isso apagarÃ¡ todos os mundos e metadados no S3 e DynamoDB.\n"
                "Deseja continuar? (s/N): "
            )
            if resposta.lower() not in ['s', 'sim', 'y', 'yes']:
                print("âŒ OperaÃ§Ã£o cancelada.")
                return False

        print("ğŸ”„ Inicializando infraestrutura AWS...")

        try:
            # 1. Garantir que o bucket S3 existe
            self._criar_bucket_se_nao_existir()

            # 2. Limpar dados no S3
            prefixos = ["planetas/", "saves/"]
            for prefix in prefixos:
                self._limpar_prefixo_s3(prefix)

            # 3. Recriar tabela DynamoDB (Ãºnica: GlobalArena)
            self._recriar_tabela_globalarena()

            print("âœ… Infraestrutura AWS reinicializada com sucesso!")
            return True

        except Exception as e:
            print(f"âŒ Erro ao inicializar infraestrutura: {e}")
            return False

    def _criar_bucket_se_nao_existir(self):
        """Cria o bucket S3 se ele nÃ£o existir."""
        try:
            self.s3.head_bucket(Bucket=self.bucket_name)
            print(f"â„¹ï¸  Bucket S3 '{self.bucket_name}' jÃ¡ existe.")
        except ClientError:
            print(f"ğŸ“¦ Criando bucket S3 '{self.bucket_name}'...")
            try:
                if self.region == "us-east-1":
                    self.s3.create_bucket(Bucket=self.bucket_name)
                else:
                    self.s3.create_bucket(
                        Bucket=self.bucket_name,
                        CreateBucketConfiguration={'LocationConstraint': self.region}
                    )
                print(f"âœ… Bucket '{self.bucket_name}' criado com sucesso.")
            except ClientError as e:
                print(f"âŒ Falha ao criar bucket: {e}")
                raise

    def _limpar_prefixo_s3(self, prefix: str):
        """Remove todos os objetos com o prefixo dado no S3."""
        print(f"ğŸ§¹ Limpando S3: s3://{self.bucket_name}/{prefix}")
        paginator = self.s3.get_paginator('list_objects_v2')
        apagados = 0

        try:
            pages = paginator.paginate(Bucket=self.bucket_name, Prefix=prefix)
            for page in pages:
                if 'Contents' not in page:
                    continue
                keys = [{'Key': obj['Key']} for obj in page['Contents']]
                if keys:
                    self.s3.delete_objects(Bucket=self.bucket_name, Delete={'Objects': keys})
                    apagados += len(keys)
            print(f"âœ… {apagados} objetos apagados no prefixo '{prefix}'.")
        except ClientError as e:
            print(f"âŒ Erro ao limpar S3 no prefixo '{prefix}': {e}")

    def _recriar_tabela_globalarena(self):
        """Deleta e recria a tabela GlobalArena com PK/SK."""
        table_name = "GlobalArena"
        try:
            print(f"ğŸ” Verificando tabela '{table_name}'...")
            self.dynamodb.describe_table(TableName=table_name)
            print(f"ğŸ—‘ï¸  Tabela '{table_name}' encontrada. Deletando...")
            self.dynamodb.delete_table(TableName=table_name)

            # Aguardar exclusÃ£o
            waiter = self.dynamodb.get_waiter('table_not_exists')
            waiter.wait(TableName=table_name, WaiterConfig={'Delay': 2, 'MaxAttempts': 30})
            print(f"âœ… Tabela '{table_name}' deletada.")
        except ClientError as e:
            if e.response['Error']['Code'] != 'ResourceNotFoundException':
                raise e
            print(f"â„¹ï¸  Tabela '{table_name}' nÃ£o existe. SerÃ¡ criada.")

        # Criar tabela com PK/SK
        print(f"ğŸ†• Criando tabela '{table_name}' com PK/SK...")
        try:
            self.dynamodb.create_table(
                TableName=table_name,
                AttributeDefinitions=[
                    {'AttributeName': 'PK', 'AttributeType': 'S'},
                    {'AttributeName': 'SK', 'AttributeType': 'S'}
                ],
                KeySchema=[
                    {'AttributeName': 'PK', 'KeyType': 'HASH'},
                    {'AttributeName': 'SK', 'KeyType': 'RANGE'}
                ],
                BillingMode='PAY_PER_REQUEST'
            )

            # Aguardar ativaÃ§Ã£o
            waiter = self.dynamodb.get_waiter('table_exists')
            waiter.wait(TableName=table_name, WaiterConfig={'Delay': 2, 'MaxAttempts': 30})
            print(f"âœ… Tabela '{table_name}' criada e ativa.")
        except ClientError as e:
            print(f"âŒ Falha ao criar tabela '{table_name}': {e}")
            raise


# ========================== CLI ==========================
if __name__ == "__main__":
    """
    ExecuÃ§Ã£o direta do mÃ³dulo:
    $ python server/inicializador.py
    """
    print("ğŸ”§ Inicializador AWS - ReinicializaÃ§Ã£o de Infraestrutura\n")

    # Cria o loader AWS
    try:
        aws_loader = AWSLoader()
        print(f"âœ… Conectado Ã  AWS (regiÃ£o: {aws_loader.region_name})")
    except Exception as e:
        print(f"âŒ Falha ao conectar Ã  AWS: {e}")
        exit(1)

    # Inicializa
    inicializador = InicializadorAWS(aws_loader)
    inicializador.inicializar(confirmar=True)

================================================================================
ğŸ“„ server/extensions.py
================================================================================
# server/extensions.py
from server.aws_loader import AWSLoader

class Extensions:
    def __init__(self):
        self.dynamodb = None
        # self.redis = None # Futuro

    def init_app(self, app):
        """Inicializa as extensÃµes com base na configuraÃ§Ã£o da app Flask."""
        try:
            aws_loader = AWSLoader(
                profile_name=app.config['AWS_PROFILE_NAME'],
                region_name=app.config['AWS_REGION_NAME']
            )
            self.dynamodb = aws_loader.get_client('dynamodb')
            print("âœ… Cliente DynamoDB conectado via Extensions.")
        except Exception as e:
            print(f"âŒ Falha ao conectar ao DynamoDB na inicializaÃ§Ã£o: {e}")
            self.dynamodb = None # Ou lanÃ§ar exceÃ§Ã£o, dependendo da polÃ­tica de falhas

# InstÃ¢ncia global
ext = Extensions()

================================================================================
ğŸ“„ server/sei_la_o_que.py
================================================================================
# sei_la_o_que.py

from aws_loader import AWSLoader  # ou from server.aws_loader import AWSLoader

def main():
    print("ğŸš€ Iniciando aplicaÃ§Ã£o...\n")

    # --- ConfiguraÃ§Ã£o ---
    loader = AWSLoader(
        region_name='us-east-2',
        # profile_name='seu-perfil'  # opcional
    )

    # --- 1. InformaÃ§Ãµes da conta ---
    try:
        account = loader.get_account_info()
        print(f"âœ… Logado na conta AWS: {account['account_id']}")
        print(f"ğŸ‘¤ UsuÃ¡rio/Role: {account['arn']}\n")
    except Exception as e:
        print(f"âŒ Falha ao obter conta: {e}")
        return

    # --- 2. Listar buckets S3 ---
    try:
        buckets = loader.list_s3_buckets()
        print(f"ğŸ“¦ Buckets S3 encontrados ({len(buckets)}):")
        for bucket in buckets:
            print(f"  - {bucket}")
    except Exception as e:
        print(f"âŒ Erro ao listar buckets S3: {e}")

    # --- 3. Listar tabelas DynamoDB ---
    try:
        tables = loader.list_dynamodb_tables()
        print(f"\nğŸ“Š Tabelas DynamoDB encontradas ({len(tables)}):")
        for table in tables:
            print(f"  - {table}")
    except Exception as e:
        print(f"âŒ Erro ao listar tabelas DynamoDB: {e}")

    # --- 4. Exemplo: usar cliente S3 ---
    try:
        s3 = loader.get_client('s3')
        response = s3.list_buckets()
        print(f"\nğŸŒ ConexÃ£o S3 bem-sucedida. Total de buckets: {len(response['Buckets'])}")
    except Exception as e:
        print(f"âŒ Falha ao usar cliente S3: {e}")


if __name__ == "__main__":
    main()

================================================================================
ğŸ“„ server/simulador_players.py
================================================================================
# server/simulador_players.py
import requests
import random
import time
import threading

# ConfiguraÃ§Ã£o
URL_BASE = "http://localhost:5000"
NUM_PLAYERS = 50  # Quantidade de players simulados: player001 atÃ© player050

# Gera usuÃ¡rios dinamicamente
USUARIOS_SIMULADOS = [{"username": f"player{i:03d}", "password": "senha123"} for i in range(1, 51)]
print("ğŸ¯ Simulador carregado com formatos: player001, player002, ...")

def registrar_usuario(usuario):
    """Tenta registrar o usuÃ¡rio no servidor."""
    try:
        response = requests.post(f"{URL_BASE}/auth/registrar", json=usuario, timeout=3)
        data = response.json()
        if data.get("success"):
            print(f"ğŸ†• Registrado: {usuario['username']}")
            return True
        else:
            # Pode jÃ¡ existir â†’ nÃ£o Ã© erro
            if "jÃ¡ estÃ¡ em uso" in data.get("message", ""):
                return True
            print(f"âŒ Falha ao registrar {usuario['username']}: {data.get('message')}")
            return False
    except Exception as e:
        print(f"âš ï¸ Erro ao registrar {usuario['username']}: {e}")
        return False

def login_usuario(usuario):
    """Tenta fazer login. Se falhar por usuÃ¡rio nÃ£o encontrado, tenta registrar."""
    try:
        response = requests.post(f"{URL_BASE}/auth/login", json=usuario, timeout=3)
        data = response.json()

        if data.get("success"):
            print(f"âœ… {usuario['username']} logou com sucesso.")
            return data.get("token")  # futuro: JWT
        else:
            mensagem = data.get("message", "")
            if "nÃ£o encontrado" in mensagem:
                print(f"ğŸ” {usuario['username']} nÃ£o existe. Tentando registrar...")
                if registrar_usuario(usuario):
                    return login_usuario(usuario)  # Tenta logar novamente apÃ³s registrar
            else:
                print(f"âŒ {usuario['username']} falhou: {mensagem}")
        return None
    except requests.exceptions.ConnectionError:
        print("ğŸ›‘ Erro: NÃ£o foi possÃ­vel conectar ao servidor. Certifique-se de que o servidor estÃ¡ rodando em http://localhost:5000")
        return None
    except Exception as e:
        print(f"âš ï¸ Erro inesperado ao logar {usuario['username']}: {e}")
        return None

def entrar_na_fila(usuario):
    """ApÃ³s login, entra na fila de jogo online."""
    token = login_usuario(usuario)
    if not token:
        return

    headers = {"Authorization": f"Bearer {token}"} if token else {}
    try:
        response = requests.post(
            f"{URL_BASE}/jogo/entrar",
            json={"modo": "online", "username": usuario["username"]},
            headers=headers,
            timeout=3
        )
        data = response.json()
        print(f"ğŸ® {usuario['username']} â†’ {data.get('message')}")
    except Exception as e:
        print(f"âš ï¸ Falha ao entrar na fila: {e}")

def simular_entrada_periodica(intervalo_min=2, intervalo_max=5):
    """
    Simula entrada periÃ³dica e aleatÃ³ria de players no sistema.
    Cada player tenta:
    1. Logar (ou se registrar, se necessÃ¡rio)
    2. Entrar na fila de matchmaking
    """
    print(f"ğŸ”„ Iniciando simulaÃ§Ã£o com {len(USUARIOS_SIMULADOS)} players...")
    print(f"ğŸ’¡ Intervalo: {intervalo_min}s a {intervalo_max}s entre tentativas")
    print("â„¹ï¸  Pressione Ctrl+C para parar.")

    while True:
        usuario = random.choice(USUARIOS_SIMULADOS)
        thread = threading.Thread(target=entrar_na_fila, args=(usuario,), daemon=True)
        thread.start()
        time.sleep(random.uniform(intervalo_min, intervalo_max))

if __name__ == "__main__":
    print("ğŸš€ Iniciando simulador de players online...")
    try:
        simular_entrada_periodica(intervalo_min=1.5, intervalo_max=4.0)
    except KeyboardInterrupt:
        print("\nğŸ›‘ SimulaÃ§Ã£o encerrada pelo usuÃ¡rio.")
    except Exception as e:
        print(f"\nâŒ Erro inesperado: {e}")

================================================================================
ğŸ“„ server/registrar_players.py
================================================================================
# server/registrar_players.py
import requests

# Lista de players a serem registrados
USUARIOS = [
    {"username": f"player{i:03d}", "password": "senha123"} for i in range(1, 51)
]

print("ğŸ“ Registrando 50 players de teste...")

for usuario in USUARIOS:
    response = requests.post("http://localhost:5000/auth/registrar", json=usuario)
    data = response.json()
    if data.get("success"):
        print(f"âœ… {usuario['username']} registrado com sucesso.")
    else:
        # Pode jÃ¡ existir â†’ nÃ£o Ã© erro
        if "jÃ¡ existe" in data.get("message", ""):
            print(f"ğŸ” {usuario['username']} jÃ¡ registrado.")
        else:
            print(f"âŒ Falha ao registrar {usuario['username']}: {data['message']}")

================================================================================
ğŸ“„ server/__init__.py
================================================================================


================================================================================
ğŸ“„ server/aws_loader.py
================================================================================
# aws_loader.py

import boto3
from botocore.exceptions import NoCredentialsError, PartialCredentialsError


class AWSLoader:
    def __init__(self, profile_name=None, region_name='us-east-2'):
        """
        Inicializa o loader de credenciais AWS.

        :param profile_name: Nome do perfil no arquivo ~/.aws/credentials (opcional)
        :param region_name: RegiÃ£o AWS padrÃ£o
        """
        self.profile_name = profile_name
        self.region_name = region_name
        self.session = None
        self._create_session()

    def _create_session(self):
        """Cria uma sessÃ£o boto3 com base no perfil ou nas credenciais padrÃ£o."""
        try:
            if self.profile_name:
                self.session = boto3.Session(profile_name=self.profile_name, region_name=self.region_name)
            else:
                self.session = boto3.Session(region_name=self.region_name)

            # Testa credenciais
            sts = self.session.client('sts')
            sts.get_caller_identity()
            print("âœ… Credenciais AWS carregadas com sucesso.")

        except NoCredentialsError:
            raise Exception("âŒ Credenciais AWS nÃ£o encontradas. Configure AWS_ACCESS_KEY_ID e AWS_SECRET_ACCESS_KEY.")
        except PartialCredentialsError:
            raise Exception("âŒ Credenciais incompletas. Verifique AWS_ACCESS_KEY_ID e AWS_SECRET_ACCESS_KEY.")
        except Exception as e:
            raise Exception(f"âŒ Erro ao carregar credenciais: {e}")

    def get_credentials(self):
        """
        Retorna as credenciais (access key, secret key, token).
        """
        credentials = self.session.get_credentials()
        frozen_creds = credentials.get_frozen_credentials()
        return {
            'access_key': frozen_creds.access_key,
            'secret_key': frozen_creds.secret_key,
            'token': frozen_creds.token
        }

    def get_client(self, service_name):
        """Retorna um cliente boto3 para o serviÃ§o especificado."""
        return self.session.client(service_name)

    def get_resource(self, service_name):
        """Retorna um recurso boto3 (ex: S3 resource)."""
        return self.session.resource(service_name)

    # --- ğŸ”§ Novos mÃ©todos adicionados ---
    def get_account_info(self):
        """Retorna informaÃ§Ãµes da conta AWS: ID, ARN, usuÃ¡rio, regiÃ£o."""
        sts = self.session.client('sts')
        identity = sts.get_caller_identity()
        return {
            'account_id': identity['Account'],
            'user_id': identity['UserId'],
            'arn': identity['Arn'],
            'region': self.region_name
        }

    def list_s3_buckets(self):
        """Lista todos os buckets S3 da conta."""
        s3 = self.get_client('s3')
        response = s3.list_buckets()
        return [bucket['Name'] for bucket in response['Buckets']]

    def list_dynamodb_tables(self):
        """Lista todas as tabelas DynamoDB da conta."""
        dynamodb = self.get_client('dynamodb')
        response = dynamodb.list_tables()
        return response['TableNames']

================================================================================
ğŸ“„ server/manager.py
================================================================================
# server/manager.py
import json
import time
from pathlib import Path
from typing import Optional, Tuple

from server.serialization import Serializador
from server.aws_loader import AWSLoader
from shared.world import Mundo


class Gerenciador:
    """
    Gerencia operaÃ§Ãµes de mundo: criaÃ§Ã£o, serializaÃ§Ã£o, upload S3 e salvamento de metadados no DynamoDB.
    Nada Ã© salvo localmente.
    """

    def __init__(self, aws_loader: AWSLoader, save_dir: str = "saves"):
        self.aws_loader = aws_loader
        self.save_dir = Path(save_dir)
        self.save_dir.mkdir(exist_ok=True)  # Mantido para compatibilidade futura

    # server/manager.py

    def upload_mundo(self,
                     mundo: Mundo,
                     bucket_name: str = "global-arena-tiles",
                     s3_prefix: str = "planetas/",
                     dynamodb_table_name: str = "GlobalArena") -> bool:
        """
        Faz upload do mundo: dados pesados para S3, metadados leves para DynamoDB.
        Agora com rollback se falhar no DynamoDB.
        """
        try:
            pk = f"PLANET#{mundo.id_mundo}"
            sk = "METADATA"
            s3_key = f"{s3_prefix}{mundo.id_mundo}.json"

            # --- Verificar se jÃ¡ existe no DynamoDB ---
            dynamodb = self.aws_loader.get_client('dynamodb')
            response = dynamodb.get_item(
                TableName=dynamodb_table_name,
                Key={'PK': {'S': pk}, 'SK': {'S': sk}}
            )
            if 'Item' in response:
                print(f"âŒ Mundo com ID {mundo.id_mundo} jÃ¡ existe no DynamoDB.")
                return False

            # --- Serializar e enviar para S3 ---
            dados_s3 = Serializador.to_serializable_dict(mundo)
            dados_json = json.dumps(dados_s3, ensure_ascii=False, indent=2)

            s3 = self.aws_loader.get_client('s3')
            s3.put_object(
                Bucket=bucket_name,
                Key=s3_key,
                Body=dados_json,
                ContentType='application/json'
            )
            print(f"âœ… Upload para S3 concluÃ­do: s3://{bucket_name}/{s3_key}")

            # --- Salvar metadados no DynamoDB ---
            try:
                bioma_inicial = getattr(mundo.planeta, 'bioma_inicial', 'Desconhecido')
                vagas = getattr(mundo.planeta, 'numero_de_jogadores', 0)

                dynamodb.put_item(
                    TableName=dynamodb_table_name,
                    Item={
                        'PK': {'S': pk},
                        'SK': {'S': sk},
                        'entityType': {'S': 'Planet'},
                        'fator': {'N': str(mundo.planeta.fator)},
                        'bioma_inicial': {'S': bioma_inicial},
                        'vagas': {'N': str(vagas)},
                        'timestamp': {'N': str(int(time.time()))}
                    }
                )
                print(f"âœ… Metadados do mundo {mundo.id_mundo} salvos no DynamoDB.")
                return True

            except Exception as e:
                print(f"âŒ Falha ao salvar no DynamoDB: {e}")
                print(f"ğŸ§¹ Removendo arquivo Ã³rfÃ£o do S3: s3://{bucket_name}/{s3_key}")
                try:
                    s3.delete_object(Bucket=bucket_name, Key=s3_key)
                    print("âœ… Arquivo Ã³rfÃ£o removido com sucesso.")
                except Exception as del_e:
                    print(f"âš ï¸ Falha ao remover arquivo Ã³rfÃ£o do S3: {del_e}")
                return False

        except Exception as e:
            print(f"âŒ Erro inesperado durante upload_mundo: {e}")
            return False

    def criar_e_upload_mundo(
        self,
        fator: int,
        bioma: str,
        bucket_name: str = "global-arena-tiles",
        s3_prefix: str = "planetas/"
    ) -> bool:
        """
        Cria um novo mundo com fator e bioma dados, e faz upload direto para S3 + DynamoDB.

        :param fator: NÃ­vel de detalhe da grade geogrÃ¡fica (ex: 4)
        :param bioma: Bioma inicial para escolha de capitais (ex: "Meadow")
        :param bucket_name: Nome do bucket S3
        :param s3_prefix: Prefixo (pasta) no bucket
        :return: True se sucesso, False caso contrÃ¡rio
        """
        try:
            print(f"ğŸŒ Criando mundo com fator={fator}, bioma='{bioma}'...")
            mundo = Mundo(fator=fator, bioma=bioma)
            print(f"âœ… Mundo criado: {mundo.id_mundo}")

            sucesso = self.upload_mundo(mundo, bucket_name=bucket_name, s3_prefix=s3_prefix)

            if sucesso:
                print(f"ğŸ‰ Mundo {mundo.id_mundo} enviado com sucesso para a nuvem!")
            else:
                print(f"âŒ Falha no upload do mundo {mundo.id_mundo}")

            return sucesso

        except Exception as e:
            print(f"âŒ Erro ao criar e upload mundo: {e}")
            return False

    def criar_e_upload_mundo_com_retorno(
            self,
            fator: int,
            bioma: str,
            bucket_name: str = "global-arena-tiles",
            s3_prefix: str = "planetas/",
            dynamodb_table_name: str = "GlobalArena"
    ) -> Tuple[bool, Optional[Mundo]]:
        """
        Cria um novo mundo com fator e bioma dados, faz upload para S3 + DynamoDB,
        e retorna sucesso e a instÃ¢ncia do mundo.
        """
        try:
            print(f"ğŸŒ Criando mundo com fator={fator}, bioma='{bioma}'...")
            mundo = Mundo(fator=fator, bioma=bioma)
            print(f"âœ… Mundo criado: {mundo.id_mundo}")

            sucesso = self.upload_mundo(
                mundo,
                bucket_name=bucket_name,
                s3_prefix=s3_prefix,
                dynamodb_table_name=dynamodb_table_name
            )

            if sucesso:
                print(f"ğŸ‰ Mundo {mundo.id_mundo} enviado com sucesso para a nuvem!")
            else:
                print(f"âŒ Falha no upload do mundo {mundo.id_mundo}")

            return sucesso, mundo

        except Exception as e:
            print(f"âŒ Erro ao criar e upload mundo: {e}")
            import traceback
            traceback.print_exc()
            return False, None

    def criar_mundo(self, fator: int, bioma: str) -> Mundo:
        """Cria e retorna um novo mundo."""
        return Mundo(fator=fator, bioma=bioma)

================================================================================
ğŸ“„ server/signals.py
================================================================================
# server/signals.py
from PyQt6.QtCore import QObject, pyqtSignal

class WorkerSignals(QObject):
    """
    Define sinais para comunicaÃ§Ã£o segura com a thread da UI.
    Usado pelo Comandante para enviar feedback.
    """
    success = pyqtSignal(object)   # resultado
    error = pyqtSignal(str)        # mensagem de erro
    finished = pyqtSignal()        # operaÃ§Ã£o concluÃ­da

================================================================================
ğŸ“„ server/app.py
================================================================================
# server/app.py
from flask import Flask, jsonify
from server.config import config
from server.extensions import ext
from server.services.user_service import UserService
from server.routes.auth import auth_bp, register_routes
from server.routes.game import jogo_bp, register_jogo_routes
from server.services.matchmaking_service import MatchmakingService
from server.services.world_pool import MundoPoolService  # âœ… Importe o novo serviÃ§o
from server.aws_loader import AWSLoader
from server.manager import Gerenciador


def create_app(config_name='default'):
    """Factory function para criar a aplicaÃ§Ã£o Flask."""
    app = Flask(__name__)

    # 1. Carrega a configuraÃ§Ã£o
    app.config.from_object(config[config_name])

    # 2. Inicializa as extensÃµes
    ext.init_app(app)

    # 3. Cria instÃ¢ncias de serviÃ§os, injetando dependÃªncias
    user_service = UserService(ext.dynamodb, app.config['DYNAMODB_TABLE_NAME'])
    print(f"âœ… DEBUG: UserService criado: {user_service}")

    # --- ğŸ”¹ AWS Loader e Gerenciador de Mundos ---
    aws_loader = AWSLoader(
        profile_name=app.config.get('AWS_PROFILE_NAME'),
        region_name=app.config.get('AWS_REGION_NAME')
    )
    gerenciador = Gerenciador(aws_loader)

    # --- ğŸ”¹ World Pool: Gerencia mundos prÃ©-criados ---
    world_pool = MundoPoolService(
        gerenciador=gerenciador,
        fator=4,
        bioma="Meadow",
        tamanho_inicial=3,
        max_mundos=10
    )

    # --- ğŸ”¹ Matchmaking: Sistema AvanÃ§ado de Salas ---
    # MatchmakingService agora recebe o world_pool, nÃ£o o gerenciador diretamente
    matchmaking_service = MatchmakingService(world_pool=world_pool)

    # Callback para quando uma partida for formada
    def partida_formada(jogadores):
        print(f"\nğŸ‰ğŸ‰ğŸ‰ PARTIDA INICIADA COM: {jogadores}")
        print(f"ğŸ® Os jogadores estÃ£o prontos para o combate!\n")
        # Aqui vocÃª pode:
        # - Notificar jogadores via WebSocket
        # - Registrar a partida no DynamoDB
        # - Iniciar a lÃ³gica do jogo

    # âœ… Registra o callback no novo serviÃ§o
    matchmaking_service.partida_iniciada_callback = partida_formada

    app.config['USER_SERVICE'] = user_service

    # 4. Registra os Blueprints e injeta dependÃªncias
    print("ğŸ“‹ DEBUG: Iniciando injeÃ§Ã£o de dependÃªncias e registro de blueprints...")

    # --- ğŸ”¹ Auth ---
    print("ğŸ”§ DEBUG: Injetando UserService em auth_bp...")
    register_routes(user_service)
    print(f"âœ… DEBUG: register_routes(user_service) chamado com sucesso.")
    app.register_blueprint(auth_bp)
    print("âœ… DEBUG: auth_bp registrado no app.")

    # --- ğŸ”¹ Jogo Online (NOVO) ---
    register_jogo_routes(user_service, matchmaking_service)
    app.register_blueprint(jogo_bp)
    print("âœ… DEBUG: jogo_bp registrado no app.")

    # 5. Rotas principais (opcional)
    @app.route('/')
    def home():
        return "ğŸš€ Servidor Global Arena - API (Refatorado com Classes)", 200

    # ğŸ” Rota de status do matchmaking (monitoramento)
    @app.route('/status')
    def status():
        return jsonify({
            "mundos_no_pool": world_pool.quantidade_total(),
            "vagas_disponiveis": world_pool.quantidade_vagas(),
            "partidas_ativas": len(matchmaking_service.salas)
        })

    return app


# Para execuÃ§Ã£o direta (ex: python server/app.py)
if __name__ == '__main__':
    app = create_app('development')  # Ou 'production'
    print("ğŸš€ Iniciando Servidor Global Arena (Flask - Refatorado)...")
    print("ğŸ“„ Endpoints disponÃ­veis:")
    print("   GET  /                        - Status do servidor")
    print("   GET  /status                  - Status do matchmaking e pool de mundos")
    print("   GET  /auth/teste_dynamodb     - Teste de conexÃ£o com DynamoDB")
    print("   POST /jogo/entrar             - Entrar na fila de jogo online (novo)")
    print("-" * 40)
    app.run(host='127.0.0.1', port=5000, debug=app.config['DEBUG'])

================================================================================
ğŸ“„ server/config.py
================================================================================
# server/config.py
import os


class Config:
    # Flask
    SECRET_KEY = os.environ.get(
        'SECRET_KEY') or 'chave_secreta_dev_super_segura'  # Em produÃ§Ã£o, use variÃ¡vel de ambiente

    # AWS
    AWS_PROFILE_NAME = os.environ.get('AWS_PROFILE_NAME') or None
    AWS_REGION_NAME = os.environ.get('AWS_REGION_NAME') or 'us-east-2'  # Certifique-se de usar a mesma regiÃ£o

    # DynamoDB
    DYNAMODB_TABLE_NAME = os.environ.get(
        'DYNAMODB_TABLE_NAME') or 'GlobalArena'  # Ou 'UsuariosGlobalArena' se criar uma nova

    # Futuras configuraÃ§Ãµes (ex: Redis, Logging)
    # REDIS_URL = os.environ.get('REDIS_URL') or 'redis://localhost:6379/0'


class DevelopmentConfig(Config):
    DEBUG = True


class ProductionConfig(Config):
    DEBUG = False
    # SECRET_KEY = os.environ.get('SECRET_KEY') # ObrigatÃ³rio em produÃ§Ã£o


config = {
    'development': DevelopmentConfig,
    'production': ProductionConfig,
    'default': DevelopmentConfig
}

================================================================================
ğŸ“„ server/serialization.py
================================================================================
# server/serialization.py
import json
import networkx as nx
import numpy as np
from pathlib import Path
from typing import Any, Dict, Optional
from shared.world import Mundo
from shared.references import Referencias


class Serializador:
    """
    Classe responsÃ¡vel por serializar e desserializar o estado completo de um Mundo.
    Converte para dict serializÃ¡vel em JSON, salva em disco e recarrega.
    """

    @staticmethod
    def _convert(value: Any) -> Any:
        """
        Converte valores nÃ£o serializÃ¡veis em tipos compatÃ­veis com JSON.
        """
        if isinstance(value, np.integer):
            return int(value)
        if isinstance(value, np.floating):
            return float(value)
        if isinstance(value, np.ndarray):
            return value.tolist()
        if isinstance(value, tuple):
            return list(value)
        if hasattr(value, '__dict__'):
            return {k: Serializador._convert(v) for k, v in value.__dict__.items() if not k.startswith('_')}
        return value

    @classmethod
    def to_serializable_dict(cls, mundo: Mundo) -> Dict[str, Any]:
        """
        Converte um objeto Mundo em um dicionÃ¡rio compatÃ­vel com JSON.
        Remove atributos derivÃ¡veis para reduzir tamanho.
        """
        if not hasattr(mundo, 'planeta') or not hasattr(mundo, 'civs'):
            raise ValueError("Objeto mundo invÃ¡lido: falta atributos 'planeta' ou 'civs'")

        G = mundo.planeta.geografia.copy()

        # Atributos que podem ser recalculados, entÃ£o nÃ£o precisam ser salvos
        node_attrs_to_remove = {
            'cor_placa', 'cor_bioma', 'letra_grega', 'cust_mob', 'tipo', 'altitude', 'umidade', 'temperatura',
        }
        for node in G.nodes:
            for attr in node_attrs_to_remove:
                G.nodes[node].pop(attr, None)  # Remove silenciosamente

        # Remover arestas (serÃ£o recalculadas com custo de mobilidade)
        G.remove_edges_from(list(G.edges))

        # Converter atributos dos nÃ³s
        for node in G.nodes:
            attrs = G.nodes[node]
            for key in list(attrs.keys()):
                attrs[key] = cls._convert(attrs[key])

        # Usa 'edges="links"' para manter compatibilidade com o formato antigo
        # O padrÃ£o futuro serÃ¡ 'edges="edges"', mas queremos evitar mudanÃ§as inesperadas
        G_data = nx.node_link_data(G, edges="links")
        G_data.pop("directed", None)
        G_data.pop("multigraph", None)
        G_data.pop("graph", None)

        # Serializar civilizaÃ§Ãµes
        civilizacoes_data = []
        for civ in mundo.civs:
            civ_data = {
                'nome': civ.nome,
                'cultura': civ.cultura,
                'cor': cls._convert(civ.cor),
                'modalidade_bandeira': civ.modalidade_bandeira,
                'cores_bandeira': cls._convert(civ.cores_bandeira),
                'player': civ.player,
                'provincias': [
                    {
                        'coordenadas': cls._convert(p.coordenadas),
                        'nome': p.nome
                    }
                    for p in civ.provincias
                ]
            }
            civilizacoes_data.append(civ_data)

        return {
            "id_mundo": mundo.id_mundo,
            "fator": mundo.planeta.fator,
            "bioma_inicial": mundo.planeta.bioma_inicial,
            "vagas": mundo.planeta.numero_de_jogadores,
            "geografia": G_data,
            "civilizacoes": civilizacoes_data
        }

    @classmethod
    def from_serializable_dict(cls, data: Dict[str, Any], ref: Optional[Referencias] = None):
        """
        Reconstroi um objeto Mundo a partir de um dicionÃ¡rio.
        Requer uma instÃ¢ncia de Referencias para inicializaÃ§Ã£o.
        """
        """
        Ainda a ser implementado
        retorna Mundo
        """

    @classmethod
    def save_to_json(cls, mundo: Mundo, filepath: str) -> bool:
        try:
            data = cls.to_serializable_dict(mundo)
            path = Path(filepath)
            path.parent.mkdir(exist_ok=True, parents=True)
            with open(path, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
            print(f"âœ… Mundo salvo em JSON: {filepath}")
            return True
        except Exception as e:
            print(f"âŒ Falha ao salvar mundo: {e}")
            return False

    @classmethod
    def save_mundo(cls, mundo: Mundo, filepath: str = None) -> str:
        """
        Salva um objeto Mundo em JSON.
        Se filepath nÃ£o for fornecido, gera um nome automÃ¡tico em 'saves/'.
        :param mundo: InstÃ¢ncia de Mundo
        :param filepath: Caminho opcional para salvar
        :return: Caminho final usado, ou string vazia se falhar
        """
        from pathlib import Path

        if filepath is None:
            # Gera caminho padrÃ£o: saves/mundo_{id}.json
            saves_dir = Path("saves")
            saves_dir.mkdir(exist_ok=True)
            filepath = saves_dir / f"mundo_{mundo.id_mundo}.json"
        else:
            # Garante que o diretÃ³rio pai exista
            path = Path(filepath)
            path.parent.mkdir(exist_ok=True, parents=True)

        sucesso = cls.save_to_json(mundo, filepath)
        return str(filepath) if sucesso else ""

================================================================================
ğŸ“„ server/interface.py
================================================================================
# server/interface.py
import sys
from PyQt6.QtWidgets import (
    QApplication, QMainWindow, QTabWidget, QWidget, QVBoxLayout,
    QComboBox, QSpinBox, QMessageBox, QFormLayout, QGroupBox,
    QFileDialog, QTextEdit, QPushButton
)
from server.signals import WorkerSignals
from server.serialization import Serializador
from server.manager import Gerenciador
from server.aws_loader import AWSLoader
from server.commander import Comandante


class Interface(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Gerenciador de Servidor - Global Arena")
        self.setGeometry(100, 100, 700, 500)

        # === InicializaÃ§Ã£o de dependÃªncias ===
        try:
            self.aws_loader = AWSLoader()
            self.gerenciador = Gerenciador(self.aws_loader)
            print("âœ… Gerenciador inicializado com AWS.")
        except Exception as e:
            QMessageBox.critical(self, "Erro AWS", f"NÃ£o foi possÃ­vel conectar Ã  AWS:\n{e}")
            self.gerenciador = None

        # âœ… Inicializa o Comandante
        try:
            self.comandante = Comandante(self.gerenciador, self.aws_loader)
            self.comandante.iniciar()
            print("âœ… Comandante iniciado.")
        except Exception as e:
            QMessageBox.critical(self, "Erro", f"Falha ao iniciar o Comandante:\n{e}")
            self.comandante = None

        # âœ… Cria e conecta os sinais
        self.setup_signals()

        # âœ… Armazena o Ãºltimo mundo criado
        self.ultimo_mundo = None

        # ConfiguraÃ§Ã£o do sistema de abas
        self.tabs = QTabWidget()
        self.setCentralWidget(self.tabs)

        # âœ… Cria as abas
        self.backup_tab = self.create_backup_tab()
        self.config_tab = QWidget()
        self.tabs.addTab(self.backup_tab, "Backup & CriaÃ§Ã£o")
        self.tabs.addTab(self.config_tab, "ConfiguraÃ§Ãµes")

    def closeEvent(self, event):
        if self.comandante:
            self.comandante.parar()
        event.accept()

    def setup_signals(self):
        """Cria e conecta os sinais para comunicaÃ§Ã£o segura."""
        self.signals = WorkerSignals()
        self.signals.success.connect(self.on_success)
        self.signals.error.connect(self.on_error)
        self.signals.finished.connect(self.on_finished)

    def on_success(self, resultado):
        """Trata diferentes tipos de sucesso: criaÃ§Ã£o de mundo ou mensagens de log."""
        if isinstance(resultado, tuple):
            # Caso 1: resultado de upload de mundo (sucesso, mundo)
            try:
                sucesso, mundo = resultado
                if sucesso:
                    self.ultimo_mundo = mundo
                    QMessageBox.information(
                        self, "Sucesso", f"Mundo {mundo.id_mundo} criado e enviado!"
                    )
                else:
                    QMessageBox.critical(self, "Falha", "Upload falhou.")
            except Exception as e:
                print(f"âŒ Erro ao processar resultado de upload: {e}")
        else:
            # Caso 2: mensagem de log (ex: simulaÃ§Ã£o de players)
            self.log_output.append(f"ğŸŸ¢ {resultado}")  # Exibe no widget de log
            print(f"ğŸŸ¢ {resultado}")  # TambÃ©m imprime no terminal

    def on_error(self, mensagem: str):
        QMessageBox.critical(self, "Erro", f"Falha: {mensagem}")

    def on_finished(self):
        print("âœ… OperaÃ§Ã£o concluÃ­da.")

    # â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
    # MÃ©todos para construÃ§Ã£o da UI
    # â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

    def create_backup_tab(self):
        """Cria a aba de operaÃ§Ãµes de backup e criaÃ§Ã£o de mundos"""
        tab = QWidget()
        layout = QVBoxLayout()

        # === Grupo: Criar e Upload de Mundo ===
        group_criar = QGroupBox("Criar e Enviar Novo Mundo")
        form_layout = QFormLayout()

        self.spin_fator = QSpinBox()
        self.spin_fator.setMinimum(2)
        self.spin_fator.setMaximum(8)
        self.spin_fator.setValue(4)
        form_layout.addRow("Fator:", self.spin_fator)

        self.combo_bioma = QComboBox()
        biomas = ["Meadow", "Forest", "Savanna", "Desert", "Hills", "Mountains"]
        self.combo_bioma.addItems(biomas)
        self.combo_bioma.setCurrentText("Meadow")
        form_layout.addRow("Bioma Inicial:", self.combo_bioma)

        group_criar.setLayout(form_layout)
        layout.addWidget(group_criar)

        btn_upload = QPushButton("ğŸŒ Criar e Enviar Mundo para Nuvem")
        btn_upload.clicked.connect(self.handle_criar_e_upload)
        layout.addWidget(btn_upload)

        layout.addSpacing(20)

        # === Grupo: SimulaÃ§Ã£o de Players ===
        group_sim = QGroupBox("SimulaÃ§Ã£o de Players Online")
        layout_sim = QVBoxLayout()

        btn_iniciar_sim = QPushButton("â–¶ï¸ Iniciar SimulaÃ§Ã£o de Players")
        btn_iniciar_sim.setStyleSheet("""
            QPushButton { background-color: #27ae60; color: white; font-weight: bold; border-radius: 6px; padding: 8px; }
            QPushButton:hover { background-color: #2ecc71; }
        """)
        btn_iniciar_sim.clicked.connect(self.handle_iniciar_simulacao)
        layout_sim.addWidget(btn_iniciar_sim)

        btn_parar_sim = QPushButton("â¹ï¸ Parar SimulaÃ§Ã£o de Players")
        btn_parar_sim.setStyleSheet("""
            QPushButton { background-color: #e74c3c; color: white; font-weight: bold; border-radius: 6px; padding: 8px; }
            QPushButton:hover { background-color: #c0392b; }
        """)
        btn_parar_sim.clicked.connect(self.handle_parar_simulacao)
        layout_sim.addWidget(btn_parar_sim)

        group_sim.setLayout(layout_sim)
        layout.addWidget(group_sim)

        layout.addSpacing(20)

        # === Grupo: Salvar Localmente ===
        group_local = QGroupBox("Salvar Estado Localmente")
        layout_local = QVBoxLayout()

        btn_save = QPushButton("ğŸ’¾ Salvar Estado como JSON (Local)")
        btn_save.clicked.connect(self.handle_save_json)
        layout_local.addWidget(btn_save)

        group_local.setLayout(layout_local)
        layout.addWidget(group_local)

        layout.addSpacing(20)

        # === BotÃ£o: Reinicializar Infraestrutura AWS ===
        btn_reiniciar = QPushButton("âš ï¸ Reinicializar Infraestrutura AWS")
        btn_reiniciar.setStyleSheet("""
            QPushButton {
                background-color: #a83232;
                color: white;
                font-weight: bold;
                border-radius: 6px;
                padding: 8px;
            }
            QPushButton:hover {
                background-color: #c03939;
            }
        """)
        btn_reiniciar.clicked.connect(self.handle_reinicializar_servidor)
        layout.addWidget(btn_reiniciar)
        layout.addSpacing(10)

        # === Log de Atividades ===
        self.log_output = QTextEdit()
        self.log_output.setReadOnly(True)
        self.log_output.setMaximumHeight(150)
        self.log_output.setPlaceholderText("Log de atividades...")
        layout.addWidget(self.log_output)

        layout.addStretch()
        tab.setLayout(layout)
        return tab

    def handle_iniciar_simulacao(self):
        """Inicia a simulaÃ§Ã£o de players online."""
        if not self.comandante:
            QMessageBox.critical(self, "Erro", "Comandante nÃ£o estÃ¡ disponÃ­vel.")
            return
        self.comandante.iniciar_simulacao_players(signals=self.signals)

    def handle_parar_simulacao(self):
        """Para a simulaÃ§Ã£o de players online."""
        if not self.comandante:
            return
        self.comandante.parar_simulacao_players()
        self.signals.success.emit("ğŸ›‘ SimulaÃ§Ã£o interrompida pelo usuÃ¡rio.")

    def handle_save_json(self):
        """Salva o Ãºltimo mundo criado (se existir) como JSON local."""
        if not self.ultimo_mundo:
            QMessageBox.warning(self, "Aviso", "Nenhum mundo foi criado ainda.")
            return

        try:
            mundo = self.ultimo_mundo
            filepath, _ = QFileDialog.getSaveFileName(
                self,
                "Salvar Mundo como JSON",
                f"saves/mundo_{mundo.id_mundo}.json",
                "JSON Files (*.json)"
            )
            if not filepath:
                return  # Cancelado

            caminho_salvo = Serializador.save_mundo(mundo, filepath)
            if caminho_salvo:
                QMessageBox.information(
                    self, "Sucesso", f"Mundo salvo localmente:\n{caminho_salvo}"
                )
            else:
                QMessageBox.critical(self, "Falha", "Erro ao salvar o arquivo.")
        except Exception as e:
            QMessageBox.critical(self, "Erro", f"Falha ao salvar: {str(e)}")

    def handle_criar_e_upload(self):
        if not self.comandante:
            QMessageBox.critical(self, "Erro", "Comandante nÃ£o estÃ¡ disponÃ­vel.")
            return

        fator = self.spin_fator.value()
        bioma = self.combo_bioma.currentText()

        self.comandante.criar_e_upload_mundo(
            fator=fator,
            bioma=bioma,
            signals=self.signals
        )

    def handle_reinicializar_servidor(self):
        if not self.comandante:
            QMessageBox.critical(self, "Erro", "Comandante nÃ£o estÃ¡ disponÃ­vel.")
            return

        reply = QMessageBox.question(
            self,
            "âš ï¸ Reinicializar Infraestrutura",
            "Isso apagarÃ¡ TODOS os mundos e metadados no S3 e DynamoDB.\n"
            "Continuar?",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
        )
        if reply != QMessageBox.StandardButton.Yes:
            return

        self.comandante.reinicializar_infra(
            confirmar=False,
            signals=self.signals
        )


# ExecuÃ§Ã£o da aplicaÃ§Ã£o
if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = Interface()
    window.show()
    sys.exit(app.exec())

================================================================================
ğŸ“„ server/services/matchmaking_service.py
================================================================================
# server/services/matchmaking_service.py
from typing import List, Optional, Callable
import threading
from shared.world import Mundo
from server.services.world_pool import MundoPoolService  # âœ… InjeÃ§Ã£o de dependÃªncia

class SalaDeEspera:
    def __init__(self, mundo: Mundo, callback: Callable[[List[str]], None]):
        self.mundo = mundo
        self.vagas = len(mundo.planeta.capitais_players)  # âœ… Vagas definidas pelo mundo
        self.jogadores = []
        self.lock = threading.Lock()
        self.callback = callback

    def adicionar_jogador(self, username: str) -> str:
        with self.lock:
            if username in self.jogadores:
                return f"Erro ao entrar na fila: {username} jÃ¡ estÃ¡ na sala."
            if len(self.jogadores) >= self.vagas:
                return "Erro ao entrar na fila: sala cheia."

            self.jogadores.append(username)

            if len(self.jogadores) == self.vagas:
                self.callback(self.jogadores.copy())

            return f"{username} entrou na sala {self.mundo.id_mundo} ({len(self.jogadores)}/{self.vagas})"

    def esta_cheia(self) -> bool:
        with self.lock:
            return len(self.jogadores) >= self.vagas

    def tamanho(self) -> int:
        with self.lock:
            return len(self.jogadores)


class MatchmakingService:
    """
    Matchmaking baseado em MUNDOS PRÃ‰-CRIADOS fornecidos pelo WorldPoolService.
    O MatchmakingService nÃ£o cria mundos â€” apenas aloca jogadores.
    """
    def __init__(self, world_pool: MundoPoolService):
        self.world_pool = world_pool
        self.salas: List[SalaDeEspera] = []  # Salas ativas com vagas
        self.lock = threading.Lock()
        self.partida_iniciada_callback: Optional[Callable[[List[str]], None]] = None

    def _on_partida_cheia(self, jogadores: List[str]):
        """Callback interno chamado quando uma sala enche."""
        if self.partida_iniciada_callback:
            self.partida_iniciada_callback(jogadores)

    def entrar_na_fila(self, username: str) -> str:
        """
        1. ObtÃ©m um mundo com vaga do WorldPoolService.
        2. Associa o jogador a esse mundo (cria ou entra em sala).
        3. Registra ocupaÃ§Ã£o no pool.
        """
        with self.lock:
            # 1. Obter um mundo com vaga disponÃ­vel
            mundo = self.world_pool.obter_mundo_com_vaga()
            if not mundo:
                return f"Erro ao entrar na fila: nenhum mundo disponÃ­vel para {username}."

            # 2. Verificar se jÃ¡ existe uma sala para esse mundo
            sala_existente = next((s for s in self.salas if s.mundo.id_mundo == mundo.id_mundo), None)

            if sala_existente:
                mensagem = sala_existente.adicionar_jogador(username)
            else:
                # Criar nova sala para esse mundo
                nova_sala = SalaDeEspera(mundo=mundo, callback=self._on_partida_cheia)
                self.salas.append(nova_sala)
                mensagem = nova_sala.adicionar_jogador(username)

            # 3. Registrar no pool que o jogador ocupou uma vaga
            if "Erro" not in mensagem:
                self.world_pool.registrar_jogador_no_mundo(username, mundo)

            print(mensagem)
            return mensagem

================================================================================
ğŸ“„ server/services/queue_service.py
================================================================================
# server/services/queue_service.py
"""
ServiÃ§o de fila de espera para matchmaking online.
Gerencia a entrada de jogadores e formaÃ§Ã£o de partidas quando hÃ¡ 4+ jogadores.
"""

import threading
from typing import Optional, Callable


class FilaService:
    """
    ServiÃ§o responsÃ¡vel por gerenciar a fila de jogadores online.
    Forma partidas automaticamente quando 4 jogadores estÃ£o na fila.
    """

    def __init__(self):
        self.fila = []
        self.lock = threading.Lock()
        self.partida_iniciada_callback: Optional[Callable[[list], None]] = None

    def adicionar_jogador(self, username: str) -> bool:
        with self.lock:
            if username in self.fila:
                print(f"âš ï¸ '{username}' jÃ¡ estÃ¡ na fila. Bloqueado.")
                return False
            self.fila.append(username)
            print(f"ğŸ“¥ Jogador '{username}' adicionado Ã  fila. Total: {len(self.fila)}")
            self._tentar_formar_partida()
            return True

    def remover_jogador(self, username: str):
        """
        Remove um jogador da fila, se estiver presente.
        """
        with self.lock:
            if username in self.fila:
                self.fila.remove(username)
                print(f"ğŸ“¤ Jogador '{username}' removido da fila.")

    def _tentar_formar_partida(self):
        with self.lock:
            print(f"ğŸ” Verificando formaÃ§Ã£o de partida. Fila atual: {self.fila} (total: {len(self.fila)})")  # â† Novo log
            if len(self.fila) >= 4:
                partida = [self.fila.pop(0) for _ in range(4)]
                print(f"ğŸ‰ Partida formada com: {partida}")
                if self.partida_iniciada_callback:
                    try:
                        self.partida_iniciada_callback(partida)
                    except Exception as e:
                        print(f"âŒ Erro ao executar partida_iniciada_callback: {e}")
                else:
                    print("â„¹ï¸ Nenhum callback configurado.")

================================================================================
ğŸ“„ server/services/user_service.py
================================================================================
# server/services/user_service.py
import boto3
from botocore.exceptions import ClientError


class UserService:
    def __init__(self, dynamodb_client, table_name):
        self.dynamodb = dynamodb_client
        self.table_name = table_name

    def _format_user_key(self, username: str) -> dict:
        """Formata a chave primÃ¡ria do usuÃ¡rio no DynamoDB."""
        return {
            'PK': {'S': f'USER#{username}'},
            'SK': {'S': 'PROFILE'}
        }

    def get_user(self, username: str) -> dict:
        """Busca um usuÃ¡rio pelo username."""
        if not self.dynamodb:
            print("âš ï¸ Cliente DynamoDB nÃ£o disponÃ­vel no UserService.")
            return None
        try:
            response = self.dynamodb.get_item(
                TableName=self.table_name,
                Key=self._format_user_key(username)
            )
            return response.get('Item')
        except ClientError as e:
            print(f"âŒ Erro do DynamoDB ao buscar usuÃ¡rio '{username}': {e.response['Error']['Message']}")
            return None
        except Exception as e:
            print(f"âŒ Erro inesperado ao buscar usuÃ¡rio '{username}': {e}")
            return None

    def create_user_item(self, username: str, **attributes) -> bool:
        """
        Cria um novo item de usuÃ¡rio no DynamoDB.
        `attributes` pode conter {'password_hash': bytes, 'outro_attr': valor, ...}
        """
        if not self.dynamodb:
            print("âš ï¸ Cliente DynamoDB nÃ£o disponÃ­vel no UserService.")
            return False
        try:
            # Inicia o item com a chave primÃ¡ria
            item = self._format_user_key(username)

            # Adiciona outros atributos fornecidos
            for attr_name, attr_value in attributes.items():
                # Trata tipos especÃ­ficos
                if isinstance(attr_value, bytes):
                    # Para password_hash, salva como tipo binÃ¡rio 'B'
                    item[attr_name] = {'B': attr_value}
                elif isinstance(attr_value, str):
                    # Para strings, salva como tipo string 'S'
                    item[attr_name] = {'S': attr_value}
                elif isinstance(attr_value, (int, float)):
                    # Para nÃºmeros, salva como tipo nÃºmero 'N' (convertido para string)
                    item[attr_name] = {'N': str(attr_value)}
                else:
                    # Para outros tipos, converte para string e salva como 'S'
                    # (vocÃª pode querer ser mais especÃ­fico aqui dependendo das suas necessidades)
                    print(
                        f"âš ï¸ Atributo '{attr_name}' tem tipo inesperado ({type(attr_value)}). Convertendo para string.")
                    item[attr_name] = {'S': str(attr_value)}

            self.dynamodb.put_item(
                TableName=self.table_name,
                Item=item
            )
            print(f"âœ… Item de usuÃ¡rio '{username}' criado/Atualizado no DynamoDB.")
            return True
        except ClientError as e:
            print(f"âŒ Erro do DynamoDB ao criar usuÃ¡rio '{username}': {e.response['Error']['Message']}")
            return False
        except Exception as e:
            print(f"âŒ Erro inesperado ao criar usuÃ¡rio '{username}': {e}")
            return False

    def authenticate_user(self, username: str, password: str) -> tuple[bool, str]:
        """
        Autentica um usuÃ¡rio verificando a senha com bcrypt.

        :param username: Nome de usuÃ¡rio.
        :param password: Senha em texto plano.
        :return: (sucesso: bool, mensagem: str)
        """
        if not username or not password:
            return False, "UsuÃ¡rio ou senha ausentes."

        # 1. Buscar usuÃ¡rio
        user = self.get_user(username)
        if not user:
            return False, "UsuÃ¡rio nÃ£o encontrado."

        # 2. Extrair o hash da senha
        password_hash_attr = user.get('password_hash')
        if not password_hash_attr:
            return False, "UsuÃ¡rio sem senha cadastrada."

        # 3. O hash pode vir como {'B': bytes} do DynamoDB
        if isinstance(password_hash_attr, dict) and 'B' in password_hash_attr:
            stored_hash = password_hash_attr['B']
        elif isinstance(password_hash_attr, bytes):
            stored_hash = password_hash_attr
        else:
            return False, "Formato de hash de senha invÃ¡lido."

        # 4. Verificar com bcrypt
        try:
            if bcrypt.checkpw(password.encode('utf-8'), stored_hash):
                return True, "Login bem-sucedido."
            else:
                return False, "Senha incorreta."
        except Exception as e:
            print(f"âŒ Erro ao verificar senha com bcrypt: {e}")
            return False, "Erro interno ao processar autenticaÃ§Ã£o."


================================================================================
ğŸ“„ server/services/world_pool.py
================================================================================
# server/services/world_pool.py
from typing import List, Optional, Dict
import threading
from shared.world import Mundo
from server.manager import Gerenciador


class MundoPoolService:
    """
    Gerencia um pool de mundos prÃ©-criados com vagas disponÃ­veis.
    Evita que o MatchmakingService crie mundos diretamente.
    """
    def __init__(
        self,
        gerenciador: Gerenciador,
        fator: int = 4,
        bioma: str = "Meadow",
        tamanho_inicial: int = 3,
        max_mundos: int = 10
    ):
        self.gerenciador = gerenciador
        self.fator = fator
        self.bioma = bioma
        self.tamanho_inicial = tamanho_inicial
        self.max_mundos = max_mundos
        self.mundos_com_vaga: List[Mundo] = []  # Mundos com pelo menos uma vaga
        self.jogadores_por_mundo: Dict[str, List[str]] = {}  # id_mundo â†’ [user1, user2, ...]
        self.lock = threading.Lock()
        self._inicializar_pool()

    def _inicializar_pool(self):
        """Cria mundos iniciais no pool."""
        for _ in range(self.tamanho_inicial):
            sucesso, mundo = self.gerenciador.criar_e_upload_mundo_com_retorno(
                fator=self.fator,
                bioma=self.bioma,
                bucket_name="global-arena-tiles",
                s3_prefix="planetas/"
            )
            if sucesso and mundo:
                self.mundos_com_vaga.append(mundo)
                self.jogadores_por_mundo[mundo.id_mundo] = []

    def obter_mundo_com_vaga(self) -> Optional[Mundo]:
        """
        Retorna um mundo com vaga disponÃ­vel.
        Se nÃ£o houver, tenta criar um novo (se abaixo do limite).
        """
        with self.lock:
            # Procurar mundo com vaga
            for mundo in self.mundos_com_vaga:
                ocupadas = len(self.jogadores_por_mundo[mundo.id_mundo])
                vagas = len(mundo.planeta.capitais_players) - ocupadas
                if vagas > 0:
                    return mundo

            # Nenhum com vaga â†’ criar novo, se possÃ­vel
            if len(self.mundos_com_vaga) < self.max_mundos:
                sucesso, novo_mundo = self.gerenciador.criar_e_upload_mundo_com_retorno(
                    fator=self.fator,
                    bioma=self.bioma,
                    bucket_name="global-arena-tiles",
                    s3_prefix="planetas/"
                )
                if sucesso and novo_mundo:
                    self.mundos_com_vaga.append(novo_mundo)
                    self.jogadores_por_mundo[novo_mundo.id_mundo] = []
                    return novo_mundo

            return None  # Sem mundos disponÃ­veis

    def registrar_jogador_no_mundo(self, username: str, mundo: Mundo):
        """
        Marca que um jogador estÃ¡ ocupando uma vaga nesse mundo.
        Quando todas as vagas forem preenchidas, o mundo Ã© removido do pool.
        """
        with self.lock:
            lista = self.jogadores_por_mundo[mundo.id_mundo]
            if username not in lista:
                lista.append(username)

            # Se nÃ£o houver mais vagas, remover do pool
            vagas_restantes = len(mundo.planeta.capitais_players) - len(lista)
            if vagas_restantes <= 0:
                if mundo in self.mundos_com_vaga:
                    self.mundos_com_vaga.remove(mundo)

    def quantidade_total(self) -> int:
        """Retorna nÃºmero total de mundos no pool (com ou sem vaga)."""
        with self.lock:
            return len(self.mundos_com_vaga)

    def quantidade_vagas(self) -> int:
        """Retorna nÃºmero total de vagas disponÃ­veis no pool."""
        total = 0
        with self.lock:
            for mundo in self.mundos_com_vaga:
                ocupadas = len(self.jogadores_por_mundo[mundo.id_mundo])
                total += len(mundo.planeta.capitais_players) - ocupadas
        return total

    def reabastecer(self):
        """Reabastece o pool atÃ© o tamanho inicial (Ãºtil para manutenÃ§Ã£o)."""
        with self.lock:
            while len(self.mundos_com_vaga) < self.tamanho_inicial and len(self.mundos_com_vaga) < self.max_mundos:
                sucesso, mundo = self.gerenciador.criar_e_upload_mundo_com_retorno(
                    fator=self.fator,
                    bioma=self.bioma,
                    bucket_name="global-arena-tiles",
                    s3_prefix="planetas/"
                )
                if sucesso and mundo:
                    self.mundos_com_vaga.append(mundo)
                    self.jogadores_por_mundo[mundo.id_mundo] = []

================================================================================
ğŸ“„ server/routes/game.py
================================================================================
# server/routes/game.py
from flask import Blueprint, jsonify, request
from server.services.user_service import UserService
from server.services.matchmaking_service import MatchmakingService  # âœ… SubstituÃ­do: agora usa MatchmakingService

jogo_bp = Blueprint('jogo', __name__, url_prefix='/jogo')

# VariÃ¡vel para injeÃ§Ã£o de dependÃªncia
_user_service = None
_matchmaking_service = None  # âœ… Renomeado: _fila_service â†’ _matchmaking_service


def register_jogo_routes(user_service: UserService, matchmaking_service: MatchmakingService):
    """FunÃ§Ã£o para injetar dependÃªncias no blueprint jogo."""
    global _user_service, _matchmaking_service
    _user_service = user_service
    _matchmaking_service = matchmaking_service  # âœ… Injeta o novo serviÃ§o


@jogo_bp.route('/entrar', methods=['POST'])
def entrar_na_fila():
    if not request.is_json:
        return jsonify({"success": False, "message": "JSON esperado"}), 400

    data = request.get_json()
    modo = data.get("modo")
    username = data.get("username")

    if modo != "online":
        return jsonify({"success": False, "message": "Modo invÃ¡lido. Use 'online'."}), 400

    if not username:
        return jsonify({"success": False, "message": "Username necessÃ¡rio."}), 400

    # âœ… Validar se o usuÃ¡rio existe
    usuario = _user_service.get_user(username)
    if not usuario:
        return jsonify({"success": False, "message": "UsuÃ¡rio nÃ£o encontrado."}), 404

    # âœ… ADICIONAR Ã€ FILA DE MATCHMAKING
    mensagem = _matchmaking_service.entrar_na_fila(username)

    # O mÃ©todo retorna uma mensagem; sucesso se nÃ£o contiver erro
    if "Erro ao entrar na fila" in mensagem:
        return jsonify({
            "success": False,
            "message": mensagem
        }), 409

    # âœ… Contagem total de jogadores em todas as salas ativas
    total_na_fila = sum(len(sala.jogadores) for sala in _matchmaking_service.salas if sala.jogadores)

    return jsonify({
        "success": True,
        "message": mensagem,
        "modo": modo,
        "total_na_fila": total_na_fila
    }), 200

================================================================================
ğŸ“„ server/routes/auth.py
================================================================================
# server/routes/auth.py
"""
MÃ³dulo de rotas de autenticaÃ§Ã£o (login, registro).
Gerencia a injeÃ§Ã£o de dependÃªncia do UserService.
"""
import re
import bcrypt
import unicodedata
from flask import Blueprint, request, jsonify, current_app

# Cria o Blueprint com prefixo
auth_bp = Blueprint('auth', __name__, url_prefix='/auth')

# VariÃ¡vel global para injeÃ§Ã£o de dependÃªncia
_user_service = None


def normalizar_username(username: str) -> str:
    """
    Normaliza o username: remove acentos, converte para minÃºsculas,
    substitui caracteres especiais por underscores.
    Retorna None se resultar em string vazia.
    """
    if not username:
        return None
    # Remove acentos
    username = unicodedata.normalize('NFKD', username)
    username = ''.join(c for c in username if not unicodedata.combining(c))
    # Substitui nÃ£o alfanumÃ©ricos por underscore
    username = re.sub(r'[^a-zA-Z0-9]', '_', username)
    # MinÃºsculas
    username = username.lower()
    # Underscores mÃºltiplos â†’ Ãºnico
    username = re.sub(r'_+', '_', username).strip('_')
    return username or None


def register_routes(user_service):
    """
    FunÃ§Ã£o de injeÃ§Ã£o de dependÃªncia.
    Configura as rotas do auth_bp com o UserService fornecido.
    Deve ser chamada ANTES de registrar o blueprint no app.
    """
    global _user_service
    print(f"ğŸ“¥ DEBUG: Injetando user_service: {user_service}")
    _user_service = user_service

    # Valida se o serviÃ§o foi injetado
    if not _user_service:
        print("âŒ ERRO GRAVE: user_service Ã© None em register_routes!")
        raise RuntimeError("UserService nÃ£o injetado em auth_bp.")
    else:
        print(f"âœ… DEBUG: _user_service atribuÃ­do com sucesso: {_user_service}")


# --- ENDPOINT: Teste de ConexÃ£o ---
@auth_bp.route('/teste_dynamodb', methods=['GET'])
def teste_dynamodb():
    """Testa a conexÃ£o com o DynamoDB via UserService."""
    if not _user_service or not _user_service.dynamodb:
        return jsonify({
            "status": "erro",
            "message": "Cliente DynamoDB nÃ£o disponÃ­vel."
        }), 500

    try:
        response = _user_service.dynamodb.list_tables()
        tabelas = response.get('TableNames', [])
        return jsonify({
            "status": "sucesso",
            "message": "ConexÃ£o com DynamoDB bem-sucedida.",
            "tabelas": tabelas
        }), 200
    except Exception as e:
        return jsonify({
            "status": "erro",
            "message": f"Falha ao acessar DynamoDB: {str(e)}"
        }), 500


# --- ENDPOINT: Registrar UsuÃ¡rio ---
@auth_bp.route('/registrar', methods=['POST'])
def registrar():
    """
    Registra um novo usuÃ¡rio.
    Expects: {"username": "str", "password": "str"}
    Returns: {"success": bool, "message": str}
    """
    if not request.is_json:
        return jsonify({"success": False, "message": "JSON esperado."}), 400

    data = request.get_json()
    username = data.get('username', '').strip()
    password = data.get('password', '')

    # Validar campos
    if not username or not password:
        return jsonify({"success": False, "message": "Username e senha sÃ£o obrigatÃ³rios."}), 400
    if len(username) < 3:
        return jsonify({"success": False, "message": "Username deve ter pelo menos 3 caracteres."}), 400
    if len(password) < 6:
        return jsonify({"success": False, "message": "Senha deve ter pelo menos 6 caracteres."}), 400

    # Normalizar username (opcional)
    username_normalizado = normalizar_username(username)
    if not username_normalizado:
        return jsonify({"success": False, "message": "Username invÃ¡lido apÃ³s normalizaÃ§Ã£o."}), 400

    # Verificar se jÃ¡ existe (usando o nome original)
    if _user_service.get_user(username):
        return jsonify({"success": False, "message": "Username jÃ¡ estÃ¡ em uso."}), 409

    # Hashear senha
    try:
        salt = bcrypt.gensalt()
        password_hash = bcrypt.hashpw(password.encode('utf-8'), salt)
    except Exception as e:
        print(f"âŒ Erro ao hashear senha para '{username}': {e}")
        return jsonify({"success": False, "message": "Erro ao processar senha."}), 500

    # Salvar no DynamoDB
    sucesso = _user_service.create_user_item(username, password_hash=password_hash)
    if sucesso:
        print(f"âœ… UsuÃ¡rio '{username}' registrado com sucesso.")
        return jsonify({"success": True, "message": "UsuÃ¡rio registrado com sucesso."}), 201
    else:
        return jsonify({"success": False, "message": "Falha ao salvar no banco."}), 500


# --- ENDPOINT: Login ---
@auth_bp.route('/login', methods=['POST'])
def login():
    """
    Autentica um usuÃ¡rio.
    Expects: {"username": "str", "password": "str"}
    Returns: {"success": bool, "message": str, "token": str (opcional)}
    """
    print("ğŸ” DEBUG: Rota /auth/login foi chamada!")

    # Garantir acesso ao serviÃ§o injetado via register_routes
    global _user_service
    if not _user_service:
        print("ğŸ’¥ ERRO: _user_service nÃ£o foi injetado!")
        return jsonify({
            "success": False,
            "message": "Erro interno do servidor."
        }), 500

    try:
        # 1. Validar formato da requisiÃ§Ã£o
        if not request.is_json:
            print("âŒ RequisiÃ§Ã£o nÃ£o Ã© JSON")
            return jsonify({
                "success": False,
                "message": "JSON esperado."
            }), 400

        data = request.get_json()
        username = data.get('username', '').strip()
        password = data.get('password', '')

        print(f"ğŸ” Tentativa de login - username: {username}")

        # 2. Validar campos obrigatÃ³rios
        if not username:
            print("âš ï¸ Username ausente")
            return jsonify({
                "success": False,
                "message": "Username Ã© obrigatÃ³rio."
            }), 400
        if not password:
            print("âš ï¸ Senha ausente")
            return jsonify({
                "success": False,
                "message": "Senha Ã© obrigatÃ³ria."
            }), 400

        # 3. Buscar usuÃ¡rio no DynamoDB
        usuario = _user_service.get_user(username)
        if not usuario:
            print(f"âŒ Credenciais invÃ¡lidas para '{username}'.")
            return jsonify({
                "success": False,
                "message": "Credenciais invÃ¡lidas."
            }), 401

        # 4. Extrair e validar hash da senha
        password_hash_attr = usuario.get('password_hash')
        if not password_hash_attr:
            print(f"âŒ UsuÃ¡rio '{username}' sem password_hash.")
            return jsonify({
                "success": False,
                "message": "Credenciais invÃ¡lidas."
            }), 401

        # Suporta formato DynamoDB {'B': bytes} ou bytes direto
        stored_hash = password_hash_attr.get('B') if isinstance(password_hash_attr, dict) else password_hash_attr

        if not isinstance(stored_hash, bytes):
            print(f"âš ï¸ Hash invÃ¡lido para '{username}': {type(stored_hash)}")
            return jsonify({
                "success": False,
                "message": "Credenciais invÃ¡lidas."
            }), 401

        # 5. Verificar senha com bcrypt
        if bcrypt.checkpw(password.encode('utf-8'), stored_hash):
            print(f"âœ… Login bem-sucedido para '{username}'.")

            # ğŸ” Gera um token fake para compatibilidade com o simulador
            # (Futuro: substituir por JWT real)
            fake_token = f"fake-jwt-{username}-{hash(username) % 10000}"

            return jsonify({
                "success": True,
                "message": "Login bem-sucedido.",
                "token": fake_token  # â† Adicionado para o simulador usar
            }), 200
        else:
            print(f"âŒ Senha incorreta para '{username}'.")
            return jsonify({
                "success": False,
                "message": "Credenciais invÃ¡lidas."
            }), 401

    except Exception as e:
        print(f"ğŸ’¥ ERRO NÃƒO TRATADO em /auth/login: {type(e).__name__}: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({
            "success": False,
            "message": "Erro interno no servidor."
        }), 500

================================================================================
ğŸ“„ client/main.py
================================================================================
# client/main.py

import sys
import os  # Para verificar o arquivo de sessÃ£o
import OpenGL.GL as gl
import ctypes

import requests
from PyQt6.QtWidgets import (
    QApplication, QMainWindow, QWidget, QVBoxLayout, QLabel, QPushButton, QHBoxLayout,
    QSizePolicy, QFrame, QMessageBox, QDialog, QFormLayout, QLineEdit, QDialogButtonBox
)
from PyQt6.QtOpenGLWidgets import QOpenGLWidget
from PyQt6.QtCore import QTimer, Qt
from PyQt6.QtGui import QSurfaceFormat, QFont
from client.components.icon_manager import GerenciadorIconesEsquerda
from client.dialogs.auth_dialog import DialogoAutenticacao


# --- Componente OpenGL ---
class MeuOpenGLWidget(QOpenGLWidget):
    """
    Widget responsÃ¡vel pela renderizaÃ§Ã£o OpenGL Moderna.
    """

    def __init__(self):
        super().__init__()
        self.shader_program = None
        self.VAO = None
        self.VBO = None
        # Permitir que o widget receba foco de teclado
        self.setFocusPolicy(Qt.FocusPolicy.StrongFocus)

    def initializeGL(self):
        """
        Inicializado uma vez quando o contexto OpenGL Ã© criado.
        Aqui compilamos shaders, criamos VAOs, VBOs etc.
        """
        print("Inicializando contexto OpenGL...")
        # Define a cor de fundo padrÃ£o como PRETO PURO
        gl.glClearColor(0.0, 0.0, 0.0, 1.0)

        # --- Compilar Shaders para o TriÃ¢ngulo ---
        vertex_shader_source = """
        #version 330 core
        layout (location = 0) in vec3 aPos;
        layout (location = 1) in vec3 aColor;
        out vec3 ourColor;
        void main()
        {
            gl_Position = vec4(aPos, 1.0);
            ourColor = aColor;
        }
        """

        fragment_shader_source = """
        #version 330 core
        in vec3 ourColor;
        out vec4 FragColor;
        void main()
        {
            FragColor = vec4(ourColor, 1.0f);
        }
        """

        # --- CompilaÃ§Ã£o e Linkagem de Shaders ---
        try:
            # CompilaÃ§Ã£o do Vertex Shader
            vertex_shader = gl.glCreateShader(gl.GL_VERTEX_SHADER)
            gl.glShaderSource(vertex_shader, vertex_shader_source)
            gl.glCompileShader(vertex_shader)
            # VerificaÃ§Ã£o de erros no vertex shader
            success = gl.glGetShaderiv(vertex_shader, gl.GL_COMPILE_STATUS)
            if not success:
                info_log = gl.glGetShaderInfoLog(vertex_shader)
                raise RuntimeError(f"Erro ao compilar Vertex Shader:\n{info_log.decode('utf-8')}")

            # CompilaÃ§Ã£o do Fragment Shader
            fragment_shader = gl.glCreateShader(gl.GL_FRAGMENT_SHADER)
            gl.glShaderSource(fragment_shader, fragment_shader_source)
            gl.glCompileShader(fragment_shader)
            # VerificaÃ§Ã£o de erros no fragment shader
            success = gl.glGetShaderiv(fragment_shader, gl.GL_COMPILE_STATUS)
            if not success:
                info_log = gl.glGetShaderInfoLog(fragment_shader)
                raise RuntimeError(f"Erro ao compilar Fragment Shader:\n{info_log.decode('utf-8')}")

            # Linkagem do Programa Shader
            self.shader_program = gl.glCreateProgram()
            gl.glAttachShader(self.shader_program, vertex_shader)
            gl.glAttachShader(self.shader_program, fragment_shader)
            gl.glLinkProgram(self.shader_program)
            # VerificaÃ§Ã£o de erros no link
            success = gl.glGetProgramiv(self.shader_program, gl.GL_LINK_STATUS)
            if not success:
                info_log = gl.glGetProgramInfoLog(self.shader_program)
                raise RuntimeError(f"Erro ao linkar Programa Shader:\n{info_log.decode('utf-8')}")

            # Deletar os shaders jÃ¡ linkados
            gl.glDeleteShader(vertex_shader)
            gl.glDeleteShader(fragment_shader)

        except RuntimeError as e:
            print(f"âŒ Erro na inicializaÃ§Ã£o dos shaders: {e}")
            self.shader_program = None  # Indica falha
            return  # Aborta a inicializaÃ§Ã£o da geometria se shaders falharem

        # --- Configurar VAO e VBO para um triÃ¢ngulo ---
        try:
            # Dados do triÃ¢ngulo (PosiÃ§Ã£o XYZ + Cor RGB)
            triangle_data = [
                0.0, 0.5, 0.0, 1.0, 0.0, 0.0,  # VÃ©rtice 0: Topo (Vermelho)
                -0.5, -0.5, 0.0, 0.0, 1.0, 0.0,  # VÃ©rtice 1: Esquerda (Verde)
                0.5, -0.5, 0.0, 0.0, 0.0, 1.0  # VÃ©rtice 2: Direita (Azul)
            ]
            triangle_data = (gl.GLfloat * len(triangle_data))(*triangle_data)

            # Gerar e vincular VAO
            self.VAO = gl.glGenVertexArrays(1)
            gl.glBindVertexArray(self.VAO)

            # Gerar e vincular VBO
            self.VBO = gl.glGenBuffers(1)
            gl.glBindBuffer(gl.GL_ARRAY_BUFFER, self.VBO)
            gl.glBufferData(gl.GL_ARRAY_BUFFER, ctypes.sizeof(triangle_data), triangle_data, gl.GL_STATIC_DRAW)

            # Definir atributos de vÃ©rtice
            stride = 6 * ctypes.sizeof(gl.GLfloat)
            # PosiÃ§Ã£o (location = 0)
            gl.glVertexAttribPointer(0, 3, gl.GL_FLOAT, gl.GL_FALSE, stride, ctypes.c_void_p(0))
            gl.glEnableVertexAttribArray(0)
            # Cor (location = 1)
            gl.glVertexAttribPointer(1, 3, gl.GL_FLOAT, gl.GL_FALSE, stride,
                                     ctypes.c_void_p(3 * ctypes.sizeof(gl.GLfloat)))
            gl.glEnableVertexAttribArray(1)

            # Desvincular VAO/VBO
            gl.glBindBuffer(gl.GL_ARRAY_BUFFER, 0)
            gl.glBindVertexArray(0)

            print("âœ… Shaders compilados e geometria do triÃ¢ngulo configurada.")

        except Exception as e:
            print(f"âŒ Erro ao configurar geometria do triÃ¢ngulo: {e}")
            # Limpar shaders em caso de falha na geometria
            if self.shader_program:
                gl.glDeleteProgram(self.shader_program)
                self.shader_program = None
            self.VAO = None
            self.VBO = None

    def resizeGL(self, w, h):
        """
        Chamado sempre que o widget Ã© redimensionado.
        """
        print(f"Redimensionando OpenGL para {w}x{h}")
        gl.glViewport(0, 0, w, h)
        # TODO: Atualizar matriz de projeÃ§Ã£o se necessÃ¡rio

    def paintGL(self):
        """
        Chamado sempre que a cena OpenGL precisa ser redesenhada.
        """
        # Limpa o buffer com a cor definida em initializeGL
        gl.glClear(gl.GL_COLOR_BUFFER_BIT | gl.GL_DEPTH_BUFFER_BIT)

# --- Componente Janela Principal ---
class JanelaPrincipal(QMainWindow):
    """
    Janela principal da aplicaÃ§Ã£o, contendo a UI 2D e o widget OpenGL.
    Layout: Barras Superior/Inferior (5% da altura),
            Laterais (max(320px, 15% da largura)),
            Ãrea Central para o conteÃºdo OpenGL.
    """

    def __init__(self):
        super().__init__()
        self.setWindowTitle("Global Arena - Cliente PyQt6")

        # --- Verificar estado de login ANTES de criar os Ã­cones ---
        self.usuario_logado = self._verificar_login()

        # --- Obter dimensÃµes da tela para cÃ¡lculos ---
        screen_geometry = self.screen().availableGeometry()
        screen_width = screen_geometry.width()
        screen_height = screen_geometry.height()

        # --- Calcular dimensÃµes das barras ---
        bar_height = int(screen_height * 0.05)
        sidebar_width = max(320, int(screen_width * 0.15))

        print(f"ğŸ® Janela PyQt6 criada. Tela: {screen_width}x{screen_height}. "
              f"Barras H: {bar_height}px, Barras V: {sidebar_width}px")

        # --- ConfiguraÃ§Ã£o do Layout Central ---
        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        main_window_layout = QVBoxLayout(central_widget)
        main_window_layout.setContentsMargins(0, 0, 0, 0)
        main_window_layout.setSpacing(0)

        # --- Barra Superior ---
        self.barra_superior = self._criar_barra(bar_height, is_horizontal=True, object_name="BarraSuperior")
        layout_barra_superior = QHBoxLayout(self.barra_superior)
        layout_barra_superior.setContentsMargins(10, 5, 10, 5)
        label_status = QLabel("Status: Aguardando...")
        layout_barra_superior.addWidget(label_status)
        layout_barra_superior.addStretch()

        # --- ConteÃºdo Principal ---
        conteudo_principal_widget = QWidget()
        conteudo_principal_layout = QHBoxLayout(conteudo_principal_widget)
        conteudo_principal_layout.setContentsMargins(0, 0, 0, 0)
        conteudo_principal_layout.setSpacing(0)

        # --- Barra Esquerda com Ãcones Interativos ---
        self.barra_esquerda = self._criar_barra(sidebar_width, is_horizontal=False, object_name="BarraEsquerda")

        # Criar gerenciador de Ã­cones
        self.gerenciador_icones = GerenciadorIconesEsquerda(caminho_recursos="client/resources")

        # Atualizar Ã­cone e nome de login com base no estado
        if self.usuario_logado:
            try:
                with open("session.txt", "r") as f:
                    nome_usuario = f.read().strip()
            except Exception as e:
                print(f"âŒ Erro ao ler session.txt: {e}")
                nome_usuario = "UsuÃ¡rio"
            self.gerenciador_icones.atualizar_estado_login(True, nome_usuario)

        # Conectar sinal de clique
        self.gerenciador_icones.icone_clicado.connect(self._ao_clicar_icone_lateral)

        # Layout da barra esquerda
        layout_esquerda = QVBoxLayout(self.barra_esquerda)
        layout_esquerda.setContentsMargins(0, 0, 0, 0)
        layout_esquerda.addWidget(self.gerenciador_icones)

        # --- Ãrea Central (OpenGL + Barra Direita) ---
        area_central_widget = QWidget()
        area_central_layout = QHBoxLayout(area_central_widget)
        area_central_layout.setContentsMargins(0, 0, 0, 0)
        area_central_layout.setSpacing(0)

        # --- Criar o Container para OpenGL e Overlay do TÃ­tulo ---
        self.opengl_container = QWidget()
        container_layout = QVBoxLayout(self.opengl_container)
        container_layout.setContentsMargins(0, 0, 0, 0)
        container_layout.setSpacing(0)

        # --- Widget OpenGL ---
        self.opengl_widget = MeuOpenGLWidget()
        self.opengl_widget.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)

        # --- Criar o Overlay Widget para o TÃ­tulo ---
        self.overlay_widget = QWidget(self.opengl_container)
        self.overlay_widget.setWindowFlags(Qt.WindowType.Widget)
        self.overlay_widget.setAttribute(Qt.WidgetAttribute.WA_TranslucentBackground)
        self.overlay_widget.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents)
        self.overlay_widget.setStyleSheet("background: transparent; border: none;")

        # --- Layout do Overlay para o TÃ­tulo e SubtÃ­tulo ---
        overlay_layout = QVBoxLayout(self.overlay_widget)
        overlay_layout.setContentsMargins(0, 0, 0, 0)
        overlay_layout.setSpacing(10)
        overlay_layout.setAlignment(Qt.AlignmentFlag.AlignCenter)

        # --- Label: "Welcome to" ---
        self.label_welcome = QLabel("Welcome to")
        font_welcome = QFont()
        font_welcome.setPointSize(14)
        font_welcome.setItalic(True)
        font_welcome.setWeight(500)
        self.label_welcome.setFont(font_welcome)
        self.label_welcome.setStyleSheet("color: #aaaaaa; background: transparent; border: none;")
        self.label_welcome.setAlignment(Qt.AlignmentFlag.AlignCenter)

        # --- Label: "Global Arena" ---
        self.label_titulo = QLabel("Global Arena")
        font_titulo = QFont()
        font_titulo.setPointSize(48)
        font_titulo.setBold(True)
        font_titulo.setWeight(700)
        self.label_titulo.setFont(font_titulo)
        self.label_titulo.setStyleSheet("""
            color: white;
            background-color: transparent;
            border: none;
            text-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
        """)
        self.label_titulo.setAlignment(Qt.AlignmentFlag.AlignCenter)

        # --- Label: SubtÃ­tulo ---
        self.label_subtitulo = QLabel("the only one for non-flat-earthers")
        font_subtitulo = QFont()
        font_subtitulo.setPointSize(16)
        font_subtitulo.setItalic(True)
        self.label_subtitulo.setFont(font_subtitulo)
        self.label_subtitulo.setStyleSheet("""
            color: #cccccc;
            background-color: transparent;
            border: none;
            font-style: italic;
        """)
        self.label_subtitulo.setAlignment(Qt.AlignmentFlag.AlignCenter)

        # --- Adicionar ao layout na ordem correta ---
        overlay_layout.addWidget(self.label_welcome)
        overlay_layout.addWidget(self.label_titulo)
        overlay_layout.addWidget(self.label_subtitulo)

        # --- Adicionar Widgets ao Container OpenGL ---
        container_layout.addWidget(self.opengl_widget)

        # --- CorreÃ§Ã£o robusta do resizeEvent ---
        def _safe_resize_event(event):
            self.overlay_widget.setGeometry(self.opengl_container.rect())
            self.overlay_widget.raise_()
            QWidget.resizeEvent(self.opengl_container, event)

        self.opengl_container.resizeEvent = _safe_resize_event

        # --- FORÃ‡AR O OVERLAY A APARECER IMEDIATAMENTE ---
        self.overlay_widget.setGeometry(self.opengl_container.rect())
        self.overlay_widget.raise_()
        self.overlay_widget.show()

        # --- Fallback pÃ³s-show: Garante posicionamento apÃ³s renderizaÃ§Ã£o inicial ---
        QTimer.singleShot(50, lambda: [
            self.overlay_widget.setGeometry(self.opengl_container.rect()),
            self.overlay_widget.raise_(),
            self.overlay_widget.show()
        ])

        # --- Barra Direita ---
        self.barra_direita = self._criar_barra(sidebar_width, is_horizontal=False, object_name="BarraDireita")
        layout_direita = QVBoxLayout(self.barra_direita)
        layout_direita.addStretch()
        banner_placeholder = QLabel("Banner\n300x600")
        banner_placeholder.setFixedSize(300, 600)
        banner_placeholder.setStyleSheet("background-color: #333; color: white; border: 1px solid gray;")
        banner_placeholder.setAlignment(Qt.AlignmentFlag.AlignCenter)
        layout_direita.addWidget(banner_placeholder, alignment=Qt.AlignmentFlag.AlignCenter)
        layout_direita.addStretch()

        # --- Adicionar widgets Ã  Ã¡rea central ---
        area_central_layout.addWidget(self.opengl_container)
        area_central_layout.addWidget(self.barra_direita)

        # --- Adicionar widgets ao conteÃºdo principal ---
        conteudo_principal_layout.addWidget(self.barra_esquerda)
        conteudo_principal_layout.addWidget(area_central_widget)

        # --- Barra Inferior ---
        self.barra_inferior = self._criar_barra(bar_height, is_horizontal=True, object_name="BarraInferior")
        layout_barra_inferior = QHBoxLayout(self.barra_inferior)
        layout_barra_inferior.addWidget(QLabel("Barra Inferior"))

        # --- Adicionar todos os componentes ao layout da janela ---
        main_window_layout.addWidget(self.barra_superior)
        main_window_layout.addWidget(conteudo_principal_widget)
        main_window_layout.addWidget(self.barra_inferior)

        # --- Timer para o Loop Principal ---
        self.timer = QTimer(self)
        self.timer.timeout.connect(self.atualizar_logica)
        self.timer.start(16)  # ~60 FPS

        # --- Mostrar e aplicar fullscreen ---
        self.show()
        self.setWindowState(Qt.WindowState.WindowFullScreen)

        # --- Debug final ---
        print("âœ… Janela exibida. Overlay forÃ§ado a aparecer.")
        print("ğŸ” Geometria do container:", self.opengl_container.geometry())
        print("ğŸ” Geometria do overlay:", self.overlay_widget.geometry())
        print("ğŸ” Overlay visÃ­vel?", self.overlay_widget.isVisible())

    def _verificar_login(self):
        """Verifica se o usuÃ¡rio estÃ¡ logado (exemplo: arquivo session.txt existe)."""
        return os.path.exists("session.txt")

    def _criar_barra(self, tamanho, is_horizontal, object_name="Barra"):
        """Cria um widget para representar uma barra, com estilo bÃ¡sico."""
        barra = QFrame()
        barra.setObjectName(object_name)
        if is_horizontal:
            barra.setFixedHeight(tamanho)
        else:
            barra.setFixedWidth(tamanho)
        barra.setStyleSheet(f"""
            #{object_name} {{
                background-color: #2c3e50;
                border: 1px solid #34495e;
            }}
        """)
        return barra

    def atualizar_logica(self):
        """
        Atualiza a lÃ³gica do jogo e solicita redesenho do OpenGL.
        """
        self.opengl_widget.update()

    def _ao_clicar_icone_lateral(self, identificador):
        """Lida com os cliques nos Ã­cones da barra lateral esquerda."""
        print(f"ğŸ–±ï¸ JanelaPrincipal recebeu clique no Ã­cone: {identificador}")
        if identificador == "login":
            self.on_icone_login()
        elif identificador == "play":
            self.on_icone_play()
        elif identificador == "sair":
            self.on_icone_sair()

    def on_icone_login(self):
        """AÃ§Ã£o acionada pelo Ã­cone de login: abre tela de login ou logout."""
        if self.usuario_logado:
            # JÃ¡ logado â†’ oferece logout
            reply = QMessageBox.question(
                self,
                "Logout",
                "VocÃª estÃ¡ logado. Deseja sair?",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
            )
            if reply == QMessageBox.StandardButton.Yes:
                try:
                    os.remove("session.txt")
                    self.usuario_logado = False
                    self.gerenciador_icones.atualizar_estado_login(False)
                    QMessageBox.information(self, "Logout", "VocÃª saiu com sucesso.")
                except Exception as e:
                    QMessageBox.critical(self, "Erro", f"Falha ao remover sessÃ£o: {e}")
        else:
            # NÃ£o logado â†’ abre o novo diÃ¡logo com Login/Registro
            dialog = DialogoAutenticacao(self)
            if dialog.exec() == QDialog.DialogCode.Accepted:
                # ApÃ³s login bem-sucedido, atualiza UI
                try:
                    with open("session.txt", "r") as f:
                        nome_usuario = f.read().strip()
                    self.usuario_logado = True
                    self.gerenciador_icones.atualizar_estado_login(True, nome_usuario)
                except Exception as e:
                    print(f"âŒ Erro ao ler session.txt: {e}")

    def on_icone_play(self):
        """AÃ§Ã£o acionada pelo Ã­cone de play: oferece modo offline ou online."""
        print("AÃ§Ã£o: Ãcone 'Play' clicado. Oferecendo modos de jogo...")

        modo_dialog = QDialog(self)
        modo_dialog.setWindowTitle("Modo de Jogo")
        modo_dialog.setModal(True)
        modo_dialog.resize(300, 150)

        layout = QVBoxLayout()
        layout.addWidget(QLabel("Escolha o modo de jogo:"))

        btn_offline = QPushButton("Offline")
        btn_online = QPushButton("Online")

        layout.addWidget(btn_offline)
        layout.addWidget(btn_online)

        modo_dialog.setLayout(layout)

        # Vamos controlar o fechamento manualmente
        modo_dialog.accepted.connect(lambda: None)  # Desativar aceitaÃ§Ã£o automÃ¡tica

        def escolher_offline():
            modo_dialog.reject()  # Fecha sem aceitar (para nÃ£o disparar lÃ³gica de online)
            self._ir_para_tela_pre_jogo(offline=True)

        def escolher_online():
            modo_dialog.reject()  # Fecha o diÃ¡logo de modo, mas mantÃ©m o controle
            if self.usuario_logado:
                self._ir_para_tela_pre_jogo(offline=False)
            else:
                # Abre o diÃ¡logo completo (login + registro)
                self._abrir_dialogo_autenticacao_completo(
                    success_callback=lambda u: self._ir_para_tela_pre_jogo(offline=False))

        btn_offline.clicked.connect(escolher_offline)
        btn_online.clicked.connect(escolher_online)

        modo_dialog.exec()

    def _iniciar_offline(self, escolha, dialog):
        escolha[0] = "offline"
        dialog.accept()

    def _iniciar_online(self, escolha, dialog):
        escolha[0] = "online"
        dialog.accept()

        # Verifica login
        if not self.usuario_logado:
            print("UsuÃ¡rio nÃ£o logado. Abrindo diÃ¡logo de autenticaÃ§Ã£o...")
            self._abrir_dialogo_autenticacao_completo(success_callback=self._on_login_sucesso_pre_jogo)
        else:
            self._ir_para_tela_pre_jogo(offline=False)

    def _on_login_sucesso_pre_jogo(self, username: str):
        """Callback chamado apÃ³s login bem-sucedido no fluxo de 'play online'."""
        print(f"âœ… Login bem-sucedido. Iniciando prÃ©-jogo online para {username}.")
        self._ir_para_tela_pre_jogo(offline=False)

    def _ir_para_tela_pre_jogo(self, offline: bool):
        """Redireciona para a tela de prÃ©-jogo (futura implementaÃ§Ã£o)."""
        modo = "Offline" if offline else "Online"
        QMessageBox.information(self, "PrÃ©-Jogo",
                                f"Iniciando modo {modo}...\n(Tela de prÃ©-jogo serÃ¡ implementada em breve.)")
        # Futuro: Trocar para widget de prÃ©-jogo
        # Ex: self.setCentralWidget(TelaPreJogo(offline=offline, parent=self))

    def on_icone_sair(self):
        """AÃ§Ã£o acionada pelo Ã­cone de sair."""
        print("AÃ§Ã£o: Ãcone 'Sair' clicado. Fechando aplicaÃ§Ã£o...")
        self.close()

    def _abrir_dialogo_autenticacao_completo(self, success_callback=None):
        """Abre o diÃ¡logo completo de autenticaÃ§Ã£o (login + registro)."""
        dialog = DialogoAutenticacao(parent=self)

        def on_login_sucesso(username: str):
            with open("session.txt", "w") as f:
                f.write(username)
            self.usuario_logado = True
            self.gerenciador_icones.atualizar_estado_login(True, username)
            if success_callback:
                success_callback(username)
            dialog.accept()  # Fecha o diÃ¡logo

        def tentar_login():
            username = dialog.username_login.text().strip()
            password = dialog.senha_login.text()
            if not username or not password:
                QMessageBox.warning(dialog, "Erro", "UsuÃ¡rio e senha sÃ£o obrigatÃ³rios.")
                return
            try:
                response = requests.post("http://localhost:5000/auth/login",
                                         json={"username": username, "password": password})
                data = response.json()
                if response.status_code == 200 and data.get("success"):
                    on_login_sucesso(username)
                else:
                    QMessageBox.critical(dialog, "Erro", data.get("message", "Login falhou."))
            except requests.exceptions.ConnectionError:
                QMessageBox.critical(dialog, "Erro", "NÃ£o foi possÃ­vel conectar ao servidor.")
            except Exception as e:
                QMessageBox.critical(dialog, "Erro", f"Erro: {str(e)}")

        def tentar_registro():
            username = dialog.username_registro.text().strip()
            password = dialog.senha_registro.text()
            confirmar = dialog.confirmar_senha.text()
            if not username or not password or not confirmar:
                QMessageBox.warning(dialog, "Erro", "Todos os campos sÃ£o obrigatÃ³rios.")
                return
            if password != confirmar:
                QMessageBox.warning(dialog, "Erro", "As senhas nÃ£o coincidem.")
                return
            if len(password) < 6:
                QMessageBox.warning(dialog, "Erro", "A senha deve ter pelo menos 6 caracteres.")
                return
            try:
                response = requests.post("http://localhost:5000/auth/registrar",
                                         json={"username": username, "password": password})
                data = response.json()
                if response.status_code == 200 and data.get("success"):
                    QMessageBox.information(dialog, "Sucesso", "Conta criada com sucesso! FaÃ§a login.")
                    # Preenche o campo de login e muda para aba de login
                    dialog.username_login.setText(username)
                    dialog.abas.setCurrentIndex(0)
                else:
                    QMessageBox.critical(dialog, "Erro", data.get("message", "Falha no registro."))
            except requests.exceptions.ConnectionError:
                QMessageBox.critical(dialog, "Erro", "NÃ£o foi possÃ­vel conectar ao servidor.")
            except Exception as e:
                QMessageBox.critical(dialog, "Erro", f"Erro: {str(e)}")

        # ğŸ” Conecta os botÃµes do QDialogButtonBox ao comportamento correto
        # Remover conexÃ£o anterior (se houver)
        try:
            dialog.buttons.accepted.disconnect()
        except TypeError:
            pass  # JÃ¡ desconectado

        # Conecta "OK" ao comportamento da aba atual
        dialog.buttons.accepted.connect(
            lambda: tentar_login() if dialog.abas.currentIndex() == 0 else tentar_registro()
        )

        # "Cancel" jÃ¡ chama reject() â†’ fecha o diÃ¡logo
        dialog.exec()

    def _abrir_tela_login(self):
        """Abre um diÃ¡logo de login com campos de usuÃ¡rio e senha."""

        dialog = QDialog(self)
        dialog.setWindowTitle("Entrar")
        dialog.setModal(True)
        dialog.resize(300, 120)

        layout = QFormLayout()

        username_input = QLineEdit()
        password_input = QLineEdit()
        password_input.setEchoMode(QLineEdit.EchoMode.Password)

        layout.addRow("UsuÃ¡rio:", username_input)
        layout.addRow("Senha:", password_input)

        buttons = QDialogButtonBox(QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel)
        layout.addRow(buttons)

        dialog.setLayout(layout)

        def tentar_login():
            username = username_input.text().strip()
            password = password_input.text()

            if not username or not password:
                QMessageBox.warning(dialog, "Erro", "UsuÃ¡rio e senha sÃ£o obrigatÃ³rios.")
                return

            # Enviar requisiÃ§Ã£o ao backend Flask
            try:
                response = requests.post(
                    "http://localhost:5000/auth/login",
                    json={"username": username, "password": password}
                )
                data = response.json()

                if response.status_code == 200 and data.get("success"):
                    # Login bem-sucedido
                    with open("session.txt", "w") as f:
                        f.write(username)
                    self.usuario_logado = True
                    # Atualiza UI: Ã­cone + nome
                    self.gerenciador_icones.atualizar_estado_login(True, username)
                    QMessageBox.information(dialog, "Sucesso", f"Bem-vindo, {username}!")
                    dialog.accept()
                else:
                    QMessageBox.critical(dialog, "Erro", data.get("message", "Login falhou."))
            except requests.exceptions.ConnectionError:
                QMessageBox.critical(dialog, "Erro", "NÃ£o foi possÃ­vel conectar ao servidor.")
            except Exception as e:
                QMessageBox.critical(dialog, "Erro", f"Erro inesperado: {e}")

        buttons.accepted.connect(tentar_login)
        buttons.rejected.connect(dialog.reject)

        dialog.exec()


# --- Ponto de Entrada da AplicaÃ§Ã£o ---
def main():
    print("ğŸ® Inicializando cliente grÃ¡fico com PyQt6...")
    app = QApplication(sys.argv)

    # Configurar o formato OpenGL padrÃ£o globalmente
    fmt = QSurfaceFormat()
    fmt.setVersion(3, 3)
    fmt.setProfile(QSurfaceFormat.OpenGLContextProfile.CoreProfile)
    # fmt.setDepthBufferSize(24)
    # fmt.setSamples(4)
    QSurfaceFormat.setDefaultFormat(fmt)

    try:
        janela = JanelaPrincipal()
        # janela.show() # show() jÃ¡ Ã© chamado dentro de __init__
        print("âœ… Janela principal exibida em fullscreen.")
        sys.exit(app.exec())
    except Exception as e:
        print(f"âŒ Erro ao criar/iniciar a janela: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)


if __name__ == "__main__":
    # Cria um arquivo session.txt de placeholder para testar o Ã­cone "logado"
    # with open("session.txt", "w") as f:
    #     f.write("usuario_teste_logado")
    main()

================================================================================
ğŸ“„ client/states/__init__.py
================================================================================


================================================================================
ğŸ“„ client/dialogs/auth_dialog.py
================================================================================
# client/dialogs/auth_dialog.py
from PyQt6.QtWidgets import (
    QDialog, QTabWidget, QWidget, QFormLayout, QLineEdit,
    QDialogButtonBox, QMessageBox, QVBoxLayout
)
import requests


class DialogoAutenticacao(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("AutenticaÃ§Ã£o")
        self.setModal(True)
        self.resize(350, 200)

        layout_principal = QVBoxLayout(self)

        # Abas: Login e Registro
        self.abas = QTabWidget()  # Salvando como atributo para acesso futuro
        self.abas.addTab(self.criar_aba_login(), "Entrar")
        self.abas.addTab(self.criar_aba_registro(), "Registrar")
        layout_principal.addWidget(self.abas)

        # BotÃµes comuns â†’ AGORA salvo como atributo: self.buttons
        self.buttons = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel
        )
        self.buttons.accepted.connect(self.on_ok)
        self.buttons.rejected.connect(self.reject)
        layout_principal.addWidget(self.buttons)

    def criar_aba_login(self):
        widget = QWidget()
        layout = QFormLayout()

        self.username_login = QLineEdit()
        self.username_login.setPlaceholderText("seu_username ou email")
        self.username_login.setToolTip("Digite seu username ou email para login.")
        layout.addRow("Username:", self.username_login)  # â† Aqui tambÃ©m

        self.senha_login = QLineEdit()
        self.senha_login.setEchoMode(QLineEdit.EchoMode.Password)
        layout.addRow("Senha:", self.senha_login)

        widget.setLayout(layout)
        return widget

    def criar_aba_registro(self):
        widget = QWidget()
        layout = QFormLayout()

        self.username_registro = QLineEdit()
        self.username_registro.setPlaceholderText("ex: jogador_42")
        self.username_registro.setToolTip("Seu nome de usuÃ¡rio Ãºnico. Usado para login.")
        layout.addRow("Username:", self.username_registro)  # â† Alterado de "UsuÃ¡rio"

        self.senha_registro = QLineEdit()
        self.senha_registro.setEchoMode(QLineEdit.EchoMode.Password)
        layout.addRow("Senha:", self.senha_registro)

        self.confirmar_senha = QLineEdit()
        self.confirmar_senha.setEchoMode(QLineEdit.EchoMode.Password)
        layout.addRow("Confirmar:", self.confirmar_senha)

        widget.setLayout(layout)
        return widget

    def on_ok(self):
        """Chamado quando o botÃ£o OK Ã© pressionado. Executa login ou registro conforme aba ativa."""
        aba_atual = self.abas.currentIndex()  # âœ… Acesso direto ao QTabWidget
        if aba_atual == 0:
            self.tentar_login()
        else:
            self.tentar_registro()

    def tentar_login(self):
        username = self.username_login.text().strip()
        password = self.senha_login.text()

        if not username or not password:
            QMessageBox.warning(self, "Erro", "UsuÃ¡rio e senha sÃ£o obrigatÃ³rios.")
            return

        try:
            response = requests.post(
                "http://localhost:5000/auth/login",
                json={"username": username, "password": password}
            )
            data = response.json()

            if response.status_code == 200 and data.get("success"):
                with open("session.txt", "w") as f:
                    f.write(username)
                QMessageBox.information(self, "Sucesso", f"Bem-vindo, {username}!")
                self.accept()  # Fecha o diÃ¡logo com sucesso
            else:
                QMessageBox.critical(self, "Erro", data.get("message", "Falha no login."))
        except requests.exceptions.ConnectionError:
            QMessageBox.critical(self, "Erro", "NÃ£o foi possÃ­vel conectar ao servidor.")
        except Exception as e:
            QMessageBox.critical(self, "Erro", f"Erro inesperado: {e}")

    def tentar_registro(self):
        username = self.username_registro.text().strip()
        password = self.senha_registro.text()
        confirmar = self.confirmar_senha.text()

        if not username or not password or not confirmar:
            QMessageBox.warning(self, "Erro", "Todos os campos sÃ£o obrigatÃ³rios.")
            return
        if password != confirmar:
            QMessageBox.warning(self, "Erro", "As senhas nÃ£o coincidem.")
            return
        if len(password) < 6:
            QMessageBox.warning(self, "Erro", "A senha deve ter pelo menos 6 caracteres.")
            return

        try:
            response = requests.post(
                "http://localhost:5000/auth/registrar",
                json={"username": username, "password": password}
            )
            data = response.json()

            if response.status_code == 200 and data.get("success"):
                QMessageBox.information(self, "Sucesso", "Conta criada com sucesso! FaÃ§a login.")
                # Podemos mudar para aba de login automaticamente
                self.parent().findChild(QTabWidget).setCurrentIndex(0)
                self.username_login.setText(username)
            else:
                QMessageBox.critical(self, "Erro", data.get("message", "Falha no registro."))
        except requests.exceptions.ConnectionError:
            QMessageBox.critical(self, "Erro", "NÃ£o foi possÃ­vel conectar ao servidor.")
        except Exception as e:
            QMessageBox.critical(self, "Erro", f"Erro inesperado: {e}")

================================================================================
ğŸ“„ client/components/icon_manager.py
================================================================================
# client/components/icon_manager.py
"""Componentes para gerenciar Ã­cones interativos na barra lateral esquerda."""

import os
from PyQt6.QtWidgets import QLabel, QVBoxLayout, QWidget, QHBoxLayout
from PyQt6.QtCore import Qt, pyqtSignal
from PyQt6.QtGui import QPixmap, QCursor
import traceback


class IconeInterativo(QLabel):
    """
    Um QLabel que exibe uma imagem e emite um sinal quando clicado.
    """
    clicado = pyqtSignal(str)  # Sinal emitido ao ser clicado, passando um identificador

    def __init__(self, icone_path, identificador, tamanho=(64, 64), parent=None):
        """
        :param icone_path: Caminho para o arquivo PNG do Ã­cone.
        :param identificador: String Ãºnica para identificar este Ã­cone ("login", "play", "sair").
        :param tamanho: Tupla (largura, altura) para redimensionar o Ã­cone.
        :param parent: Widget pai.
        """
        super().__init__(parent)
        self.identificador = identificador
        self.tamanho = tamanho
        self.setAlignment(Qt.AlignmentFlag.AlignCenter)

        # Estilo para feedback visual (opcional)
        self.setStyleSheet("""
            IconeInterativo {
                border: 2px solid transparent; /* Borda invisÃ­vel por padrÃ£o */
                border-radius: 5px; /* Bordas arredondadas */
            }
            IconeInterativo:hover {
                border: 2px solid #3498db; /* Borda azul ao passar o mouse */
                background-color: rgba(52, 152, 219, 30); /* Fundo azul claro transparente */
            }
        """)
        self.setCursor(QCursor(Qt.CursorShape.PointingHandCursor))  # Muda o cursor para mÃ£ozinha

        self.carregar_icone(icone_path)
        # Redimensionar o QLabel para o tamanho desejado
        self.setFixedSize(*self.tamanho)

    def carregar_icone(self, caminho):
        """
        Carrega e define a imagem do Ã­cone.
        Inclui verificaÃ§Ãµes detalhadas e logs para facilitar depuraÃ§Ã£o.
        """
        print(f"[DEBUG] [IconeInterativo] Tentando carregar Ã­cone '{self.identificador}' de: '{caminho}'")

        # --- VerificaÃ§Ãµes detalhadas do caminho ---
        caminho_absoluto = os.path.abspath(caminho)
        existe = os.path.exists(caminho)
        eh_arquivo = os.path.isfile(caminho) if existe else False

        print(f"[DEBUG] [IconeInterativo] Caminho absoluto resolvido: '{caminho_absoluto}'")
        print(f"[DEBUG] [IconeInterativo] os.path.exists('{caminho}') = {existe}")
        print(f"[DEBUG] [IconeInterativo] os.path.isfile('{caminho}') = {eh_arquivo}")

        # --- Determinar se o carregamento pode prosseguir ---
        pixmap = None
        if not existe:
            print(
                f"âš ï¸ [IconeInterativo] O caminho '{caminho}' NÃƒO EXISTE. DiretÃ³rio de execuÃ§Ã£o pode estar incorreto. Usando placeholder.")
        elif not eh_arquivo:
            print(
                f"âš ï¸ [IconeInterativo] O caminho '{caminho}' EXISTE, mas NÃƒO Ã‰ um arquivo (pode ser um diretÃ³rio). Usando placeholder.")
        else:
            # Caminho existe e Ã© um arquivo, tentar carregar com QPixmap
            print(f"[DEBUG] [IconeInterativo] Caminho vÃ¡lido, tentando QPixmap('{caminho}')...")
            try:
                pixmap = QPixmap(caminho)

                # Verificar se o carregamento foi bem-sucedido
                if pixmap.isNull():
                    print(f"âš ï¸ [IconeInterativo] QPixmap falhou ao carregar o arquivo '{caminho}'. "
                          f"O arquivo pode estar corrompido ou nÃ£o ser uma imagem vÃ¡lida. Usando placeholder.")
                    pixmap = None  # ForÃ§ar uso do placeholder
                else:
                    print(
                        f"[DEBUG] [IconeInterativo] QPixmap carregou com sucesso. Tamanho original: {pixmap.width()}x{pixmap.height()}")

            except Exception as e:
                print(f"âŒ [IconeInterativo] Erro inesperado ao carregar QPixmap de '{caminho}': {e}")
                import traceback
                traceback.print_exc()  # Imprime o stack trace completo
                pixmap = None  # ForÃ§ar uso do placeholder

        # --- Criar pixmap final (carregada ou placeholder) ---
        if pixmap is None:
            # Criar um pixmap de placeholder se a imagem nÃ£o for carregada
            pixmap = QPixmap(self.tamanho[0], self.tamanho[1])
            pixmap.fill(Qt.GlobalColor.gray)  # Cor cinza para placeholder
            print(f"[DEBUG] [IconeInterativo] Placeholder cinza criado para '{self.identificador}'.")
        else:
            # Redimensionar a pixmap carregada para o tamanho desejado
            pixmap = pixmap.scaled(
                self.tamanho[0],
                self.tamanho[1],
                Qt.AspectRatioMode.KeepAspectRatio,
                Qt.TransformationMode.SmoothTransformation
            )
            print(
                f"[DEBUG] [IconeInterativo] Pixmap (carregada) redimensionada para {self.tamanho[0]}x{self.tamanho[1]}.")

        # --- Definir a pixmap (carregada ou placeholder) no QLabel ---
        self.setPixmap(pixmap)
        print(f"[DEBUG] [IconeInterativo] Pixmap definida para o Ã­cone '{self.identificador}'.")

    def mousePressEvent(self, event):
        """Sobrescreve para emitir o sinal ao ser clicado."""
        if event.button() == Qt.MouseButton.LeftButton:
            print(f"ğŸ–±ï¸ Ãcone '{self.identificador}' clicado.")
            self.clicado.emit(self.identificador)  # Emite o sinal com o identificador
        super().mousePressEvent(event)  # Chama o mÃ©todo da classe base


class GerenciadorIconesEsquerda(QWidget):
    """
    Widget que contÃ©m e organiza os Ã­cones interativos na barra esquerda.
    """
    icone_clicado = pyqtSignal(str)  # Re-emite o sinal dos Ã­cones filhos

    def __init__(self, caminho_recursos="client/resources", parent=None):
        """
        :param caminho_recursos: Caminho para a pasta com os Ã­cones PNG.
        :param parent: Widget pai.
        """
        super().__init__(parent)
        self.caminho_recursos = caminho_recursos
        self.icones = {}  # DicionÃ¡rio para armazenar referÃªncias aos Ã­cones {identificador: IconeInterativo}
        self.TAMANHO_ICONE = (48, 48)

        # Layout vertical para os Ã­cones
        layout = QVBoxLayout(self)
        layout.setContentsMargins(10, 10, 10, 10)  # Margens internas
        layout.setSpacing(20)  # EspaÃ§o entre os Ã­cones
        layout.setAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft)

        # --- Criar e adicionar Ã­cones ---
        # --- Ãcone de Login com nome do usuÃ¡rio ---
        icone_login_path = os.path.join(self.caminho_recursos, "log-in.png")
        self.icone_login = IconeInterativo(icone_login_path, "login", tamanho=self.TAMANHO_ICONE)
        self.icone_login.clicado.connect(self._ao_clicar_icone)

        # Layout horizontal para Ã­cone + nome
        self.login_layout = QHBoxLayout()
        self.login_layout.setContentsMargins(0, 0, 0, 0)
        self.login_layout.setSpacing(8)
        self.login_layout.setAlignment(Qt.AlignmentFlag.AlignLeft)

        # Adicionar Ã­cone
        self.login_layout.addWidget(self.icone_login)

        # Label para nome do usuÃ¡rio
        self.label_nome_usuario = QLabel()
        self.label_nome_usuario.setStyleSheet("""
            color: #ecf0f1;
            background: transparent;
            border: none;
            font-size: 14px;
            font-weight: bold;
        """)
        self.label_nome_usuario.hide()
        self.login_layout.addWidget(self.label_nome_usuario)

        # Container final
        self.login_container = QWidget()
        self.login_container.setLayout(self.login_layout)

        # Adicionar ao layout principal
        layout.addWidget(self.login_container)

        # ReferÃªncia
        self.icones["login"] = self.icone_login

        # Criar um layout horizontal para o Ã­cone + nome
        self.login_layout = QHBoxLayout()
        self.login_layout.setContentsMargins(0, 0, 0, 0)
        self.login_layout.setSpacing(8)  # EspaÃ§o entre Ã­cone e texto
        self.login_layout.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)

        # Adicionar Ã­cone
        self.login_layout.addWidget(self.icone_login)

        # Adicionar label de nome (inicialmente oculto)
        self.label_nome_usuario = QLabel()
        self.label_nome_usuario.setStyleSheet("""
            color: #ecf0f1;
            background: transparent;
            border: none;
            font-family: Arial, sans-serif;
            font-size: 14px;
            font-weight: bold;
        """)
        self.label_nome_usuario.hide()  # Esconde por padrÃ£o
        self.login_layout.addWidget(self.label_nome_usuario)

        # Container widget para o layout horizontal
        self.login_container = QWidget()
        self.login_container.setLayout(self.login_layout)

        # Adicionar o container ao layout principal
        layout.addWidget(self.login_container)

        # Armazenar referÃªncia
        self.icones["login"] = self.icone_login  # MantÃ©m compatibilidade

        # Ãcone de Play (Mais abaixo)
        icone_play_path = os.path.join(self.caminho_recursos, "play.png")
        self.icone_play = IconeInterativo(icone_play_path, "play", tamanho=self.TAMANHO_ICONE)
        self.icone_play.clicado.connect(self._ao_clicar_icone)
        layout.addWidget(self.icone_play)
        self.icones["play"] = self.icone_play

        # EspaÃ§o elÃ¡stico para empurrar o Ã­cone de sair para baixo
        layout.addStretch()

        # Ãcone de Sair (Inferior Esquerdo)
        icone_sair_path = os.path.join(self.caminho_recursos, "arrow-left.png")
        self.icone_sair = IconeInterativo(icone_sair_path, "sair", tamanho=self.TAMANHO_ICONE)
        self.icone_sair.clicado.connect(self._ao_clicar_icone)
        layout.addWidget(self.icone_sair)
        self.icones["sair"] = self.icone_sair

    def atualizar_estado_login(self, esta_logado: bool, nome_usuario: str = None):
        """
        Atualiza o Ã­cone e mostra/esconde o nome do usuÃ¡rio.
        """
        if esta_logado and nome_usuario:
            caminho = os.path.join(self.caminho_recursos, "smile.png")
            self.icone_login.carregar_icone(caminho)
            self.label_nome_usuario.setText(nome_usuario)
            self.label_nome_usuario.show()
        else:
            caminho = os.path.join(self.caminho_recursos, "log-in.png")
            self.icone_login.carregar_icone(caminho)
            self.label_nome_usuario.hide()

    def _ao_clicar_icone(self, identificador):
        """Slot interno para reemitir o sinal do Ã­cone clicado."""
        print(f"ğŸ“¡ GerenciadorIconesEsquerda: Ãcone '{identificador}' acionado.")
        self.icone_clicado.emit(identificador)  # Re-emite o sinal para o consumidor (JanelaPrincipal)

    # MÃ©todos para atualizar Ã­cones, se necessÃ¡rio (ex: login/logout)
    def atualizar_icone(self, identificador, novo_caminho):
        """Atualiza a imagem de um Ã­cone existente."""
        if identificador in self.icones:
            self.icones[identificador].carregar_icone(novo_caminho)
        else:
            print(f"âš ï¸ GerenciadorIconesEsquerda: Ãcone '{identificador}' nÃ£o encontrado para atualizar.")


================================================================================
ğŸ“„ client/components/__init__.py
================================================================================


================================================================================
ğŸ“„ shared/polygons.py
================================================================================
import math
import numpy

def dicionario_poligonos(fator):

    def icosaedro():
        
        def triangulo_original():
            
            def primeira_definicao_pontos():
                lista_pontos = []
                for x in range(fator ** 2):
                    if x % 2 == 0:
                        coord_x = x / 2 + 0.5
                        coord_y = math.sin(math.pi / 6)
                    else:
                        coord_x = x / 2 + 0.5
                        coord_y = math.sqrt(3) / 3
                    lista_pontos.append((round(coord_x, 15), round(coord_y, 15)))
                return lista_pontos
            
            def ponto_por_linha():
                lista_pontos = [0]
                ppf = fator * 2 - 1
                una = fator * 2 - 1
                while una != 1:
                    lista_pontos.append(ppf)
                    ppf += una - 2
                    una -= 2
                return lista_pontos

            def processar_coordenadas(coordenadas, indices):
                r = math.sqrt(3) / 3
                h = math.sqrt(0.75) * fator
                coords = []
                for i in range(len(indices)):
                    if i == len(indices) - 1:
                        segmento = [coordenadas[-1]]
                    else:
                        inicio, fim = indices[i], indices[i + 1]
                        segmento = coordenadas[inicio:fim]
                    for x in range(len(segmento)):
                        coefy = math.sin(math.pi / 6) * r
                        cx = (0.5 * i + 0.5 * x) + 0.5 - fator / 2
                        if x % 2 == 0:
                            cy = 0 + math.sqrt(0.75) * i + coefy - h / 2
                        else:
                            cy = r - coefy + math.sqrt(0.75) * i + coefy - h / 2
                        coords.append((cx, cy))
                return coords
            return processar_coordenadas(primeira_definicao_pontos(), ponto_por_linha())

        to = triangulo_original()

        def triangulos_equatoriais_em_pe():
            raio = fator / (2 * math.sin(math.pi / 5))
            apotema = fator / (2 * math.tan(math.pi / 5))
            theta = math.asin((raio - apotema) / fator)
            h = fator * math.sqrt(0.75)
            t1 = [(x, math.cos(theta) * y, math.sin(theta) * y) for x, y in to]
            t1 = [(x, y, z + apotema + math.sin(theta) * h / 2) for x, y, z in t1]
            return t1

        t1 = triangulos_equatoriais_em_pe()

        def rotacionar_em_torno_do_eixo_y(coordenadas, angulo_graus):
            angulo_radianos = math.radians(angulo_graus)
            cos_theta = math.cos(angulo_radianos)
            sin_theta = math.sin(angulo_radianos)
            coordenadas_rotacionadas = []
            for x, y, z in coordenadas:
                x_novo = cos_theta * x + sin_theta * z
                y_novo = y
                z_novo = -sin_theta * x + cos_theta * z
                coordenadas_rotacionadas.append((x_novo, y_novo, z_novo))
            return coordenadas_rotacionadas

        t2 = rotacionar_em_torno_do_eixo_y(t1, 72)
        t3 = rotacionar_em_torno_do_eixo_y(t1, 144)
        t4 = rotacionar_em_torno_do_eixo_y(t1, 216)
        t5 = rotacionar_em_torno_do_eixo_y(t1, 288)

        def triangulos_equatoriais_invertidos():
            raio = fator / (2 * math.sin(math.pi / 5))
            apotema = fator / (2 * math.tan(math.pi / 5))
            theta = math.asin((raio - apotema) / fator)
            h = fator * math.sqrt(0.75)
            t6 = [(x, -y) for x, y in to]
            t6 = [(x, math.cos(theta) * y, math.sin(theta) * -y) for x, y in t6]
            t6 = [(x, y, z + apotema + math.sin(theta) * h / 2) for x, y, z in t6]
            return t6

        tr = triangulos_equatoriais_invertidos()
        t6 = rotacionar_em_torno_do_eixo_y(tr, 36)
        t7 = rotacionar_em_torno_do_eixo_y(tr, 108)
        t8 = rotacionar_em_torno_do_eixo_y(tr, 180)
        t9 = rotacionar_em_torno_do_eixo_y(tr, 252)
        t10 = rotacionar_em_torno_do_eixo_y(tr, 324)

        def triangulos_polares_norte():
            alpha = math.acos(1 / (2 * math.tan(math.pi / 5) * math.sqrt(0.75)))
            apotema = fator / (2 * math.tan(math.pi / 5))
            h = fator * math.sqrt(0.75)
            deslocamento = apotema - math.cos(alpha) * h / 2
            raio = fator / (2 * math.sin(math.pi / 5))
            theta = math.asin((raio - apotema) / fator)
            deslocamento_vertical = (math.cos(theta) * h / 2) + (math.sin(alpha) * h / 2)
            tr = [(x, 0, -y) for x, y in to]
            tr = [(x, math.sin(alpha) * -z + deslocamento_vertical,
                z * math.cos(alpha) + deslocamento) for x, y, z in tr]
            return tr

        tr = triangulos_polares_norte()

        t11 = rotacionar_em_torno_do_eixo_y(tr, 36)
        t12 = rotacionar_em_torno_do_eixo_y(tr, 108)
        t13 = rotacionar_em_torno_do_eixo_y(tr, 180)
        t14 = rotacionar_em_torno_do_eixo_y(tr, 252)
        t15 = rotacionar_em_torno_do_eixo_y(tr, 324)

        def triangulos_polares_sul():
            alpha = math.acos(1 / (2 * math.tan(math.pi / 5) * math.sqrt(0.75)))
            apotema = fator / (2 * math.tan(math.pi / 5))
            h = fator * math.sqrt(0.75)
            deslocamento = apotema - math.cos(alpha) * h / 2
            raio = fator / (2 * math.sin(math.pi / 5))
            theta = math.asin((raio - apotema) / fator)
            deslocamento_vertical = (math.cos(theta) * h / 2) + (math.sin(alpha) * h / 2)
            t16 = [(x, 0, -y) for x, y in to]
            t16 = [(x, math.sin(alpha) * z - deslocamento_vertical,
                    z * math.cos(alpha) + deslocamento) for x, y, z in t16]
            return t16

        t16 = triangulos_polares_sul()
        t17 = rotacionar_em_torno_do_eixo_y(t16, 72)
        t18 = rotacionar_em_torno_do_eixo_y(t16, 144)
        t19 = rotacionar_em_torno_do_eixo_y(t16, 216)
        t20 = rotacionar_em_torno_do_eixo_y(t16, 288)
        return [t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20]

    def esfera(pontos, raio):

        def projetar_ponto_na_esfera(ponto, raio):
            x, y, z = ponto
            magnitude = math.sqrt(x**2 + y**2 + z**2)
            return (
                raio * x / magnitude,
                raio * y / magnitude,
                raio * z / magnitude
            )

        return [[projetar_ponto_na_esfera(ponto, raio) for ponto in lista] for lista in pontos]

    esfera = esfera(icosaedro(), fator)

    def poligonos():
        poligonos = []
        
        def ponto_por_linha():
            lista_pontos = [0]
            ppf = fator * 2 - 1
            una = fator * 2 - 1
            while una != 1:
                lista_pontos.append(ppf)
                ppf += una - 2
                una -= 2
            return lista_pontos

        p = ponto_por_linha()

        def hexagonos_centrais():
            hexagonos = []
            for t in esfera:
                i = 0
                for x in range(fator - 2, 0, -1):
                    for y in range(x):
                        hexagonos.append(numpy.array([
                            t[p[y] + i * 2 + 1],
                            t[p[y] + i * 2 + 2],
                            t[p[y] + i * 2 + 3],
                            t[p[y + 1] + i * 2 + 2],
                            t[p[y + 1] + i * 2 + 1],
                            t[p[y + 1] + i * 2]
                        ]))
                    i += 1
            return hexagonos

        poligonos.append(hexagonos_centrais())

        def hexagonos_tropicais_sul():
            hexagonos = []
            for x in range(5):
                for y in range(fator - 1):
                    hexagonos.append(numpy.array([
                        esfera[x][y * 2],
                        esfera[x][y * 2 + 1],
                        esfera[x][y * 2 + 2],
                        esfera[x + 15][y * 2 + 2],
                        esfera[x + 15][y * 2 + 1],
                        esfera[x + 15][y * 2]
                    ]))
            return hexagonos

        poligonos.append(hexagonos_tropicais_sul())

        def hexagonos_tropicais_norte():
            hexagonos = []
            for x in range(5, 10, 1):
                for y in range(fator - 1):
                    hexagonos.append(numpy.array([
                        esfera[x][y * 2],
                        esfera[x][y * 2 + 1],
                        esfera[x][y * 2 + 2],
                        esfera[x + 5][y * 2 + 2],
                        esfera[x + 5][y * 2 + 1],
                        esfera[x + 5][y * 2]
                    ]))
            return hexagonos

        poligonos.append(hexagonos_tropicais_norte())

        def hexagonos_equatoriais_ascendentes():
            hexagonos = []
            for x in range(5):
                for y in range(fator - 1):
                    if x == 0:
                        hexagonos.append(numpy.array([
                            esfera[x][p[y]],
                            esfera[x][p[y] + 1],
                            esfera[x][p[y + 1]],
                            esfera[x + 9][p[fator - y - 1] - 1],
                            esfera[x + 9][p[fator - y - 1] - 2],
                            esfera[x + 9][p[fator - y - 1] + 2 * y]
                        ]))
                    else:
                        hexagonos.append(numpy.array([
                            esfera[x][p[y]],
                            esfera[x][p[y] + 1],
                            esfera[x][p[y + 1]],
                            esfera[x + 4][p[fator - y - 1] - 1],
                            esfera[x + 4][p[fator - y - 1] - 2],
                            esfera[x + 4][p[fator - y - 1] + 2 * y]
                        ]))
            return hexagonos

        poligonos.append(hexagonos_equatoriais_ascendentes())

        def hexagonos_equatoriais_descendentes():
            hexagonos = []
            for x in range(5):
                for y in range(fator - 1):
                    hexagonos.append(numpy.array([
                        esfera[x][p[fator - 1 - y] + 2 * y],
                        esfera[x][p[fator - 1 - y] - 2],
                        esfera[x][p[fator - 1 - y] - 1],
                        esfera[x + 5][p[y + 1]],
                        esfera[x + 5][p[y] + 1],
                        esfera[x + 5][p[y]]
                    ]))
            return hexagonos

        poligonos.append(hexagonos_equatoriais_descendentes())

        def hexagonos_polares_norte():
            hexagonos = []
            for x in range(10, 15, 1):
                for y in range(fator - 1):
                    if x == 10:
                        hexagonos.append(numpy.array([
                            esfera[x][p[y]],
                            esfera[x][p[y] + 1],
                            esfera[x][p[y + 1]],
                            esfera[x + 4][p[y + 1] + (fator - y - 2) * 2],
                            esfera[x + 4][p[y + 1] - 2],
                            esfera[x + 4][p[y + 1] - 1]
                        ]))
                    else:
                        hexagonos.append(numpy.array([
                            esfera[x][p[y]],
                            esfera[x][p[y] + 1],
                            esfera[x][p[y + 1]],
                            esfera[x - 1][p[y + 1] + (fator - y - 2) * 2],
                            esfera[x - 1][p[y + 1] - 2],
                            esfera[x - 1][p[y + 1] - 1]
                        ]))
            return hexagonos

        poligonos.append(hexagonos_polares_norte())

        def hexagonos_polares_sul():
            hexagonos = []
            for x in range(15, 20):
                for y in range(fator - 1):
                    if x == 15:
                        hexagonos.append(numpy.array([
                            esfera[x][p[y]],
                            esfera[x][p[y] + 1],
                            esfera[x][p[y + 1]],
                            esfera[x + 4][p[y + 1] + (fator - y - 2) * 2],
                            esfera[x + 4][p[y + 1] - 2],
                            esfera[x + 4][p[y + 1] - 1]
                        ]))
                    else:
                        hexagonos.append(numpy.array([
                            esfera[x][p[y]],
                            esfera[x][p[y] + 1],
                            esfera[x][p[y + 1]],
                            esfera[x - 1][p[y + 1] + (fator - y - 2) * 2],
                            esfera[x - 1][p[y + 1] - 2],
                            esfera[x - 1][p[y + 1] - 1]
                        ]))
            return hexagonos

        poligonos.append(hexagonos_polares_sul())

        def pentagonos():

            pentagonos = []

            def pentagonos_tropicais_sul():
                pentagonos = []
                for x in range(5):
                    if x == 0:
                        pentagonos.append(numpy.array([
                            esfera[0][0],
                            esfera[9][p[fator - 1]],
                            esfera[4][p[1] - 1],
                            esfera[19][p[1] - 1],
                            esfera[15][0]
                        ]))
                    else:
                        pentagonos.append(numpy.array([
                            esfera[x][0],
                            esfera[x + 4][p[fator - 1]],
                            esfera[x - 1][p[1] - 1],
                            esfera[x + 14][p[1] - 1],
                            esfera[x + 15][0]
                        ]))
                return pentagonos

            pentagonos.extend(pentagonos_tropicais_sul())

            def pentagonos_tropicais_norte():
                pentagonos = []
                for x in range(5):
                    if x == 0:
                        pentagonos.append(numpy.array([
                            esfera[0][p[fator - 1]],
                            esfera[5][0],
                            esfera[10][0],
                            esfera[14][p[1] - 1],
                            esfera[9][p[1] - 1]
                        ]))
                    else:
                        pentagonos.append(numpy.array([
                            esfera[x][p[fator - 1]],
                            esfera[x + 5][0],
                            esfera[x + 10][0],
                            esfera[x + 9][p[1] - 1],
                            esfera[x + 4][p[1] - 1]
                        ]))
                return pentagonos

            pentagonos.extend(pentagonos_tropicais_norte())

            def pentagono_polo_norte():
                return numpy.array([
                    esfera[10][p[fator - 1]],
                    esfera[11][p[fator - 1]],
                    esfera[12][p[fator - 1]],
                    esfera[13][p[fator - 1]],
                    esfera[14][p[fator - 1]]
                ])

            pentagonos.append(pentagono_polo_norte())

            def pentagono_polo_sul():
                return numpy.array([
                    esfera[15][p[fator - 1]],
                    esfera[16][p[fator - 1]],
                    esfera[17][p[fator - 1]],
                    esfera[18][p[fator - 1]],
                    esfera[19][p[fator - 1]]
                ])

            pentagonos.append(pentagono_polo_sul())
            
            return pentagonos

        poligonos.append(pentagonos())

        return poligonos

    poligonos = poligonos()

    def dic_pol():
        coord_vert = {}
        h = 0
        for x in range(5):        
            for i, z in enumerate(range(fator - 2, 0, -1)):
                n = fator * 2 - 1
                for a in range(z):
                    coord_vert[(n - a, fator * x + i + 1)] = poligonos[0][h]
                    h += 1

        for x in range(5):
            for i, z in enumerate(range(fator - 2, 0, -1)):
                n = fator + 1
                for a in range(z):
                    coord_vert[(n + a, fator * x + 2 + i + a)] = poligonos[0][h]
                    h += 1

        for x in range(5):
            for i, z in enumerate(range(fator - 2, 0, -1)):
                n = fator - 1
                for a in range(z):
                    coord_vert[(n - a, fator * x + 1 - x * (a + 1) + i)] = poligonos[0][h]
                    h += 1

        for x in range(5):
            b = fator * x + 1 - x
            for i, z in enumerate(range(fator - 2, 0, -1)):
                n = fator * 2 + 1
                for a in range(z):
                    coord_vert[(n + a, b + i - a * x)] = poligonos[0][h]
                    h += 1
        h = 0
        for x in range(5):
            for z in range(fator - 1):
                coord_vert[(fator * 2, fator * x + z + 1)] = poligonos[1][h]
                h += 1
        h = 0
        for x in range(5):
            for z in range(fator - 1):
                coord_vert[(fator, fator * x + z + 1)] = poligonos[2][h]
                h += 1
        h = 0
        for x in range(5):
            for z in range(fator - 1):
                coord_vert[(fator * 2 - z - 1, fator * x)] = poligonos[3][h]
                h += 1
        h = 0
        for x in range(5):
            for z in range(fator - 1):
                coord_vert[(fator + z + 1, fator * x + z + 1)] = poligonos[4][h]
                h += 1
        h = 0
        for x in range(5):
            for z in range(fator - 1):
                coord_vert[(fator - z - 1, (fator - z - 1) * x)] = poligonos[5][h]
                h += 1
        h = 0
        for x in range(5):
            for i, z in enumerate(range(fator - 1, 0, -1)):
                coord_vert[(fator * 2 + i + 1, z * x)] = poligonos[6][h]
                h += 1
        h = 0
        for x in range(5):
            coord_vert[(fator * 2, fator * x)] = poligonos[7][h]
            h += 1
        for x in range(5):
            coord_vert[(fator, fator * x)] = poligonos[7][h]
            h += 1
        coord_vert[(0, 0)] = poligonos[7][h]
        h += 1
        coord_vert[(fator * 3, 0)] = poligonos[7][h]

        return coord_vert
    
    return dic_pol()

================================================================================
ğŸ“„ shared/planet.py
================================================================================
import random
from shared.polygons import dicionario_poligonos
from shared.geography import definir_geografia

class Planeta:
    def __init__(self, fator, bioma):
        self.fator = fator
        self.bioma_inicial = bioma
        self.geografia, self.capitais_players = definir_geografia(dicionario_poligonos(fator), fator, bioma) # capitais = [(int, int), ...]
        random.shuffle(self.capitais_players)
        self.numero_de_jogadores = len(self.capitais_players)
        biomas_invalidos = {"Ice", "Sea", "Ocean", "Coast", bioma}
        capitais_player_set = set(self.capitais_players)
        nodos_validos = [
            n for n in self.geografia.nodes()
            if self.geografia.nodes[n]["bioma"] not in biomas_invalidos and n not in capitais_player_set
        ]
        npn = 27 - len(self.capitais_players)  # Lembrar de evitar npn (paÃ­ses neutros) negativo
        self.capitais_neutros = random.sample(nodos_validos, npn)
        random.shuffle(self.capitais_neutros)
        self.civilizacoes = []


================================================================================
ğŸ“„ shared/geography.py
================================================================================
import networkx
import random
import math
from statistics import mean
from random import choice

# CUSTOS BASE
CUSTOS_BASE = {
    'Ice': 20.0,
    'Mountains': 12.0,
    'Hills': 6.0,
    'Forest': 4.0,
    'Meadow': 3.0,
    'Savanna': 4.0,
    'Desert': 5.0,
    'Coast': 0.8,
    'Sea': 0.6,
    'Ocean': 0.4
}

PENALIDADE_TRANSICAO = 15.0

def letra_grega(placa):
    letras_gregas_dict = {
        "Alpha": "Î‘", "Beta": "Î’", "Gamma": "Î“", "Delta": "Î”",
        "Epsilon": "Î•", "Zeta": "Î–", "Eta": "Î—", "Theta": "Î˜",
        "Iota": "Î™", "Kappa": "Îš", "Lambda": "Î›", "Mu": "Îœ",
        "Nu": "Î", "Xi": "Î", "Omicron": "ÎŸ", "Pi": "Î ",
        "Rho": "Î¡", "Sigma": "Î£", "Tau": "Î¤", "Upsilon": "Î¥",
        "Phi": "Î¦", "Chi": "Î§", "Psi": "Î¨", "Omega": "Î©"
    }
    return letras_gregas_dict.get(placa)

def definir_geografia(poligonos, fator, bioma):

    geografia = networkx.DiGraph()

    for coordenadas in poligonos:
        geografia.add_node(coordenadas)

    def tipo_de_poligono(c):
        if c == (0, 0):
            geografia.nodes[c]['tipo'] = 'pn'
            return "pn"
        elif 0 < c[0] < fator and c[1] % c[0] == 0:
            geografia.nodes[c]['tipo'] = 'ipn'
            return "ipn"
        elif 0 < c[0] < fator and c[1] % c[0] != 0:
            geografia.nodes[c]['tipo'] = 'cpn'
            return "cpn"
        elif c[0] == fator and c[1] % c[0] == 0:
            geografia.nodes[c]['tipo'] = 'ntn'
            return "ntn"
        elif c[0] == fator and c[1] % c[0] != 0:
            geografia.nodes[c]['tipo'] = 'itn'
            return "itn"
        elif fator < c[0] < fator * 2:
            geografia.nodes[c]['tipo'] = 'e'
            return "e"
        elif c[0] == fator * 2 and c[1] % fator != 0:
            geografia.nodes[c]['tipo'] = 'its'
            return "its"
        elif c[0] == fator * 2 and c[1] % fator == 0:
            geografia.nodes[c]['tipo'] = 'nts'
            return "nts"
        elif fator * 2 < c[0] < fator * 3 and c[1] % (fator * 3 - c[0]) != 0:
            geografia.nodes[c]['tipo'] = 'cps'
            return "cps"
        elif fator * 2 < c[0] < fator * 3 and c[1] % (fator * 3 - c[0]) == 0:
            geografia.nodes[c]['tipo'] = 'ips'
            return "ips"
        elif c[0] == fator * 3:
            geografia.nodes[c]['tipo'] = 'ps'
            return "ps"

    for n in list(geografia.nodes):
        no = tipo_de_poligono(n)
        if no == "pn":
            for y in range(5):
                geografia.add_edge(n, (1, y), direcao=f'S{y+1}')
            continue
        if no == "ps":
            for y in range(5):
                geografia.add_edge(n, (fator * 3 - 1, y), direcao=f'N{y+1}')
            continue
        x = n[1] // n[0]
        y = n[1] // (fator * 3 - n[0])
        if no == "ipn":
            if n[1] != n[0] * 5 - 1:
                geografia.add_edge(n, (n[0] + 1, n[1] + x), direcao='S')
                geografia.add_edge(n, (n[0] + 1, n[1] + x + 1), direcao='SE')
                geografia.add_edge(n, (n[0], n[1] + 1), direcao='E')
                geografia.add_edge(n, (n[0] - 1, n[1] - x), direcao='N')
                geografia.add_edge(n, (n[0], n[1] - 1), direcao='W') if n[1] != 0 else geografia.add_edge(n, (n[0], n[0] * 5 - 1), direcao='W')
                geografia.add_edge(n, (n[0] + 1, n[1] + x - 1), direcao='SW') if n[1] != 0 else \
                                        geografia.add_edge(n, (n[0] + 1, (n[0] + 1) * 5 - 1), direcao='SW')
            else:
                geografia.add_edge(n, (n[0] + 1, n[1] + x), direcao='S')
                geografia.add_edge(n, (n[0] + 1, n[1] + x + 1), direcao='SE')
                geografia.add_edge(n, (n[0], 0), direcao='E')
                geografia.add_edge(n, (n[0] - 1, n[1] - x), direcao='N')
                geografia.add_edge(n, (n[0], n[1] - 1), direcao='W')
                geografia.add_edge(n, (n[0] + 1, n[1] + x - 1), direcao='SW')
        elif no == "cpn":
            if n[1] != n[0] * 5 - 1:
                geografia.add_edge(n, (n[0] + 1, n[1] + x + 1), direcao='SE')
                geografia.add_edge(n, (n[0], n[1] + 1), direcao='E')
                geografia.add_edge(n, (n[0] - 1, n[1] - x), direcao='NE')
                geografia.add_edge(n, (n[0] - 1, n[1] - x - 1), direcao='NW')
                geografia.add_edge(n, (n[0], n[1] - 1), direcao='W')
                geografia.add_edge(n, (n[0] + 1, n[1] + x), direcao='SW')
            else:
                geografia.add_edge(n, (n[0] + 1, n[1] + x + 1), direcao='SE')
                geografia.add_edge(n, (n[0], 0), direcao='E')
                geografia.add_edge(n, (n[0] - 1, 0), direcao='NE')
                geografia.add_edge(n, (n[0] - 1, n[1] - x - 1), direcao='NW')
                geografia.add_edge(n, (n[0], n[1] - 1), direcao='W')
                geografia.add_edge(n, (n[0] + 1, n[1] + x), direcao='SW')
        elif no == "ntn":
            geografia.add_edge(n, (n[0] + 1, n[1]), direcao='SW')
            geografia.add_edge(n, (n[0] + 1, n[1] + 1), direcao='SE')
            geografia.add_edge(n, (n[0], n[1] + 1), direcao='NE')
            geografia.add_edge(n, (n[0] - 1, n[1] - x), direcao='N')
            geografia.add_edge(n, (n[0], n[1] - 1), direcao='NW') if n[1] != 0 else geografia.add_edge(n, (n[0], n[0] * 5 - 1), direcao='NW')
        elif no == "itn":
            if n[1] != fator * 5 - 1:
                geografia.add_edge(n, (n[0] + 1, n[1]), direcao='SW')
                geografia.add_edge(n, (n[0] + 1, n[1] + 1), direcao='NE')
                geografia.add_edge(n, (n[0], n[1] + 1), direcao='E')
                geografia.add_edge(n, (n[0] - 1, n[1] - x), direcao='NE')
                geografia.add_edge(n, (n[0] - 1, n[1] - x - 1), direcao='NW')
                geografia.add_edge(n, (n[0], n[1] - 1), direcao='W')
            else:
                geografia.add_edge(n, (n[0] + 1, n[1]), direcao='SW')
                geografia.add_edge(n, (n[0] + 1, 0), direcao='NE')
                geografia.add_edge(n, (n[0], 0), direcao='E')
                geografia.add_edge(n, (n[0] - 1, 0), direcao='NE')
                geografia.add_edge(n, (n[0] - 1, n[1] - x - 1), direcao='NW')
                geografia.add_edge(n, (n[0], n[1] - 1), direcao='W')
        elif no == "e":
            if n[1] != fator * 5 - 1:
                geografia.add_edge(n, (n[0] + 1, n[1]), direcao='SW')
                geografia.add_edge(n, (n[0] + 1, n[1] + 1), direcao='SE')
                geografia.add_edge(n, (n[0], n[1] + 1), direcao='E')
                geografia.add_edge(n, (n[0] - 1, n[1]), direcao='NE')
                geografia.add_edge(n, (n[0] - 1, n[1] - 1), direcao='NW') if n[1] != 0 else geografia.add_edge(n, (n[0] - 1, fator * 5 - 1), direcao='NW')
                geografia.add_edge(n, (n[0], n[1] - 1), direcao='W') if n[1] != 0 else geografia.add_edge(n, (n[0], fator * 5 - 1), direcao='W')
            else:
                geografia.add_edge(n, (n[0] + 1, n[1]), direcao='SW')
                geografia.add_edge(n, (n[0] + 1, 0), direcao='SE')
                geografia.add_edge(n, (n[0], 0), direcao='E')
                geografia.add_edge(n, (n[0] - 1, n[1]), direcao='NE')
                geografia.add_edge(n, (n[0] - 1, n[1] - 1), direcao='NW')
                geografia.add_edge(n, (n[0], n[1] - 1), direcao='W')
        elif no == "its":
            if n[1] != fator * 5 - 1:
                geografia.add_edge(n, (n[0] + 1, n[1] - y), direcao='SE')
                geografia.add_edge(n, (n[0], n[1] + 1), direcao='E')
                geografia.add_edge(n, (n[0] - 1, n[1]), direcao='NE')
                geografia.add_edge(n, (n[0] - 1, n[1] - 1), direcao='NW')
                geografia.add_edge(n, (n[0], n[1] - 1), direcao='W')
                geografia.add_edge(n, (n[0] + 1, n[1] - y - 1), direcao='SW')
            else:
                geografia.add_edge(n, (n[0] + 1, 0), direcao='SE')
                geografia.add_edge(n, (n[0], 0), direcao='E')
                geografia.add_edge(n, (n[0] - 1, n[1]), direcao='NE')
                geografia.add_edge(n, (n[0] - 1, n[1] - 1), direcao='NW')
                geografia.add_edge(n, (n[0], n[1] - 1), direcao='W')
                geografia.add_edge(n, (n[0] + 1, n[1] - y - 1), direcao='SW')
        elif no == "nts":
            geografia.add_edge(n, (n[0] + 1, n[1] - y), direcao='S')
            geografia.add_edge(n, (n[0], n[1] + 1), direcao='SE')
            geografia.add_edge(n, (n[0] - 1, n[1]), direcao='NE')
            geografia.add_edge(n, (n[0] - 1, n[1] - 1), direcao='NW') if n[1] != 0 else geografia.add_edge(n, (n[0] - 1, fator * 5 - 1), direcao='NW')
            geografia.add_edge(n, (n[0], n[1] - 1), direcao='SW') if n[1] != 0 else geografia.add_edge(n, (n[0], fator * 5 - 1), direcao='SW')
        elif no == "cps":
            if n[1] != (fator * 3 - n[0]) * 5 - 1:
                geografia.add_edge(n, (n[0] + 1, n[1] - y), direcao='SE')
                geografia.add_edge(n, (n[0], n[1] + 1), direcao='E')
                geografia.add_edge(n, (n[0] - 1, n[1] + y + 1), direcao='NE')
                geografia.add_edge(n, (n[0] - 1, n[1] + y), direcao='NW')
                geografia.add_edge(n, (n[0], n[1] - 1), direcao='W')
                geografia.add_edge(n, (n[0] + 1, n[1] - y - 1), direcao='SW')
            else:
                geografia.add_edge(n, (n[0] + 1, 0), direcao='SE')
                geografia.add_edge(n, (n[0], 0), direcao='E')
                geografia.add_edge(n, (n[0] - 1, n[1] + y + 1), direcao='NE')
                geografia.add_edge(n, (n[0] - 1, n[1] + y), direcao='NW')
                geografia.add_edge(n, (n[0], n[1] - 1), direcao='W')
                geografia.add_edge(n, (n[0] + 1, n[1] - y - 1), direcao='SW')
        elif no == "ips":
            if n[1] != (fator * 3 - n[0]) * 5 - 1:
                geografia.add_edge(n, (n[0] + 1, n[1] - y), direcao='S')
                geografia.add_edge(n, (n[0], n[1] + 1), direcao='SE')
                geografia.add_edge(n, (n[0] - 1, n[1] + y + 1), direcao='NE')
                geografia.add_edge(n, (n[0] - 1, n[1] + y), direcao='N')
                geografia.add_edge(n, (n[0] - 1, n[1] + y - 1), direcao='NW') if n[1] != 0 else \
                                        geografia.add_edge(n, (n[0] - 1, (fator * 3 - n[0] + 1) * 5 - 1), direcao='NW')
                geografia.add_edge(n, (n[0], n[1] - 1), direcao='SW') if n[1] != 0 else \
                                        geografia.add_edge(n, (n[0], (fator * 3 - n[0]) * 5 - 1), direcao='SW')
            else:
                geografia.add_edge(n, (n[0] + 1, n[1] - y), direcao='S')
                geografia.add_edge(n, (n[0], 0), direcao='SE')
                geografia.add_edge(n, (n[0] - 1, n[1] + y + 1), direcao='NE')
                geografia.add_edge(n, (n[0] - 1, n[1] + y), direcao='N')
                geografia.add_edge(n, (n[0] - 1, n[1] + y - 1), direcao='NW')
                geografia.add_edge(n, (n[0], n[1] - 1), direcao='SW')

    areas = list(poligonos.keys())
    areas_sem_definicao = {}
    areas_definidas = {}
    referencias_relevo = random.sample(areas, fator * 20)

    for area in areas:
        areas_sem_definicao[area] = []
        areas_definidas[area] = []

    for n in range(fator * 3 // 2):
        if not areas_sem_definicao:
            break
        for node in referencias_relevo:
            altitude = random.randint(0, 12)
            areas_definidas[node].append(altitude)
            if node in areas_sem_definicao:
                del areas_sem_definicao[node]
            distancias = networkx.single_source_shortest_path_length(geografia, node)
            nos_a_n_arestas = [node for node, distance in distancias.items() if distance == n + 1]
            for neighbor in nos_a_n_arestas:
                if neighbor in areas_sem_definicao and neighbor not in referencias_relevo:
                    areas_sem_definicao[neighbor].append(altitude)
        for chave in list(areas_sem_definicao.keys()):
            if areas_sem_definicao[chave]:
                areas_definidas[chave].append(round(mean(areas_sem_definicao[chave]), 3))
                del areas_sem_definicao[chave]

    chaves = list(areas_definidas.keys())
    random.shuffle(chaves)
    chaves_ordenadas = sorted(chaves, key=lambda chave: areas_definidas[chave])
    percentual_terra = random.randint(35, 45)
    limite_abissal = (100 - percentual_terra) // 2
    limite_barreira = limite_abissal + (100 - percentual_terra) // 3
    nivel_do_mar = 100 - percentual_terra
    limite_planicie = nivel_do_mar + (100 - nivel_do_mar) * 4 // 6
    limite_planalto = limite_planicie + (100 - limite_planicie) // 2

    for i, chave in enumerate(chaves_ordenadas):
        if i <= len(chaves_ordenadas) * limite_abissal // 100:
            geografia.nodes[chave]['altitude'] = 'abissal'
        elif i <= len(chaves_ordenadas) * limite_barreira // 100:
            geografia.nodes[chave]['altitude'] = 'barreira'
        elif i <= len(chaves_ordenadas) * nivel_do_mar // 100:
            geografia.nodes[chave]['altitude'] = 'plataforma'
        elif i <= len(chaves_ordenadas) * limite_planicie // 100:
            geografia.nodes[chave]['altitude'] = 'planicie'
        elif i <= len(chaves_ordenadas) * limite_planalto // 100:
            geografia.nodes[chave]['altitude'] = 'planalto'
        else:
            geografia.nodes[chave]['altitude'] = 'cordilheira'

    areas_sem_definicao = {}
    areas_definidas = {}
    referencias_umidade = random.sample(areas, 60)

    for area in areas:
        areas_sem_definicao[area] = []
        areas_definidas[area] = []

    for n in range(fator * 3 // 2):
        if not areas_sem_definicao:
            break
        for node in referencias_umidade:
            altitude = random.randint(0, 12)
            areas_definidas[node].append(altitude)
            if node in areas_sem_definicao:
                del areas_sem_definicao[node]
            distancias = networkx.single_source_shortest_path_length(geografia, node)
            nos_a_n_arestas = [node for node, distance in distancias.items() if distance == n + 1]
            for neighbor in nos_a_n_arestas:
                if neighbor in areas_sem_definicao and neighbor not in referencias_umidade:
                    areas_sem_definicao[neighbor].append(altitude)
        for chave in list(areas_sem_definicao.keys()):
            if areas_sem_definicao[chave]:
                areas_definidas[chave].append(round(mean(areas_sem_definicao[chave]), 3))
                del areas_sem_definicao[chave]

    chaves = list(areas_definidas.keys())
    random.shuffle(chaves)
    chaves_ordenadas = sorted(chaves, key=lambda chave: areas_definidas[chave])

    for i, chave in enumerate(chaves_ordenadas):
        if i <= len(chaves_ordenadas) * 25 // 100:
            geografia.nodes[chave]['umidade'] = 'arido'
        elif i <= len(chaves_ordenadas) * 50 // 100:
            geografia.nodes[chave]['umidade'] = 'semi-arido'
        elif i <= len(chaves_ordenadas) * 75 // 100:
            geografia.nodes[chave]['umidade'] = 'fertil'
        else:
            geografia.nodes[chave]['umidade'] = 'umido'

    # DefiniÃ§Ã£o das placas com dois pontos de referÃªncia cada
    placas = ['Alpha', 'Beta', 'Gamma', 'Delta', 'Epsilon', 'Zeta',
            'Eta', 'Theta', 'Iota', 'Kappa', 'Lambda', 'Mu',
            'Nu', 'Xi', 'Omicron', 'Pi', 'Rho', 'Sigma',
            'Tau', 'Upsilon', 'Phi', 'Chi', 'Psi', 'Omega']
    
    # Gerar duas referÃªncias para cada placa (total 48)
    placas_duplicadas = placas * 2
    random.shuffle(placas_duplicadas)
    referencias_geologia = random.sample(areas, 48)

    # Atribuir cada referÃªncia a uma placa
    areas_definidas = {area: None for area in areas}
    for i, node in enumerate(referencias_geologia):
        areas_definidas[node] = placas_duplicadas[i]

    # Calcular a placa para cada nÃ³ baseado na proximidade
    for node in areas_definidas:
        if areas_definidas[node] is not None:
            continue  # Pula pontos de referÃªncia jÃ¡ definidos
        
        # Encontrar todas as distÃ¢ncias para pontos de referÃªncia
        distancias = []
        for ref in referencias_geologia:
            try:
                dist = networkx.shortest_path_length(geografia, ref, node)
                distancias.append( (ref, dist) )
            except networkx.exception.NetworkXNoPath:
                continue
        
        if not distancias:
            areas_definidas[node] = random.choice(placas)
            continue
        
        # Encontrar a distÃ¢ncia mÃ­nima
        min_dist = min(d[1] for d in distancias)
        candidatos = [d[0] for d in distancias if d[1] == min_dist]
        
        # Escolher aleatoriamente entre candidatos equidistantes
        ref_escolhida = random.choice(candidatos)
        areas_definidas[node] = areas_definidas[ref_escolhida]
    
    coeficiente_movimento = 300

    # Gerar cores para as placas
    cores_placas = []
    for _ in range(24):
        while True:
            r = random.randint(0, 255)
            g = random.randint(0, 255)
            b = random.randint(0, 255)
            if (r + g + b) > 127.5:
                cores_placas.append((r, g, b))
                break

    latitude_equador = fator * 3 / 2

    for chave, valor in areas_definidas.items():
        geografia.nodes[chave]['placa'] = valor
        geografia.nodes[chave]['cor_placa'] = cores_placas[placas.index(valor)]
        geografia.nodes[chave]['letra_grega'] = letra_grega(geografia.nodes[chave]['placa'])
        if chave[0] < latitude_equador:
            distancia_para_equador = latitude_equador - chave[0]
            angulo = distancia_para_equador * 90 / latitude_equador
            incidencia_solar = math.cos(math.radians(angulo))
        elif chave[0] == latitude_equador:
            distancia_para_equador = 0
            angulo = distancia_para_equador * 90 / latitude_equador
            incidencia_solar = math.cos(math.radians(angulo))
        else:
            distancia_para_equador = chave[0] - latitude_equador
            angulo = distancia_para_equador * 90 / latitude_equador
            incidencia_solar = math.cos(math.radians(angulo))
        if geografia.nodes[chave]['altitude'] == 'abissal' \
        or geografia.nodes[chave]['altitude'] == 'barreira' \
        or geografia.nodes[chave]['altitude'] == 'plataforma':
            fator_altitude = 3
        elif geografia.nodes[chave]['altitude'] == 'planicie':
            fator_altitude = 1
        elif geografia.nodes[chave]['altitude'] == 'planalto':
            fator_altitude = -1
        elif geografia.nodes[chave]['altitude'] == 'cordilheira':
            fator_altitude = -3
        if geografia.nodes[chave]['umidade'] == 'umido':
            fator_umidade = 1.5
        elif geografia.nodes[chave]['umidade'] == 'fertil':
            fator_umidade = 0.5
        elif geografia.nodes[chave]['umidade'] == 'semi-arido':
            fator_umidade = -0.5
        elif geografia.nodes[chave]['umidade'] == 'arido':
            fator_umidade = -1.5
        geografia.nodes[chave]['temperatura'] = round(40 * incidencia_solar - 8 + fator_altitude + fator_umidade, 1) - 4

    for node, atributos in geografia.nodes(data=True):
        temperatura = atributos.get('temperatura')
        altitude = atributos.get('altitude')
        umidade = atributos.get('umidade')
        
        if temperatura < 0:
            atributos['bioma'] = 'Ice'
        else:
            if altitude == 'cordilheira':
                atributos['bioma'] = 'Mountains'
            elif altitude == 'planalto':
                atributos['bioma'] = 'Hills'
            elif altitude == 'planicie':
                if umidade == 'umido':
                    atributos['bioma'] = 'Forest'
                elif umidade == 'fertil':
                    atributos['bioma'] = 'Meadow'
                elif umidade == 'semi-arido':
                    atributos['bioma'] = 'Savanna'
                else:
                    atributos['bioma'] = 'Desert'
            elif altitude == 'plataforma':
                atributos['bioma'] = 'Coast'
            elif altitude == 'barreira':
                atributos['bioma'] = 'Sea'
            else:
                atributos['bioma'] = 'Ocean'
        
        # Aplica custo base diretamente do dicionÃ¡rio
        atributos['cust_mob'] = CUSTOS_BASE[atributos['bioma']] * coeficiente_movimento

    for u, v in geografia.edges():
        mob_u = geografia.nodes[u]['cust_mob']
        mob_v = geografia.nodes[v]['cust_mob']
        
        u_maritimo = geografia.nodes[u]['bioma'] in ['Coast', 'Sea', 'Ocean']
        v_maritimo = geografia.nodes[v]['bioma'] in ['Coast', 'Sea', 'Ocean']
        
        if u_maritimo != v_maritimo:  # TransiÃ§Ã£o terra-mar
            geografia[u][v]['cust_mob'] = max(mob_u, mob_v) * 2 + PENALIDADE_TRANSICAO * coeficiente_movimento
        else:
            geografia[u][v]['cust_mob'] = (mob_u + mob_v) / 2

        # BÃ´nus para rotas oceÃ¢nicas longas
        if u_maritimo and v_maritimo:
            geografia[u][v]['cust_mob'] *= 0.7

    cores_biomas = {
        'Ocean': (0, 23, 98), 'Sea': (8, 33, 113), 'Coast': (12, 71, 108), 'Meadow': (91, 174, 70), 'Savanna': (231, 190, 141),
        'Forest': (75, 129, 66), 'Desert': (242, 242, 166), 'Hills': (201, 147, 121), 'Mountains': (158, 86, 86), 'Ice': (245, 255, 245)
    }

    bioma_escolhido = []

    for node in geografia.nodes:
        geografia.nodes[node]['cor_bioma'] = cores_biomas[geografia.nodes[node]['bioma']]
        if geografia.nodes[node]['bioma'] == f'{bioma}':
            bioma_escolhido.append(node)

    bioma_escolhido = [n for n, attr in geografia.nodes(data=True) if attr['bioma'] == f'{bioma}']
    lista_capitais = [choice(bioma_escolhido)]
    while len(lista_capitais) < len(bioma_escolhido) // 2:
        d2 = {}
        for candidato in bioma_escolhido:
            if candidato in lista_capitais:
                continue
            d = {}
            for capital in lista_capitais:
                d[capital] = networkx.shortest_path_length(geografia, source=candidato, target=capital, weight='custo_mobilidade')
            d2[candidato] = min(d.values())
        if not d2:  # Se nÃ£o houver candidatos possÃ­veis, o planeta nÃ£o comporta a quantidade desejada
            print("d2 vazio")
            raise ValueError("O planeta nÃ£o comporta essa quantidade de civilizaÃ§Ãµes!")
        maior_valor = max(d2.values())
        chaves_maior_valor = [chave for chave, valor in d2.items() if valor == maior_valor]
        lista_capitais.append(choice(chaves_maior_valor))

    print(f"nÃºmero de {bioma}:", len(bioma_escolhido))
    return geografia, lista_capitais


================================================================================
ğŸ“„ shared/civilization.py
================================================================================
import random
from shared.flags import bandeira

class Civilizacao:
    def __init__(self, ref, indice, nome, player=False, ponto_inicial=None):
        self.player = player
        self.nome = nome
        self.cultura = ref.culturas[indice % len(ref.culturas)]
        self.cor = ref.civs_cores[self.nome]
        self.modalidade_bandeira = random.randint(0, 82)
        self.cores_bandeira = bandeira(self.nome, self.modalidade_bandeira)
        self.ponto_inicial = ponto_inicial
        self.provincias = []
        self.unidades = []

================================================================================
ğŸ“„ shared/province.py
================================================================================
from shared.naming import formar_nome

class Provincia:
    def __init__(self, civilizacao, coordenadas):
        self.civilizacao = civilizacao
        self.coordenadas = coordenadas
        self.nome = formar_nome(civilizacao.cultura)

================================================================================
ğŸ“„ shared/world.py
================================================================================
# shared/world.py
import random
from uuid import uuid4
from shared.references import Referencias
from shared.planet import Planeta
from shared.civilization import Civilizacao
from shared.province import Provincia


class Mundo:
    def __init__(self, fator=4, bioma='Meadow'):
        self.id_mundo = str(uuid4())
        ref = Referencias()
        random.shuffle(ref.culturas)
        lista_de_cores = list(ref.civs_cores.keys())
        random.shuffle(lista_de_cores)
        self.planeta = Planeta(fator=fator, bioma=bioma)
        self.civs = []

        # Criar civilizaÃ§Ãµes com capitais corretas
        for i, capital in enumerate(self.planeta.capitais_players):
            nome = lista_de_cores[i % len(lista_de_cores)]
            civ = Civilizacao(ref, i, nome, True, capital)
            self.civs.append(civ)

        for i, capital in enumerate(self.planeta.capitais_neutros):
            indice = i + len(self.planeta.capitais_players)
            nome = lista_de_cores[indice % len(lista_de_cores)]
            civ = Civilizacao(ref, indice, nome, False, capital)
            self.civs.append(civ)

        # Atribuir provÃ­ncia inicial usando o ponto_inicial de cada civ
        for civ in self.civs:
            provincia = Provincia(civ, civ.ponto_inicial)
            civ.provincias.append(provincia)

================================================================================
ğŸ“„ shared/references.py
================================================================================
class Referencias:
    def __init__(self):
        self.culturas = [
            'English', 'Chinese', 'Spanish',
            'French', 'Indian', 'Russian',
            'Vietnamese', 'Turkish', 'Arabic',
            'Indonesian', 'Persian', 'Hausa',
            'Swahili', 'Portuguese', 'Telugu',
            'Bengali', 'Japanese', 'Marathi',
            'Wu', 'Yue', 'Min',
            'Korean', 'Italian', 'German'
        ]
        self.civs_cores = {
            'Black': (16, 16, 16), 'Midnight Blue': (0, 0, 127), 'Blue': (0, 0, 255),
            'Dark Green': (0, 127, 0), 'Teal': (0, 127, 127), 'Sky Blue': (32, 127, 223),
            'Green': (0, 255, 0), 'Spring Green': (0, 255, 127), 'Cyan': (0, 223, 223),
            'Maroon': (127, 0, 0), 'Purple': (127, 0, 127), 'Violet': (127, 0, 255),
            'Olive': (127, 127, 0), 'Gray': (127, 127, 127), 'Lavender': (127, 127, 255),
            'Chartreuse': (127, 255, 0), 'Light Green': (127, 223, 127), 'Pale Cyan': (127, 255, 255),
            'Red': (234, 33, 37), 'Rose': (255, 0, 127), 'Magenta': (255, 0, 255),
            'Orange': (223, 127, 32), 'Salmon': (255, 127, 127), 'Orchid': (255, 127, 255),
            'Yellow': (255, 255, 0), 'Light Yellow': (255, 255, 127), 'White': (250, 255, 253)
        }

        self.tons_de_pele = [(245, 212, 205), (212, 160, 147), (163, 106, 95), (101, 61, 53)]
        self.tons_de_cabelo = [(209, 195, 2), (140, 106, 0), (99, 55, 26), (52, 48, 47)]

================================================================================
âœ… Total de 32 arquivos incluÃ­dos.
================================================================================