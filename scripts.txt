ARQUIVO DE CÓDIGO CONSOLIDADO
Gerado em: 2025-08-30 13:13:37
Diretório: /home/mariagoreti/quan_qiu_wu_tai
Conteúdo dos scripts principais reunidos.

================================================================================

================================================================================
📁 ESTRUTURA DO PROJETO
================================================================================

📁 .
├── client
│   ├── components
│   │   └── icon_manager.py
│   ├── dialogs
│   │   └── auth_dialog.py
│   ├── rendering
│   │   ├── camera.py
│   │   ├── opengl_widget.py
│   │   ├── planet_renderer.py
│   │   └── shader.py
│   ├── resources
│   ├── states
│   │   └── waiting_room.py
│   ├── widgets
│   │   ├── game_placeholder.py
│   │   ├── offline_setup_overlay.py
│   │   └── waiting_room_overlay.py
│   └── main.py
├── shared
│   ├── civilization.py
│   ├── geography.py
│   ├── planet.py
│   ├── polygons.py
│   ├── province.py
│   ├── references.py
│   └── world.py

================================================================================
📄 CONTEÚDO DOS ARQUIVOS
================================================================================

================================================================================
📄 client/main.py
================================================================================
# client/main.py

import sys
import os
import requests
from PyQt6.QtWidgets import (
    QApplication, QMainWindow, QWidget, QVBoxLayout, QLabel, QPushButton, QHBoxLayout,
    QSizePolicy, QFrame, QMessageBox, QDialog, QFormLayout, QLineEdit, QDialogButtonBox
)
from PyQt6.QtCore import QTimer, Qt
from PyQt6.QtGui import QSurfaceFormat, QFont
from client.components.icon_manager import GerenciadorIconesEsquerda
from client.dialogs.auth_dialog import DialogoAutenticacao
from client.widgets.waiting_room_overlay import WaitingRoomOverlay
from client.widgets.offline_setup_overlay import OfflineSetupOverlay
from client.rendering.opengl_widget import MeuOpenGLWidget

# --- Componente Janela Principal ---
class JanelaPrincipal(QMainWindow):
    """
    Janela principal da aplicação, contendo a UI 2D e o widget OpenGL.
    Layout: Barras Superior/Inferior (5% da altura),
            Laterais (max(320px, 15% da largura)),
            Área Central para o conteúdo OpenGL.
    """

    def __init__(self):
        super().__init__()
        self.setWindowTitle("Global Arena - Cliente PyQt6")

        # === Estado e Controle ===
        self.usuario_logado = self._verificar_login()
        self.loop_ativo = True
        self.overlay_sala = None
        self.polling_timer = None
        self.game_placeholder = None

        # === Dimensões da Tela ===
        screen_geometry = self.screen().availableGeometry()
        screen_width = screen_geometry.width()
        screen_height = screen_geometry.height()
        bar_height = int(screen_height * 0.05)
        sidebar_width = max(320, int(screen_width * 0.15))

        print(f"🎮 Janela PyQt6 criada. Tela: {screen_width}x{screen_height}. "
              f"Barras H: {bar_height}px, Barras V: {sidebar_width}px")

        # === Layout Principal da Janela ===
        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        main_window_layout = QVBoxLayout(central_widget)
        main_window_layout.setContentsMargins(0, 0, 0, 0)
        main_window_layout.setSpacing(0)

        # === Barra Superior ===
        self.barra_superior = self._criar_barra(bar_height, is_horizontal=True, object_name="BarraSuperior")
        layout_barra_superior = QHBoxLayout(self.barra_superior)
        layout_barra_superior.setContentsMargins(10, 5, 10, 5)
        label_status = QLabel("Status: Aguardando...")
        layout_barra_superior.addWidget(label_status)
        layout_barra_superior.addStretch()

        # === Conteúdo Principal (Barra Esquerda + Área Central + Barra Direita) ===
        conteudo_principal_widget = QWidget()
        conteudo_principal_layout = QHBoxLayout(conteudo_principal_widget)
        conteudo_principal_layout.setContentsMargins(0, 0, 0, 0)
        conteudo_principal_layout.setSpacing(0)

        # --- Barra Esquerda (com transparência) ---
        self.barra_esquerda = self._criar_barra(sidebar_width, is_horizontal=False, object_name="BarraEsquerda")
        self.barra_esquerda.setAttribute(Qt.WidgetAttribute.WA_TranslucentBackground)
        self.barra_esquerda.setStyleSheet("""
            #BarraEsquerda {
                background-color: rgba(25, 25, 35, 180);
                border-right: 1px solid #3498db;
            }
            QLabel {
                color: #ecf0f1;
            }
        """)
        layout_esquerda = QVBoxLayout(self.barra_esquerda)
        layout_esquerda.setContentsMargins(0, 0, 0, 0)

        self.gerenciador_icones = GerenciadorIconesEsquerda(caminho_recursos="client/resources")
        self.gerenciador_icones.icone_clicado.connect(self._ao_clicar_icone_lateral)

        if self.usuario_logado:
            try:
                with open("session.txt", "r") as f:
                    nome_usuario = f.read().strip()
                if not nome_usuario:
                    raise ValueError("Nome vazio")
            except Exception as e:
                print(f"❌ Erro ao ler session.txt: {e}")
                nome_usuario = "Player"
            self.gerenciador_icones.atualizar_estado_login(True, nome_usuario)
        else:
            self.gerenciador_icones.atualizar_estado_login(False)

        layout_esquerda.addWidget(self.gerenciador_icones)

        # --- Área Central (OpenGL + Overlay) ---
        area_central_widget = QWidget()
        area_central_layout = QHBoxLayout(area_central_widget)
        area_central_layout.setContentsMargins(0, 0, 0, 0)
        area_central_layout.setSpacing(0)

        # Container OpenGL
        self.opengl_container = QWidget()
        container_layout = QVBoxLayout(self.opengl_container)
        container_layout.setContentsMargins(0, 0, 0, 0)
        container_layout.setSpacing(0)

        # Widget OpenGL
        self.opengl_widget = MeuOpenGLWidget()
        self.opengl_widget.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
        container_layout.addWidget(self.opengl_widget)

        # Overlay de Boas-Vindas (centralizado)
        self.overlay_widget = QWidget(self.opengl_container)
        self.overlay_widget.setAttribute(Qt.WidgetAttribute.WA_TranslucentBackground)
        self.overlay_widget.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents)
        self.overlay_widget.setStyleSheet("background-color: rgba(0, 0, 0, 120); border: none;")

        overlay_layout = QVBoxLayout(self.overlay_widget)
        overlay_layout.setContentsMargins(0, 0, 0, 0)
        overlay_layout.setSpacing(10)
        overlay_layout.setAlignment(Qt.AlignmentFlag.AlignCenter)

        # Labels (mantidos como antes)
        self.label_welcome = QLabel("Welcome to")
        font_welcome = QFont()
        font_welcome.setPointSize(14)
        font_welcome.setItalic(True)
        font_welcome.setWeight(500)
        self.label_welcome.setFont(font_welcome)
        self.label_welcome.setStyleSheet("color: #aaaaaa; background: transparent; border: none;")
        self.label_welcome.setAlignment(Qt.AlignmentFlag.AlignCenter)

        self.label_titulo = QLabel("Global Arena")
        font_titulo = QFont()
        font_titulo.setPointSize(48)
        font_titulo.setBold(True)
        font_titulo.setWeight(700)
        self.label_titulo.setFont(font_titulo)
        self.label_titulo.setStyleSheet("""
            color: white;
            background-color: transparent;
            border: none;
            text-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
        """)
        self.label_titulo.setAlignment(Qt.AlignmentFlag.AlignCenter)

        self.label_subtitulo = QLabel("the only one for non-flat-earthers")
        font_subtitulo = QFont()
        font_subtitulo.setPointSize(16)
        font_subtitulo.setItalic(True)
        self.label_subtitulo.setFont(font_subtitulo)
        self.label_subtitulo.setStyleSheet("""
            color: #cccccc;
            background-color: transparent;
            border: none;
            font-style: italic;
        """)
        self.label_subtitulo.setAlignment(Qt.AlignmentFlag.AlignCenter)

        overlay_layout.addWidget(self.label_welcome)
        overlay_layout.addWidget(self.label_titulo)
        overlay_layout.addWidget(self.label_subtitulo)

        # --- Ajuste de Tamanho e Posição do Overlay ---
        def _safe_resize_event(event):
            self.overlay_widget.setGeometry(self.opengl_container.rect())
            self.overlay_widget.raise_()
            if hasattr(self, 'overlay_sala') and self.overlay_sala:
                self._ajustar_overlay_sala()
                self.overlay_sala.raise_()
            QWidget.resizeEvent(self.opengl_container, event)

        self.opengl_container.resizeEvent = _safe_resize_event

        # Mostrar overlay imediatamente
        self.overlay_widget.setGeometry(self.opengl_container.rect())
        self.overlay_widget.raise_()
        self.overlay_widget.show()

        QTimer.singleShot(50, lambda: [
            self.overlay_widget.setGeometry(self.opengl_container.rect()),
            self.overlay_widget.raise_(),
            self.overlay_widget.show()
        ])

        # Adicionar OpenGL ao layout central
        area_central_layout.addWidget(self.opengl_container)

        # --- Barra Direita (com transparência, mesma aparência da esquerda) ---
        self.barra_direita = self._criar_barra(sidebar_width, is_horizontal=False, object_name="BarraDireita")
        self.barra_direita.setAttribute(Qt.WidgetAttribute.WA_TranslucentBackground)
        self.barra_direita.setStyleSheet("""
            #BarraDireita {
                background-color: rgba(25, 25, 35, 180);
                border-left: 1px solid #3498db;
            }
            QLabel {
                color: #ecf0f1;
            }
        """)

        layout_direita = QVBoxLayout(self.barra_direita)
        layout_direita.addStretch()
        banner_placeholder = QLabel("Banner\n300x600")
        banner_placeholder.setFixedSize(300, 600)
        banner_placeholder.setStyleSheet("""
            background-color: rgba(30, 30, 40, 200);
            color: white;
            border: 1px solid #555;
            border-radius: 8px;
            font-size: 14px;
        """)
        banner_placeholder.setAlignment(Qt.AlignmentFlag.AlignCenter)
        layout_direita.addWidget(banner_placeholder, alignment=Qt.AlignmentFlag.AlignCenter)
        layout_direita.addStretch()

        # --- Adicionar widgets à área central ---
        area_central_layout.addWidget(self.opengl_container)
        area_central_layout.addWidget(self.barra_direita)

        # --- Adicionar barra esquerda e área central ao conteúdo principal ---
        conteudo_principal_layout.addWidget(self.barra_esquerda)
        conteudo_principal_layout.addWidget(area_central_widget)

        # === Barra Inferior ===
        self.barra_inferior = self._criar_barra(bar_height, is_horizontal=True, object_name="BarraInferior")
        self.barra_inferior.setAttribute(Qt.WidgetAttribute.WA_TranslucentBackground)
        self.barra_inferior.setStyleSheet("""
            #BarraInferior {
                background-color: rgba(25, 25, 35, 180);
                border-top: 1px solid #3498db;
            }
            QLabel {
                color: #ecf0f1;
            }
        """)
        layout_barra_inferior = QHBoxLayout(self.barra_inferior)
        layout_barra_inferior.addWidget(QLabel("Barra Inferior"))

        # === Montagem Final da Janela ===
        main_window_layout.addWidget(self.barra_superior)
        main_window_layout.addWidget(conteudo_principal_widget)
        main_window_layout.addWidget(self.barra_inferior)

        # === Loop de Atualização (60 FPS) ===
        self.timer = QTimer(self)
        self.timer.timeout.connect(self.atualizar_logica)
        self.timer.start(16)

        # === Exibição ===
        self.show()
        self.setWindowState(Qt.WindowState.WindowFullScreen)

        # === Debug Final ===
        print("✅ Janela exibida. Overlay forçado a aparecer.")
        print("🔍 Geometria do container:", self.opengl_container.geometry())
        print("🔍 Geometria do overlay:", self.overlay_widget.geometry())
        print("🔍 Overlay visível?", self.overlay_widget.isVisible())

    def _mostrar_dialogo_modos(self):
        """Exibe um diálogo para escolher entre modo Offline e Online."""
        # Evita múltiplas aberturas do diálogo
        if hasattr(self, '_modo_dialog_aberto') and self._modo_dialog_aberto:
            return
        self._modo_dialog_aberto = True

        modo_dialog = QDialog(self)
        modo_dialog.setWindowTitle("Modo de Jogo")
        modo_dialog.setModal(True)
        modo_dialog.resize(300, 150)
        modo_dialog.setStyleSheet("""
            QDialog {
                background-color: #2c3e50;
                font-family: Arial;
            }
            QLabel {
                color: #ecf0f1;
                font-size: 14px;
                margin-bottom: 15px;
            }
            QPushButton {
                background-color: #3498db;
                color: white;
                border: none;
                padding: 10px;
                border-radius: 6px;
                font-size: 13px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #2980b9;
            }
        """)

        layout = QVBoxLayout()
        layout.setSpacing(10)
        layout.setContentsMargins(20, 20, 20, 20)

        # Título
        label = QLabel("Selecione o modo de jogo:")
        layout.addWidget(label)

        # Botões
        btn_offline = QPushButton("🎮 Offline")
        btn_offline.clicked.connect(lambda: [
            modo_dialog.accept(),
            self._mostrar_overlay_offline()
        ])
        btn_online = QPushButton("🌐 Online")

        layout.addWidget(btn_offline)
        layout.addWidget(btn_online)

        modo_dialog.setLayout(layout)

        # Prevenir aceitação automática
        modo_dialog.accepted.connect(lambda: None)

        def escolher_offline():
            modo_dialog.reject()
            self._modo_dialog_aberto = False
            self._ir_para_tela_pre_jogo(offline=True)

        def escolher_online():
            modo_dialog.reject()
            self._modo_dialog_aberto = False
            if self.usuario_logado:
                self._entrar_na_fila()
            else:
                # Abre o diálogo de login e entra na fila após sucesso
                self._abrir_dialogo_autenticacao_completo(
                    success_callback=lambda username: self._entrar_na_fila()
                )

        # Conectar botões
        btn_offline.clicked.connect(escolher_offline)
        btn_online.clicked.connect(escolher_online)

        # Limpar flag se o diálogo for fechado de outra forma (ex: ESC)
        modo_dialog.finished.connect(lambda: setattr(self, '_modo_dialog_aberto', False))

        modo_dialog.exec()

    def atualizar_logica(self):
        """Atualiza a lógica do jogo e solicita redesenho do OpenGL."""
        if not self.loop_ativo:
            return  # Evita update() se o loop foi desativado

        try:
            if hasattr(self, 'opengl_widget') and self.opengl_widget:
                self.opengl_widget.update()
        except RuntimeError:
            # Widget foi deletado — apenas pare o loop
            self.parar_loop()

    def parar_loop(self):
        """Para o loop de atualização gráfica."""
        self.loop_ativo = False
        if self.timer:
            self.timer.stop()

    def reiniciar_loop(self):
        """Reinicia o loop de atualização gráfica (útil ao voltar ao menu)."""
        if not self.loop_ativo:
            self.loop_ativo = True
            self.timer.start(18)

    def _verificar_login(self):
        """Verifica se o usuário está logado (exemplo: arquivo session.txt existe)."""
        return os.path.exists("session.txt")

    def _criar_barra(self, tamanho, is_horizontal, object_name="Barra"):
        """Cria um widget para representar uma barra, com estilo básico."""
        barra = QFrame()
        barra.setObjectName(object_name)
        if is_horizontal:
            barra.setFixedHeight(tamanho)
        else:
            barra.setFixedWidth(tamanho)
        barra.setStyleSheet(f"""
            #{object_name} {{
                background-color: #2c3e50;
                border: 1px solid #34495e;
            }}
        """)
        return barra

    def atualizar_logica(self):
        """
        Atualiza a lógica do jogo e solicita redesenho do OpenGL.
        """
        self.opengl_widget.update()

    def _ao_clicar_icone_lateral(self, identificador):
        """Lida com os cliques nos ícones da barra lateral esquerda."""
        print(f"🖱️ JanelaPrincipal recebeu clique no ícone: {identificador}")
        if identificador == "login":
            self.on_icone_login()
        elif identificador == "play":
            self.on_icone_play()
        elif identificador == "sair":
            self.on_icone_sair()

    def on_icone_login(self):
        """Ação acionada pelo ícone de login: abre tela de login ou logout."""
        if self.usuario_logado:
            # Já logado → oferece logout
            reply = QMessageBox.question(
                self,
                "Logout",
                "Você está logado. Deseja sair da conta?",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                QMessageBox.StandardButton.No
            )
            if reply == QMessageBox.StandardButton.Yes:
                try:
                    # ✅ Remove sessão
                    if os.path.exists("session.txt"):
                        os.remove("session.txt")
                        print("🗑️ session.txt removed (logout).")
                    # ✅ Atualiza estado
                    self.usuario_logado = False
                    self.gerenciador_icones.atualizar_estado_login(False)
                    # ✅ Feedback opcional (pode ser removido para UX mais limpa)
                    # QMessageBox.information(self, "Logout", "Você saiu com sucesso.")
                except Exception as e:
                    QMessageBox.critical(self, "Erro", f"Falha ao remover sessão: {e}")
        else:
            # Não logado → abre o diálogo completo com login e registro
            dialog = DialogoAutenticacao(self)

            def on_login_sucesso(username: str):
                """Callback chamado após login bem-sucedido."""
                self.usuario_logado = True
                self.gerenciador_icones.atualizar_estado_login(True, username)

            if dialog.exec() == QDialog.DialogCode.Accepted:
                # ✅ O diálogo já garante que o login foi bem-sucedido
                try:
                    with open("session.txt", "r") as f:
                        nome_usuario = f.read().strip()
                    # Atualiza UI com o nome do usuário
                    self.usuario_logado = True
                    self.gerenciador_icones.atualizar_estado_login(True, nome_usuario)
                except Exception as e:
                    print(f"❌ Erro ao ler session.txt após login: {e}")
                    # Mesmo com erro, o login foi feito — usa fallback
                    self.gerenciador_icones.atualizar_estado_login(True, "Player")

    def on_icone_play(self):
        """Action triggered by the 'Play' icon: checks server state before acting."""
        print("🔵 [DEBUG] on_icone_play: Início da execução")
        print("Action: 'Play' icon clicked. Checking state...")

        # ✅ Stop render loop before any UI changes
        self.parar_loop()
        print("⏸️ [DEBUG] on_icone_play: Render loop parado")

        try:
            # ✅ 1. Verificar se o usuário está logado
            username = self._ler_username()
            print(f"🔵 [DEBUG] on_icone_play: Username lido de session.txt: '{username}'")

            if not username:
                print("🟡 [DEBUG] on_icone_play: Nenhum usuário logado. Mostrando diálogo de modos.")
                self._mostrar_dialogo_modos()
                return

            # ✅ 2. CONSULTAR ESTADO ANTES DE LIMPAR
            print("🔵 [DEBUG] on_icone_play: Consultando estado do jogador no servidor...")
            try:
                response = requests.post(
                    "http://localhost:5000/jogo/estado",
                    json={"username": username},
                    timeout=3
                )
                print(f"🟢 [DEBUG] on_icone_play: Resposta de /jogo/estado: {response.status_code} - {response.text}")

                if response.status_code == 200:
                    data = response.json()
                    print(f"🟢 [DEBUG] on_icone_play: Estado recebido: {data}")

                    if data.get("em_partida"):
                        print("⚠️ Jogador já está em partida. Mostrando placeholder...")
                        self.mostrar_tela_jogo()
                        return
                    elif data.get("em_fila"):
                        print("⚠️ Jogador já está na fila. Reexibindo overlay...")
                        # Opcional: reconectar ao estado da fila
                        # self._reconectar_a_fila(data)
                        pass
                else:
                    print(f"🟡 [DEBUG] on_icone_play: /jogo/estado retornou status {response.status_code}")
            except requests.exceptions.ConnectionError:
                print("🔴 [DEBUG] on_icone_play: Falha de conexão com o servidor. Assumindo estado limpo.")
            except requests.exceptions.Timeout:
                print("🔴 [DEBUG] on_icone_play: Tempo de resposta excedido. Assumindo estado limpo.")
            except requests.exceptions.RequestException as e:
                print(f"🔴 [DEBUG] on_icone_play: Falha de rede ao consultar estado: {e}")
            except Exception as e:
                print(f"🔴 [DEBUG] on_icone_play: Erro ao processar resposta de /jogo/estado: {e}")

            # ✅ 3. SE LIVRE, LIMPAR ESTADO E CONTINUAR
            print("🔵 [DEBUG] on_icone_play: Limpando estado do usuário no servidor...")
            try:
                response = requests.post(
                    "http://localhost:5000/jogo/limpar_usuario",
                    json={"username": username},
                    timeout=3
                )
                print(
                    f"🧹 Estado do usuário '{username}' limpo no servidor. Resposta: {response.status_code} - {response.text}")
            except requests.exceptions.ConnectionError:
                print("🟠 [DEBUG] on_icone_play: Servidor offline. Continuando sem limpeza.")
            except requests.exceptions.Timeout:
                print("🟠 [DEBUG] on_icone_play: Timeout ao limpar estado. Continuando.")
            except Exception as e:
                print(f"⚠️ Falha ao limpar estado no servidor: {e}")

            # ✅ 4. MOSTRAR DIÁLOGO DE MODOS
            print("🟢 [DEBUG] on_icone_play: Mostrando diálogo de escolha de modo (offline/online)")
            self._mostrar_dialogo_modos()

        except Exception as e:
            print(f"❌ Erro inesperado em on_icone_play: {e}")
            QMessageBox.critical(self, "Erro", f"Erro inesperado: {e}")
            self._mostrar_dialogo_modos()

        print("🟢 [DEBUG] on_icone_play: Execução concluída")

    def _iniciar_offline(self, escolha, dialog):
        escolha[0] = "offline"
        dialog.accept()

    def _iniciar_online(self, escolha, dialog):
        escolha[0] = "online"
        dialog.accept()

        # Verifica login
        if not self.usuario_logado:
            print("Usuário não logado. Abrindo diálogo de autenticação...")
            self._abrir_dialogo_autenticacao_completo(success_callback=self._on_login_sucesso_pre_jogo)
        else:
            self._ir_para_tela_pre_jogo(offline=False)

    def _on_login_sucesso_pre_jogo(self, username: str):
        """Callback chamado após login bem-sucedido no fluxo de 'play online'."""
        print(f"✅ Login bem-sucedido. Iniciando pré-jogo online para {username}.")
        self._ir_para_tela_pre_jogo(offline=False)

    def _ir_para_tela_pre_jogo(self, offline: bool):
        if offline:
            self._mostrar_overlay_offline()  # ✅ Mostra o overlay de configuração
        else:
            self._entrar_na_fila()

    def on_icone_sair(self):
        """Action triggered by the 'Exit' icon: cleans server state and closes the app."""
        print("Action: 'Exit' icon clicked.")

        # ✅ Stop render loop
        self.parar_loop()

        username = self._ler_username()
        if not username:
            # Se não está logado, fecha direto
            self.close()
            return

        # ✅ 1. Perguntar se quer sair da sala de espera (se estiver em uma)
        if hasattr(self, 'overlay_sala') and self.overlay_sala is not None:
            reply = QMessageBox.question(
                self,
                "Sair da Partida",
                "Você está em uma sala de espera. Sair agora cancelará sua participação.\n\n"
                "Deseja realmente sair?",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                QMessageBox.StandardButton.No
            )
            if reply == QMessageBox.StandardButton.No:
                return  # Cancela o fechamento

        # ✅ 2. Sempre limpar o estado do jogador no servidor
        try:
            response = requests.post(
                "http://localhost:5000/jogo/limpar_usuario",
                json={"username": username},
                timeout=3
            )
            print(f"🧹 Estado do usuário '{username}' limpo no servidor ao sair. {response.text}")
        except requests.exceptions.RequestException as e:
            print(f"⚠️ Falha ao limpar estado ao sair: {e}")
            # Ignora erro — o importante é fechar

        # ✅ 3. Limpeza local: remover overlays e parar polling
        try:
            if hasattr(self, 'overlay_sala') and self.overlay_sala is not None:
                self._esconder_overlay_sala_espera()
        except Exception as e:
            print(f"⚠️ Falha ao remover overlay local: {e}")

        try:
            if hasattr(self, 'polling_timer') and self.polling_timer:
                self.polling_timer.stop()
                self.polling_timer.deleteLater()
                self.polling_timer = None
            print("⏸️ Polling de status da sala interrompido.")
        except Exception as e:
            print(f"⚠️ Falha ao parar polling: {e}")

        # ✅ 4. Fechar o programa
        self.close()

    def _abrir_dialogo_autenticacao_completo(self, success_callback=None):
        """Abre o diálogo completo de autenticação (login + registro)."""
        dialog = DialogoAutenticacao(parent=self)

        def on_login_sucesso(username: str):
            with open("session.txt", "w") as f:
                f.write(username)
            self.usuario_logado = True
            self.gerenciador_icones.atualizar_estado_login(True, username)
            if success_callback:
                success_callback(username)
            dialog.accept()  # Fecha o diálogo

        def tentar_login():
            username = dialog.username_login.text().strip()
            password = dialog.senha_login.text()
            if not username or not password:
                QMessageBox.warning(dialog, "Erro", "Usuário e senha são obrigatórios.")
                return
            try:
                response = requests.post("http://localhost:5000/auth/login",
                                         json={"username": username, "password": password})
                data = response.json()
                if response.status_code == 200 and data.get("success"):
                    on_login_sucesso(username)
                else:
                    QMessageBox.critical(dialog, "Erro", data.get("message", "Login falhou."))
            except requests.exceptions.ConnectionError:
                QMessageBox.critical(dialog, "Erro", "Não foi possível conectar ao servidor.")
            except Exception as e:
                QMessageBox.critical(dialog, "Erro", f"Erro: {str(e)}")

        def tentar_registro():
            username = dialog.username_registro.text().strip()
            password = dialog.senha_registro.text()
            confirmar = dialog.confirmar_senha.text()
            if not username or not password or not confirmar:
                QMessageBox.warning(dialog, "Erro", "Todos os campos são obrigatórios.")
                return
            if password != confirmar:
                QMessageBox.warning(dialog, "Erro", "As senhas não coincidem.")
                return
            if len(password) < 6:
                QMessageBox.warning(dialog, "Erro", "A senha deve ter pelo menos 6 caracteres.")
                return
            try:
                response = requests.post("http://localhost:5000/auth/registrar",
                                         json={"username": username, "password": password})
                data = response.json()
                if response.status_code == 200 and data.get("success"):
                    QMessageBox.information(dialog, "Sucesso", "Conta criada com sucesso! Faça login.")
                    # Preenche o campo de login e muda para aba de login
                    dialog.username_login.setText(username)
                    dialog.abas.setCurrentIndex(0)
                else:
                    QMessageBox.critical(dialog, "Erro", data.get("message", "Falha no registro."))
            except requests.exceptions.ConnectionError:
                QMessageBox.critical(dialog, "Erro", "Não foi possível conectar ao servidor.")
            except Exception as e:
                QMessageBox.critical(dialog, "Erro", f"Erro: {str(e)}")

        # 🔁 Conecta os botões do QDialogButtonBox ao comportamento correto
        # Remover conexão anterior (se houver)
        try:
            dialog.buttons.accepted.disconnect()
        except TypeError:
            pass  # Já desconectado

        # Conecta "OK" ao comportamento da aba atual
        dialog.buttons.accepted.connect(
            lambda: tentar_login() if dialog.abas.currentIndex() == 0 else tentar_registro()
        )

        # "Cancel" já chama reject() → fecha o diálogo
        dialog.exec()

    def _abrir_tela_login(self):
        """Abre um diálogo de login com campos de usuário e senha."""

        dialog = QDialog(self)
        dialog.setWindowTitle("Entrar")
        dialog.setModal(True)
        dialog.resize(300, 120)

        layout = QFormLayout()

        username_input = QLineEdit()
        password_input = QLineEdit()
        password_input.setEchoMode(QLineEdit.EchoMode.Password)

        layout.addRow("Usuário:", username_input)
        layout.addRow("Senha:", password_input)

        buttons = QDialogButtonBox(QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel)
        layout.addRow(buttons)

        dialog.setLayout(layout)

        def tentar_login():
            username = username_input.text().strip()
            password = password_input.text()

            if not username or not password:
                QMessageBox.warning(dialog, "Erro", "Usuário e senha são obrigatórios.")
                return

            # Enviar requisição ao backend Flask
            try:
                response = requests.post(
                    "http://localhost:5000/auth/login",
                    json={"username": username, "password": password}
                )
                data = response.json()

                if response.status_code == 200 and data.get("success"):
                    # Login bem-sucedido
                    with open("session.txt", "w") as f:
                        f.write(username)
                    self.usuario_logado = True
                    # Atualiza UI: ícone + nome
                    self.gerenciador_icones.atualizar_estado_login(True, username)
                    QMessageBox.information(dialog, "Sucesso", f"Bem-vindo, {username}!")
                    dialog.accept()
                else:
                    QMessageBox.critical(dialog, "Erro", data.get("message", "Login falhou."))
            except requests.exceptions.ConnectionError:
                QMessageBox.critical(dialog, "Erro", "Não foi possível conectar ao servidor.")
            except Exception as e:
                QMessageBox.critical(dialog, "Erro", f"Erro inesperado: {e}")

        buttons.accepted.connect(tentar_login)
        buttons.rejected.connect(dialog.reject)

        dialog.exec()

    def _entrar_na_fila(self):
        """Tenta entrar na fila de matchmaking e mostra a tela de espera como overlay.
        Garante limpeza proativa de estado anterior (servidor e cliente).
        """
        print("📞 Chamando /jogo/entrar...")

        # ✅ Evita múltiplas execuções simultâneas
        if hasattr(self, 'entrando_na_fila') and self.entrando_na_fila:
            print("⚠️ Já está entrando na fila. Operação ignorada.")
            return
        self.entrando_na_fila = True

        username = None
        try:
            # 1. Ler o username
            with open("session.txt", "r") as f:
                username = f.read().strip()
            if not username:
                raise FileNotFoundError("Arquivo de sessão vazio.")

            # 2. ✅ Limpeza proativa no servidor: força saída e limpa estado
            try:
                requests.post(
                    "http://localhost:5000/jogo/limpar_usuario",
                    json={"username": username},
                    timeout=3
                )
                print(f"🧹 Estado do usuário '{username}' limpo no servidor.")
            except Exception as e:
                print(f"⚠️ Falha ao limpar estado no servidor (servidor offline?): {e}")
                # Continua mesmo assim — pode ser um teste local

            # 3. ✅ Limpeza local: parar polling e remover overlays
            if hasattr(self, 'polling_timer') and self.polling_timer:
                self.polling_timer.stop()
                self.polling_timer.deleteLater()
                self.polling_timer = None

            # 4. ✅ Forçar remoção do overlay existente
            if hasattr(self, 'overlay_sala') and self.overlay_sala is not None:
                self._esconder_overlay_sala_espera()
            self.overlay_sala = None  # Garante que será recriado

            # 5. ✅ Entrar na fila
            response = requests.post(
                "http://localhost:5000/jogo/entrar",
                json={"modo": "online", "username": username},
                timeout=5
            )
            data = response.json()

            if data.get("success"):
                max_jogadores = data.get("max_jogadores")

                # 6. ✅ Mostrar overlay da sala de espera
                self._mostrar_overlay_sala_espera(username, max_jogadores)

                # 7. ✅ Iniciar polling para atualizar status
                self._iniciar_polling_sala()

                print(f"✅ {username} entrou na fila. Overlay exibido.")
            else:
                QMessageBox.critical(self, "Erro", data.get("message", "Falha ao entrar na fila."))

        except FileNotFoundError:
            QMessageBox.critical(self, "Erro", "Você não está logado.")
        except requests.exceptions.ConnectionError:
            QMessageBox.critical(self, "Erro", "Não foi possível conectar ao servidor.")
        except requests.exceptions.Timeout:
            QMessageBox.critical(self, "Erro", "Tempo de resposta excedido.")
        except Exception as e:
            QMessageBox.critical(self, "Erro", f"Erro inesperado: {e}")
            print(f"❌ Erro em _entrar_na_fila: {e}")
        finally:
            self.entrando_na_fila = False

    def on_partida_iniciada(self):
        """Chamado quando a partida começa.
        Realiza limpeza completa de UI e prepara a transição para o modo de jogo.
        """
        print("🔵 [DEBUG] on_partida_iniciada: Início da execução")

        # ✅ Verificar se já foi chamado (evitar duplicação)
        if hasattr(self, 'partida_iniciada') and self.partida_iniciada:
            print("🟡 [DEBUG] on_partida_iniciada: Já foi chamado anteriormente. Ignorando.")
            return
        self.partida_iniciada = True
        print("🟢 [DEBUG] on_partida_iniciada: Flag 'partida_iniciada' definido como True")

        print("🎮 Partida iniciada: removendo overlays, status e parando polling...")

        # 1. Remover o widget de status da barra lateral (se existir)
        try:
            if hasattr(self, 'gerenciador_icones') and self.gerenciador_icones:
                print("🔵 [DEBUG] on_partida_iniciada: Removendo widget de status da barra lateral")
                self.gerenciador_icones.remover_status_sala()
                print("🗑️ Widget de status da sala removido da barra esquerda.")
            else:
                print("🟡 [DEBUG] on_partida_iniciada: gerenciador_icones não encontrado ou inexistente")
        except Exception as e:
            print(f"⚠️ Falha ao remover status da sala: {e}")

        # 2. Esconder e remover o overlay da sala de espera (se existir)
        try:
            if hasattr(self, 'overlay_sala') and self.overlay_sala is not None:
                print("🔵 [DEBUG] on_partida_iniciada: Overlay da sala de espera detectado. Iniciando remoção...")
                # Usa o mecanismo de fade_out do overlay, se disponível
                if hasattr(self.overlay_sala, 'fade_out'):
                    print("🎨 [DEBUG] on_partida_iniciada: Aplicando fade_out no overlay")
                    self.overlay_sala.fade_out()
                    # Após a animação, esconde e remove
                    from PyQt6.QtCore import QTimer
                    QTimer.singleShot(300, self._esconder_overlay_sala_espera)
                else:
                    print("🎨 [DEBUG] on_partida_iniciada: Sem fade_out. Escondendo diretamente")
                    self._esconder_overlay_sala_espera()
                print("🎨 Overlay da sala de espera removido com sucesso.")
            else:
                print("🟡 [DEBUG] on_partida_iniciada: overlay_sala não encontrado ou já removido")
        except Exception as e:
            print(f"⚠️ Falha ao esconder overlay da sala: {e}")

        # 3. Parar o polling de status (evita chamadas desnecessárias)
        try:
            if hasattr(self, 'polling_timer') and self.polling_timer:
                print("⏸️ [DEBUG] on_partida_iniciada: Parando polling_timer")
                self.polling_timer.stop()
                self.polling_timer.deleteLater()
                self.polling_timer = None
                print("⏸️ Polling de status da sala interrompido.")
            else:
                print("🟡 [DEBUG] on_partida_iniciada: polling_timer não encontrado ou já parado")
        except Exception as e:
            print(f"⚠️ Falha ao parar o polling: {e}")

        # 4. Placeholder: exibir mensagem de partida iniciada
        try:
            print("🟢 [DEBUG] on_partida_iniciada: Exibindo placeholder da partida")
            # ✅ Compatível com o código atual
            QMessageBox.information(self, "Game Started", "Loading Planet...")
            print("🟢 Placeholder de partida exibido: 'Loading Planet...'")

            # ✅ Opcional: ativar modo de jogo no OpenGL (se implementado futuramente)
            if hasattr(self, 'opengl_widget') and self.opengl_widget:
                # Se no futuro você adicionar o método:
                # self.opengl_widget.ativar_modo_jogo()
                # Por enquanto, forçar atualização
                self.opengl_widget.update()
                print("🔵 [DEBUG] on_partida_iniciada: OpenGL widget atualizado")
        except Exception as e:
            print(f"⚠️ Falha ao exibir tela de jogo: {e}")

        # 5. Mensagem final de sucesso
        print("✅ Transição para partida iniciada com sucesso.")
        print("🟢 [DEBUG] on_partida_iniciada: Execução concluída")

    def _mostrar_overlay_sala_espera(self, username: str, max_jogadores: int):
        """
        Mostra o overlay da sala de espera como sobreposição flutuante sobre o OpenGL,
        substituindo o 'Welcome to Global Arena', sem afetar o layout do OpenGL.
        """
        print("🔵 [DEBUG] _mostrar_overlay_sala_espera: Início da execução")
        print(
            f"🟢 [DEBUG] _mostrar_overlay_sala_espera: Tentando mostrar overlay para {username} | max_jogadores: {max_jogadores}")

        # 1. Se já existe um overlay da sala, remova-o corretamente
        if self.overlay_sala is not None:
            print(
                "🟡 [DEBUG] _mostrar_overlay_sala_espera: overlay_sala já existe. Chamando _esconder_overlay_sala_espera()")
            self._esconder_overlay_sala_espera()
        else:
            print("🟢 [DEBUG] _mostrar_overlay_sala_espera: Nenhum overlay existente. Continuando...")

        # 2. Esconder o overlay de boas-vindas
        if self.overlay_widget:
            self.overlay_widget.hide()
            print("🎨 [DEBUG] _mostrar_overlay_sala_espera: overlay_widget (boas-vindas) escondido")
        else:
            print("🟡 [DEBUG] _mostrar_overlay_sala_espera: overlay_widget não encontrado")

        # 3. Criar o novo overlay da sala de espera
        try:
            print("🔵 [DEBUG] _mostrar_overlay_sala_espera: Criando nova instância de WaitingRoomOverlay")
            self.overlay_sala = WaitingRoomOverlay(username, max_jogadores, parent=self.opengl_container)
            print("🟢 [DEBUG] _mostrar_overlay_sala_espera: WaitingRoomOverlay criado com sucesso")
        except Exception as e:
            print(f"❌ Falha ao criar WaitingRoomOverlay: {e}")
            if self.overlay_widget:
                self.overlay_widget.show()  # Restaura se falhar
            return

        # 4. Adicionar como widget filho direto (sem usar layout) → evita interferência no OpenGL
        self.overlay_sala.setParent(self.opengl_container)
        print("🔵 [DEBUG] _mostrar_overlay_sala_espera: overlay_sala definido como filho de opengl_container")

        self.overlay_sala.hide()  # Inicialmente oculto para ajustar posição primeiro
        print("🟡 [DEBUG] _mostrar_overlay_sala_espera: overlay_sala inicialmente oculto para ajuste de posição")

        # 5. Ajustar posição e tamanho com base no container (será refinado após renderização)
        print("🔵 [DEBUG] _mostrar_overlay_sala_espera: Ajustando posição inicial do overlay")
        self._ajustar_overlay_sala()

        # 6. Exibir o overlay
        self.overlay_sala.show()
        self.overlay_sala.raise_()  # Garante que fique na frente
        print("🟢 [DEBUG] _mostrar_overlay_sala_espera: overlay_sala exibido e trazido para frente (raise_)")

        # 7. Conectar o botão Cancelar com a lógica de saída
        def on_cancel():
            print(f"🔵 [DEBUG] on_cancel: {username} clicou em Cancelar")
            try:
                import requests
                response = requests.post(
                    "http://localhost:5000/jogo/sair",
                    json={"username": username},
                    timeout=3
                )
                print(f"📤 {username} saiu da fila via cancelamento. Resposta: {response.status_code}")
            except Exception as e:
                print(f"❌ Falha ao sair da fila: {e}")
            finally:
                # Sempre esconder o overlay após tentar sair
                print("🔵 [DEBUG] on_cancel: Chamando _esconder_overlay_sala_espera()")
                self._esconder_overlay_sala_espera()

        # Conectar o callback ao botão Cancelar
        self.overlay_sala.connect_cancel(on_cancel)
        print("🟢 [DEBUG] _mostrar_overlay_sala_espera: Callback de cancelamento conectado")

        # 8. 👉 Garantir posicionamento pós-renderização (evita geometria 0x0)
        from PyQt6.QtCore import QTimer
        QTimer.singleShot(30, self._ajustar_overlay_sala)
        print("🔵 [DEBUG] _mostrar_overlay_sala_espera: QTimer.singleShot(30) agendado para _ajustar_overlay_sala")

        QTimer.singleShot(60, lambda: self.overlay_sala.raise_() if self.overlay_sala else None)
        print("🔵 [DEBUG] _mostrar_overlay_sala_espera: QTimer.singleShot(60) agendado para garantir raise_()")

        print("🟢 [DEBUG] _mostrar_overlay_sala_espera: Execução concluída")

    def _esconder_overlay_sala_espera(self):
        """Esconde o overlay da sala de espera e restaura o estado inicial."""
        print("🔵 [DEBUG] _esconder_overlay_sala_espera: Início da execução")

        # 1. Parar polling
        if hasattr(self, 'polling_timer') and self.polling_timer:
            self.polling_timer.stop()
            self.polling_timer = None
            print("🟡 [DEBUG] _esconder_overlay_sala_espera: polling_timer já parado ou inexistente")

        # 2. Remover overlay da sala
        if hasattr(self, 'overlay_sala') and self.overlay_sala:
            self.overlay_sala.setParent(None)
            self.overlay_sala.deleteLater()
            self.overlay_sala = None
            print("🎨 [DEBUG] _esconder_overlay_sala_espera: overlay_sala já removido ou inexistente")

        # 3. ✅ Mostrar overlay_widget (boas-vindas) só se NÃO estiver em modo jogo
        if hasattr(self, 'opengl_widget') and not self.opengl_widget.modulo_jogo:
            if hasattr(self, 'overlay_widget') and self.overlay_widget:
                self.overlay_widget.show()
                self.overlay_widget.raise_()
                print("🎨 [DEBUG] _esconder_overlay_sala_espera: overlay_widget (boas-vindas) restaurado")
        else:
            # ✅ Se estiver em modo jogo, NÃO mostre o overlay de boas-vindas
            if hasattr(self, 'overlay_widget') and self.overlay_widget:
                self.overlay_widget.hide()
                print("🎨 [DEBUG] _esconder_overlay_sala_espera: overlay_widget escondido (modo jogo ativo)")

        print("🟢 [DEBUG] _esconder_overlay_sala_espera: Execução concluída")

    def _ajustar_overlay_sala(self):
        """Ajusta posição e tamanho do overlay da sala de espera, garantindo centralização e responsividade.
        Protegido contra chamadas prematuras (ex: geometria 0x0)."""
        if not self.overlay_sala or not self.opengl_container:
            return

        container_rect = self.opengl_container.rect()

        # ✅ Proteção contra chamadas prematuras (tamanho inválido)
        if container_rect.width() < 10 or container_rect.height() < 10:
            print("⚠️ _ajustar_overlay_sala adiado: container ainda não tem dimensões válidas.")
            from PyQt6.QtCore import QTimer
            QTimer.singleShot(20, self._ajustar_overlay_sala)  # Tenta novamente em breve
            return

        # ✅ Calcular dimensões responsivas
        max_width = 500
        min_width = 300
        padding_horizontal = 60
        target_width = min(max_width, container_rect.width() - padding_horizontal)
        width = max(min_width, target_width)  # Garante largura mínima

        height = 300  # Altura fixa suficiente para o conteúdo

        # ✅ Centralizar
        x = (container_rect.width() - width) // 2
        y = (container_rect.height() - height) // 2

        # ✅ Aplicar geometria
        self.overlay_sala.setGeometry(x, y, width, height)
        self.overlay_sala.raise_()  # Garante que fique na frente

        print(f"🎨 Overlay ajustado: ({x}, {y}, {width}x{height}) dentro de {container_rect.size()}")

    def _iniciar_polling_sala(self):
        """Inicia o polling para atualizar o status da sala de espera a cada 1 segundo."""
        from PyQt6.QtCore import QTimer

        print("🔵 [DEBUG] _iniciar_polling_sala: Iniciando ou reiniciando polling")

        # 1. Parar qualquer timer anterior
        if hasattr(self, 'polling_timer') and self.polling_timer:
            print("⏸️ [DEBUG] _iniciar_polling_sala: Parando polling_timer existente")
            self.polling_timer.stop()
            self.polling_timer.deleteLater()
            self.polling_timer = None

        # 2. Criar novo timer
        self.polling_timer = QTimer(self)

        # 3. Conectar ao novo método de atualização
        self.polling_timer.timeout.connect(self._atualizar_status_sala)

        # 4. Iniciar polling
        self.polling_timer.start(1000)  # A cada 1 segundo
        print("🟢 [DEBUG] _iniciar_polling_sala: polling_timer iniciado (1s)")

        # 5. Atualização imediata
        self._atualizar_status_sala()
        print("🟢 [DEBUG] _iniciar_polling_sala: Primeira atualização de status disparada")

    def _atualizar_status_sala(self):
        """Atualiza o status da sala com base na sala do jogador."""
        try:
            username = self._ler_username()
            if not username:
                print("🟡 [DEBUG] _atualizar_status_sala: Nenhum usuário logado. Ignorando.")
                return

            print(f"🔵 [DEBUG] _atualizar_status_sala: Consultando /jogo/minha_sala para {username}")
            response = requests.post(
                "http://localhost:5000/jogo/minha_sala",
                json={"username": username},
                timeout=3
            )
            if response.status_code == 200:
                data = response.json()
                print(f"🟢 [DEBUG] _atualizar_status_sala: Estado recebido: {data}")

                if data.get("em_fila"):
                    jogadores = data["jogadores_na_sala"]
                    vagas = data["vagas"]
                    esta_cheia = data["esta_cheia"]

                    # Atualiza o overlay da sala de espera
                    if hasattr(self, 'overlay_sala') and self.overlay_sala is not None:
                        print(f"🎨 [DEBUG] _atualizar_status_sala: Atualizando overlay para {len(jogadores)}/{vagas}")
                        self.overlay_sala.atualizar_status(len(jogadores), vagas)
                    else:
                        print("🟡 [DEBUG] _atualizar_status_sala: overlay_sala não encontrado")

                    # Se a sala encheu, inicia a partida
                    if esta_cheia:
                        print(
                            f"✅ [DEBUG] _atualizar_status_sala: Sala cheia detectada ({len(jogadores)}/{vagas}). Iniciando partida.")
                        self._esconder_overlay_sala_espera()
                        if hasattr(self, 'polling_timer') and self.polling_timer:
                            self.polling_timer.stop()
                            self.polling_timer.deleteLater()
                            self.polling_timer = None
                            print("⏸️ [DEBUG] _atualizar_status_sala: polling_timer parado")
                        self.on_partida_iniciada()
                else:
                    # Jogador não está mais na fila
                    print("🟡 [DEBUG] _atualizar_status_sala: Jogador não está na fila. Escondendo overlay.")
                    self._esconder_overlay_sala_espera()
            else:
                print(f"🔴 [DEBUG] _atualizar_status_sala: /jogo/minha_sala retornou status {response.status_code}")

        except requests.exceptions.ConnectionError:
            print("🔴 [DEBUG] _atualizar_status_sala: Falha de conexão com o servidor.")
        except requests.exceptions.Timeout:
            print("🔴 [DEBUG] _atualizar_status_sala: Tempo de resposta excedido.")
        except requests.exceptions.RequestException as e:
            print(f"🔴 [DEBUG] _atualizar_status_sala: Erro de rede: {e}")
        except Exception as e:
            print(f"❌ Erro inesperado em _atualizar_status_sala: {e}")

    def sair_da_partida(self):
        """Sai da partida e volta para o menu principal."""
        if self.game_placeholder:
            self.game_placeholder.setParent(None)
            self.game_placeholder.deleteLater()
            self.game_placeholder = None

        # Restaurar overlay de boas-vindas
        if self.overlay_widget:
            self.overlay_widget.show()
            self.overlay_widget.raise_()

        print("✅ Retornou ao menu principal.")

    def _ler_username(self) -> str:
        """Lê o username do arquivo session.txt. Retorna string vazia se não encontrado."""
        try:
            with open("session.txt", "r", encoding="utf-8") as f:
                username = f.read().strip()
            if username:
                return username
            else:
                print("⚠️ Arquivo session.txt encontrado, mas vazio.")
                return ""
        except FileNotFoundError:
            print("⚠️ Arquivo session.txt não encontrado.")
            return ""
        except Exception as e:
            print(f"❌ Erro ao ler session.txt: {e}")
            return ""

    def resizeEvent(self, event):
        super().resizeEvent(event)

        # Ajustar overlay de boas-vindas
        if hasattr(self, 'overlay_widget') and self.overlay_widget:
            self.overlay_widget.setGeometry(self.opengl_container.rect())
            self.overlay_widget.raise_()

        # Ajustar overlay da sala de espera (se existir)
        if hasattr(self, 'overlay_sala') and self.overlay_sala:
            self._ajustar_overlay_sala()  # Este método já existe
            self.overlay_sala.raise_()

        # Ajustar barra direita (se for flutuante)
        if hasattr(self, 'barra_direita') and self.barra_direita.parent() == self.opengl_container:
            w = self.barra_direita.width()
            h = self.opengl_container.height()
            self.barra_direita.setGeometry(self.opengl_container.width() - w, 0, w, h)
            self.barra_direita.raise_()

        # Forçar atualização do OpenGL
        if hasattr(self, 'opengl_widget'):
            self.opengl_widget.update()

    def _mostrar_overlay_offline(self):
        """Mostra o overlay de configuração offline sobre o OpenGL."""
        print("🔵 [DEBUG] _mostrar_overlay_offline: Exibindo overlay de configuração offline")

        # ✅ Esconder overlay de boas-vindas ANTES de mostrar o offline
        if hasattr(self, 'overlay_widget') and self.overlay_widget:
            self.overlay_widget.hide()

        # Criar ou reutilizar overlay
        if not hasattr(self, 'offline_overlay'):
            self.offline_overlay = OfflineSetupOverlay(parent=self.opengl_container)
            self.offline_overlay.setParent(self.opengl_container)

            # 🔥 CONECTAR O SINAL AQUI, logo após a criação
            self.offline_overlay.on_start.connect(self.on_offline_setup_confirmed)
            print("✅ [DEBUG] Sinal 'on_start' conectado a 'on_offline_setup_confirmed'")
        else:
            self.offline_overlay.show()

        self.offline_overlay.raise_()
        self.offline_overlay.show()

    def on_offline_setup_confirmed(self, fator, bioma):
        """
        Chamado quando o usuário confirma as configurações offline.
        Cria um mundo local e ativa a renderização 3D.
        """
        print(f"🟢 [DEBUG] on_offline_setup_confirmed: Iniciando partida offline | fator={fator}, bioma='{bioma}'")

        # 1. Esconder overlay atual
        if hasattr(self, 'offline_overlay') and self.offline_overlay:
            self.offline_overlay.hide()
            print("🔵 [DEBUG] Overlay de configuração offline escondido.")

        # 2. Criar mundo
        try:
            from shared.world import Mundo
            self.mundo = Mundo(fator=fator, bioma=bioma)
            print(
                f"✅ Mundo criado com sucesso: fator={fator}, bioma='{bioma}', províncias={len(self.mundo.planeta.geografia.nodes)}"
            )
        except Exception as e:
            print(f"❌ Falha ao criar mundo: {e}")
            import traceback
            traceback.print_exc()
            # Opcional: mostrar mensagem ao usuário
            from PyQt6.QtWidgets import QMessageBox
            QMessageBox.critical(self, "Erro", f"Não foi possível criar o mundo: {e}")
            return

        # 3. Enviar para OpenGLWidget
        if hasattr(self, 'opengl_widget') and self.opengl_widget:
            try:
                # ✅ Resetar câmera com base no fator para garantir que o planeta caiba na tela
                if hasattr(self.opengl_widget, 'camera'):
                    self.opengl_widget.camera.resetar(fator)
                    print(f"🔧 [DEBUG] Câmera reposicionada para fator={fator}")

                # ✅ Carregar mundo e ativar modo 3D
                self.opengl_widget.carregar_mundo(self.mundo)
                self.opengl_widget.ativar_modo_jogo()
                self.opengl_widget.update()  # Força renderização
                print("🟢 [DEBUG] Mundo enviado para MeuOpenGLWidget. Modo 3D ativado.")
            except Exception as e:
                print(f"❌ Erro ao carregar mundo no OpenGLWidget: {e}")
        else:
            print("⚠️ [WARN] opengl_widget não encontrado ou não inicializado.")
            return

        # 4. Esconder outros overlays (ex: sala de espera)
        self._esconder_overlay_sala_espera()

        # 5. Log final
        print("✅ Transição para modo offline concluída com sucesso.")

    def on_offline_setup_canceled(self):
        """Chamado ao cancelar. Restaura o overlay de boas-vindas."""
        print("🟡 [DEBUG] Modo offline cancelado. Restaurando overlay de boas-vindas.")

        # Esconder o overlay offline
        if hasattr(self, 'offline_overlay') and self.offline_overlay:
            self.offline_overlay.hide()

        # Mostrar e trazer para frente o overlay de boas-vindas
        if hasattr(self, 'overlay_widget') and self.overlay_widget:
            self.overlay_widget.show()
            self.overlay_widget.raise_()

        # Opcional: forçar update do OpenGL (para garantir render)
        if hasattr(self, 'opengl_widget'):
            self.opengl_widget.update()


# --- Ponto de Entrada da Aplicação ---
def main():
    print("🎮 Inicializando cliente gráfico com PyQt6...")

    # Configurar o formato OpenGL padrão globalmente
    fmt = QSurfaceFormat()
    fmt.setVersion(3, 3)
    fmt.setProfile(QSurfaceFormat.OpenGLContextProfile.CoreProfile)
    fmt.setDepthBufferSize(24)  # ✅ Ativado: necessário para 3D
    fmt.setStencilBufferSize(8)  # ✅ Adicionado: útil para efeitos futuros
    fmt.setSamples(4)  # ✅ Ativado: 4x MSAA para suavização
    fmt.setSwapBehavior(QSurfaceFormat.SwapBehavior.DoubleBuffer)
    fmt.setAlphaBufferSize(8)
    fmt.setRedBufferSize(8)
    fmt.setGreenBufferSize(8)
    fmt.setBlueBufferSize(8)

    QSurfaceFormat.setDefaultFormat(fmt)

    app = QApplication(sys.argv)

    try:
        janela = JanelaPrincipal()
        janela.show()  # Garante que a janela será exibida
        print("✅ Janela principal exibida.")
        sys.exit(app.exec())
    except Exception as e:
        print(f"❌ Erro ao criar/iniciar a janela: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)


if __name__ == "__main__":
    # Cria um arquivo session.txt de placeholder para testar o ícone "logado"
    # with open("session.txt", "w") as f:
    #     f.write("usuario_teste_logado")
    main()

================================================================================
📄 client/widgets/waiting_room_overlay.py
================================================================================
# client/widgets/waiting_room_overlay.py
from PyQt6.QtWidgets import (
    QWidget, QVBoxLayout, QLabel, QPushButton, QFrame, QSizePolicy
)
from PyQt6.QtCore import Qt
from PyQt6.QtGui import QFont


class WaitingRoomOverlay(QWidget):
    """
    Overlay flutuante para exibir a sala de espera no centro da área principal,
    entre as barras laterais, substituindo o 'Welcome to Global Arena'.
    """

    def __init__(self, username: str, max_jogadores: int, parent=None):
        super().__init__(parent)
        self.username = username
        self.max_jogadores = max_jogadores
        self.setup_ui()

    def setup_ui(self):
        # Fundo translúcido escuro
        self.setStyleSheet("background-color: rgba(0, 0, 0, 180);")
        self.setAttribute(Qt.WidgetAttribute.WA_TranslucentBackground)
        self.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)

        # Layout principal com centralização vertical
        layout = QVBoxLayout(self)
        layout.setContentsMargins(20, 15, 20, 15)
        layout.setSpacing(12)
        layout.setAlignment(Qt.AlignmentFlag.AlignCenter)

        # ✅ Adicionar stretch acima para centralizar
        layout.addStretch()

        # --- TÍTULO: Waiting Room ---
        self.label_titulo = QLabel("Waiting Room")
        font_titulo = QFont()
        font_titulo.setPointSize(20)
        font_titulo.setBold(True)
        self.label_titulo.setFont(font_titulo)
        self.label_titulo.setStyleSheet("color: #3498db;")
        self.label_titulo.setAlignment(Qt.AlignmentFlag.AlignCenter)
        layout.addWidget(self.label_titulo)

        # --- SUBTÍTULO: Players: X / 4 ---
        self.label_subtitulo = QLabel(f"Players: 1 / {self.max_jogadores}")
        font_sub = QFont()
        font_sub.setPointSize(14)
        self.label_subtitulo.setFont(font_sub)
        self.label_subtitulo.setStyleSheet("color: #ecf0f1;")
        self.label_subtitulo.setAlignment(Qt.AlignmentFlag.AlignCenter)
        layout.addWidget(self.label_subtitulo)

        # --- CAIXA: Nome do jogador ---
        self.content_frame = QFrame()
        self.content_frame.setStyleSheet("""
            background-color: #2c3e50;
            border: 2px solid #3498db;
            border-radius: 16px;
            padding: 20px;
        """)
        content_layout = QVBoxLayout()
        content_layout.setSpacing(10)

        # ✅ REMOVIDO: self.label_icon = QLabel("🎮") → Não queremos o emoji

        self.label_user = QLabel(f"You: {self.username}")
        self.label_user.setStyleSheet("font-size: 14px; color: #bdc3c7;")
        self.label_user.setAlignment(Qt.AlignmentFlag.AlignCenter)
        content_layout.addWidget(self.label_user)

        self.content_frame.setLayout(content_layout)
        layout.addWidget(self.content_frame)

        # --- BOTÃO CANCEL ---
        self.btn_cancel = QPushButton("Cancel")
        self.btn_cancel.setStyleSheet("""
            QPushButton {
                background-color: #e74c3c;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 6px;
                font-weight: bold;
                font-size: 13px;
            }
            QPushButton:hover {
                background-color: #c0392b;
            }
        """)
        self.btn_cancel.setFixedHeight(35)
        layout.addWidget(self.btn_cancel)

        # ✅ Adicionar stretch abaixo para centralizar
        layout.addStretch()

    def atualizar_status(self, total_na_sala: int, vagas: int):
        """Atualiza o subtítulo com o número de jogadores na sala."""
        self.label_subtitulo.setText(f"Players: {total_na_sala} / {vagas}")

    def connect_cancel(self, callback):
        """Conecta o botão Cancelar a uma função."""
        if callable(callback):
            self.btn_cancel.clicked.connect(callback)

================================================================================
📄 client/widgets/game_placeholder.py
================================================================================
# client/widgets/game_placeholder.py
from PyQt6.QtWidgets import QWidget, QVBoxLayout, QLabel, QPushButton
from PyQt6.QtCore import Qt

class GamePlaceholder(QWidget):
    """Tela temporária que simula o jogo em andamento."""
    def __init__(self, username: str, parent=None):
        super().__init__(parent)
        self.username = username
        self.setup_ui()

    def setup_ui(self):
        layout = QVBoxLayout()
        layout.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.setLayout(layout)

        # Fundo escuro
        self.setStyleSheet("background-color: #1e1e2e; color: white;")

        # Título
        titulo = QLabel("🌍 Partida em Andamento")
        titulo.setStyleSheet("font-size: 28px; font-weight: bold; margin-bottom: 20px;")
        titulo.setAlignment(Qt.AlignmentFlag.AlignCenter)

        # Informações
        info = QLabel(f"Jogador: {self.username}\nModo: Online\nMundo: Global Sphere")
        info.setStyleSheet("font-size: 18px; margin-bottom: 30px;")
        info.setAlignment(Qt.AlignmentFlag.AlignCenter)

        # Botão para sair
        btn_sair = QPushButton("🚪 Sair da Partida")
        btn_sair.setStyleSheet("""
            QPushButton {
                background-color: #d22d72;
                color: white;
                font-size: 16px;
                padding: 10px;
                border-radius: 8px;
            }
            QPushButton:hover {
                background-color: #ff3c8e;
            }
        """)
        btn_sair.clicked.connect(self.on_sair)

        layout.addWidget(titulo)
        layout.addWidget(info)
        layout.addWidget(btn_sair)

    def on_sair(self):
        """Chamado quando o jogador clica em 'Sair'."""
        if hasattr(self.parent(), 'sair_da_partida'):
            self.parent().sair_da_partida()
        else:
            self.hide()

================================================================================
📄 client/widgets/offline_setup_overlay.py
================================================================================
# client/widgets/offline_setup_overlay.py
from PyQt6.QtWidgets import (
    QWidget, QVBoxLayout, QLabel, QPushButton, QComboBox, QSpinBox, QHBoxLayout
)
from PyQt6.QtCore import Qt, pyqtSignal


class OfflineSetupOverlay(QWidget):
    """
    Overlay flutuante para configurar partida offline: escolher fator e bioma.
    Emite sinal `on_start(fator, bioma)` ao clicar em "Iniciar".
    """

    on_start = pyqtSignal(int, str)

    def __init__(self, parent=None):
        super().__init__(parent)
        self.parent_widget = parent
        self.setup_ui()

    def setup_ui(self):
        self.setAttribute(Qt.WidgetAttribute.WA_TranslucentBackground)
        self.setStyleSheet("""
            background-color: rgba(30, 30, 40, 220);
            border-radius: 16px;
            border: 1px solid #3498db;
            color: white;
        """)

        layout = QVBoxLayout()
        layout.setContentsMargins(30, 20, 30, 20)
        layout.setSpacing(20)

        # Título
        title = QLabel("🎮 Modo Offline")
        title.setStyleSheet("font-size: 24px; font-weight: bold; color: #ffffff;")
        title.setAlignment(Qt.AlignmentFlag.AlignCenter)
        layout.addWidget(title)

        # Formulário
        form_layout = QVBoxLayout()
        form_layout.setSpacing(15)

        # Fator
        fator_layout = QHBoxLayout()
        fator_label = QLabel("Fator:")
        fator_label.setStyleSheet("min-width: 80px;")
        self.spin_fator = QSpinBox()
        self.spin_fator.setMinimum(4)  # fator >= 4
        self.spin_fator.setMaximum(99)  # limite técnico alto
        self.spin_fator.setValue(4)  # valor inicial
        self.spin_fator.setAccelerated(True)  # rolagem rápida
        self.spin_fator.setStyleSheet("padding: 6px;")
        fator_layout.addWidget(fator_label)
        fator_layout.addWidget(self.spin_fator)
        form_layout.addLayout(fator_layout)

        # Bioma
        bioma_layout = QHBoxLayout()
        bioma_label = QLabel("Bioma:")
        bioma_label.setStyleSheet("min-width: 80px;")
        self.combo_bioma = QComboBox()
        biomas_permitidos = ["Meadow", "Forest", "Savanna", "Desert", "Hills", "Mountains"]
        self.combo_bioma.addItems(biomas_permitidos)
        self.combo_bioma.setCurrentText("Meadow")
        self.combo_bioma.setStyleSheet("padding: 6px;")
        bioma_layout.addWidget(bioma_label)
        bioma_layout.addWidget(self.combo_bioma)
        form_layout.addLayout(bioma_layout)

        layout.addLayout(form_layout)

        # Botões
        btn_layout = QHBoxLayout()
        self.btn_cancel = QPushButton("Cancelar")
        self.btn_start = QPushButton("Iniciar")

        self.btn_cancel.clicked.connect(self.on_cancel)
        self.btn_start.clicked.connect(self.on_confirm)

        btn_layout.addWidget(self.btn_cancel)
        btn_layout.addWidget(self.btn_start)
        layout.addLayout(btn_layout)

        self.setLayout(layout)

        # Tamanho fixo
        self.setFixedSize(400, 300)

    def on_confirm(self):
        fator = self.spin_fator.value()
        bioma = self.combo_bioma.currentText()
        self.on_start.emit(fator, bioma)  # ✅ Emite o sinal
        self.hide()

    def on_cancel(self):
        if hasattr(self.parent(), 'on_offline_setup_canceled'):
            self.parent().on_offline_setup_canceled()
        self.hide()

    def showEvent(self, event):
        super().showEvent(event)
        if self.parent_widget:
            x = (self.parent_widget.width() - self.width()) // 2
            y = (self.parent_widget.height() - self.height()) // 2
            self.move(x, y)

================================================================================
📄 client/states/waiting_room.py
================================================================================
# client/states/waiting_room.py
from PyQt6.QtWidgets import (
    QWidget, QVBoxLayout, QLabel, QFrame
)
from PyQt6.QtCore import Qt, QTimer, pyqtProperty, QPropertyAnimation, QEasingCurve
from PyQt6.QtGui import QCursor
import requests


class OverlaySalaEspera(QWidget):
    """
    Widget de sobreposição (overlay) para exibir a sala de espera
    diretamente sobre o OpenGL, mantendo a barra de ícones, fundo e estrutura.
    Não substitui a janela principal.
    """

    def __init__(self, username: str, max_jogadores: int, parent=None):
        super().__init__(parent)
        self.username = username
        self.max_jogadores = max_jogadores
        self.parent_widget = parent  # Referência ao widget pai (ex: opengl_container)
        self.timer = None
        self._opacity = 0.0
        self.setCursor(QCursor(Qt.CursorShape.WaitCursor))
        self.setup_ui()
        self.iniciar_polling()

    def _get_opacity(self):
        return self._opacity

    def _set_opacity(self, opacity):
        self._opacity = opacity
        # Atualiza fundo com transparência
        self.setStyleSheet(
            f"background-color: rgba(44, 62, 80, {int(opacity * 180)}); "
            "border-radius: 15px; border: 1px solid #3498db;"
        )

    opacity = pyqtProperty(float, _get_opacity, _set_opacity)

    def setup_ui(self):
        # Layout principal
        layout = QVBoxLayout()
        layout.setSpacing(15)
        layout.setContentsMargins(20, 20, 20, 20)
        layout.setAlignment(Qt.AlignmentFlag.AlignCenter)

        # Título
        titulo = QLabel("🎮 Sala de Espera")
        titulo.setStyleSheet("font-size: 18px; font-weight: bold; color: #ecf0f1;")
        titulo.setAlignment(Qt.AlignmentFlag.AlignCenter)
        layout.addWidget(titulo)

        # Subtítulo
        subtitulo = QLabel("Aguardando outros jogadores entrarem...")
        subtitulo.setStyleSheet("font-size: 13px; color: #bdc3c7;")
        subtitulo.setAlignment(Qt.AlignmentFlag.AlignCenter)
        layout.addWidget(subtitulo)

        # Linha separadora
        linha = QFrame()
        linha.setFrameShape(QFrame.Shape.HLine)
        linha.setFrameShadow(QFrame.Shadow.Sunken)
        linha.setStyleSheet("color: #34495e;")
        layout.addWidget(linha)

        # Status: jogadores na fila
        self.label_status = QLabel("Você entrou na fila...")
        self.label_status.setStyleSheet(
            "font-size: 16px; color: #ecf0f1; background-color: #2c3e50; "
            "padding: 10px; border-radius: 8px;"
        )
        self.label_status.setAlignment(Qt.AlignmentFlag.AlignCenter)
        layout.addWidget(self.label_status)

        # Informação do usuário
        self.label_usuario = QLabel(f"Seu nome: {self.username}")
        self.label_usuario.setStyleSheet("font-size: 13px; color: #95a5a6;")
        self.label_usuario.setAlignment(Qt.AlignmentFlag.AlignCenter)
        layout.addWidget(self.label_usuario)

        self.setLayout(layout)

        # Estilo geral
        self.setFixedWidth(360)
        self.setFixedHeight(220)
        self.setStyleSheet("background-color: rgba(44, 62, 80, 180); border-radius: 15px; border: 1px solid #3498db;")
        self.setAttribute(Qt.WidgetAttribute.WA_TranslucentBackground)
        self.hide()  # Começa oculto

    def iniciar_polling(self):
        """Inicia atualização periódica do status da fila."""
        self.timer = QTimer(self)
        self.timer.timeout.connect(self.atualizar_status)
        self.timer.start(1000)  # A cada 1 segundo
        self.atualizar_status()  # Primeira atualização imediata

    def atualizar_status(self):
        try:
            response = requests.get("http://localhost:5000/status", timeout=3)
            if response.status_code == 200:
                data = response.json()
                total_na_fila = data.get("total_na_fila", 0)
                self.label_status.setText(f"Jogadores na fila: {total_na_fila} / {self.max_jogadores}")
                print(f"📊 Status atual: {total_na_fila} / {self.max_jogadores}")

                if total_na_fila >= self.max_jogadores:
                    self.partida_iniciada()
        except requests.exceptions.ConnectionError:
            self.label_status.setText("❌ Erro de conexão")
        except Exception as e:
            self.label_status.setText(f"❌ Erro: {str(e)}")

    def partida_iniciada(self):
        """Chamado quando a sala está cheia. Evita chamadas duplicadas e garante transição segura."""
        print("🔵 [DEBUG] WaitingRoomOverlay.partida_iniciada: Início da execução")

        # 1. Parar o timer de atualização
        if self.timer:
            print("⏸️ [DEBUG] WaitingRoomOverlay.partida_iniciada: Parando timer de atualização")
            self.timer.stop()
        else:
            print("🟡 [DEBUG] WaitingRoomOverlay.partida_iniciada: Timer já parado ou inexistente")

        # 2. Atualizar o status visual
        print("🎨 [DEBUG] WaitingRoomOverlay.partida_iniciada: Atualizando texto do status")
        self.label_status.setText("✅ Partida iniciada! Carregando mundo...")

        # 3. Verificar se a partida já foi iniciada (evitar duplicação)
        parent = self.parent_widget
        if hasattr(parent, 'game_placeholder') and parent.game_placeholder is not None:
            print(
                "🔴 [DEBUG] WaitingRoomOverlay.partida_iniciada: game_placeholder já existe. Partida já iniciada. Ignorando.")
            self.hide()
            return
        else:
            print("🟢 [DEBUG] WaitingRoomOverlay.partida_iniciada: Nenhum game_placeholder detectado. Continuando...")

        # 4. Chamar a função da janela principal com animação
        if hasattr(parent, 'on_partida_iniciada'):
            print(
                "🔵 [DEBUG] WaitingRoomOverlay.partida_iniciada: on_partida_iniciada encontrado no parent. Iniciando fade_out")

            # Iniciar animação de saída
            self.fade_out()

            # Chamar on_partida_iniciada após a animação
            print("🟡 [DEBUG] WaitingRoomOverlay.partida_iniciada: Agendando parent.on_partida_iniciada em 300ms")
            QTimer.singleShot(300, parent.on_partida_iniciada)
        else:
            print(
                "🔴 [DEBUG] WaitingRoomOverlay.partida_iniciada: parent.on_partida_iniciada não encontrado. Escondendo overlay.")
            # Caso não exista callback, apenas esconder
            self.hide()

        print("🟢 [DEBUG] WaitingRoomOverlay.partida_iniciada: Execução concluída")

    def fade_in(self):
        """Animação de entrada suave."""
        self._opacity = 0.0
        self.show()
        self.raise_()

        anim = QPropertyAnimation(self, b"opacity")
        anim.setDuration(250)
        anim.setStartValue(0.0)
        anim.setEndValue(1.0)
        anim.setEasingCurve(QEasingCurve.Type.InOutCubic)
        anim.start(QPropertyAnimation.DeletionPolicy.DeleteWhenStopped)

    def fade_out(self):
        """Animação de saída suave."""
        anim = QPropertyAnimation(self, b"opacity")
        anim.setDuration(200)
        anim.setStartValue(1.0)
        anim.setEndValue(0.0)
        anim.setEasingCurve(QEasingCurve.Type.InOutCubic)
        anim.start(QPropertyAnimation.DeletionPolicy.DeleteWhenStopped)

    def showEvent(self, event):
        """Reposiciona o overlay no centro do pai ao aparecer."""
        super().showEvent(event)
        if self.parent_widget:
            x = (self.parent_widget.width() - self.width()) // 2
            y = (self.parent_widget.height() - self.height()) // 2
            self.move(x, y)
        # Inicia animação de entrada
        QTimer.singleShot(10, self.fade_in)

    def resizeEvent(self, event):
        """Reposiciona ao redimensionar."""
        super().resizeEvent(event)
        if self.isVisible() and self.parent_widget:
            x = (self.parent_widget.width() - self.width()) // 2
            y = (self.parent_widget.height() - self.height()) // 2
            self.move(x, y)

================================================================================
📄 client/rendering/planet_renderer.py
================================================================================
pass

================================================================================
📄 client/rendering/camera.py
================================================================================
# client/rendering/camera.py
from pyglm import glm

class Camera:
    """
    Câmera orbital 3D para visualização de planetas.
    Permite rotação (orbit), zoom e atualização da matriz de view/projection.
    """

    def __init__(self):
        # Posição inicial: olhando para a origem
        self.center = glm.vec3(0.0, 0.0, 0.0)  # Ponto central (planeta)
        self.distance = 5.0                   # Distância do centro
        self.theta = 0.0                      # Rotação horizontal (Y)
        self.phi = glm.radians(10.0)          # Rotação vertical (X), evita singularity

        self.fov = 45.0                       # Campo de visão
        self.aspect = 1.0                     # Será atualizado com o resize
        self.near = 0.1
        self.far = 100.0

        # Limites
        self.min_distance = 2.0
        self.max_distance = 20.0

    def orbit(self, dtheta: float, dphi: float, dzoom: float = 0.0):
        """
        Atualiza a câmera com variações em theta, phi e zoom.
        Args:
            dtheta: variação em rotação horizontal (mouse x)
            dphi: variação em rotação vertical (mouse y)
            dzoom: variação de zoom (scroll)
        """
        self.theta += dtheta
        self.phi = glm.clamp(self.phi + dphi, 0.01, glm.pi() - 0.01)  # Evita polos

        # Atualiza distância com zoom
        self.distance = glm.clamp(self.distance + dzoom, self.min_distance, self.max_distance)

    def update_position(self):
        """
        Atualiza a posição da câmera com base em theta, phi e distância.
        """
        # Coordenadas esféricas → cartesianas
        x = self.distance * glm.sin(self.phi) * glm.cos(self.theta)
        y = self.distance * glm.cos(self.phi)
        z = self.distance * glm.sin(self.phi) * glm.sin(self.theta)

        self.position = glm.vec3(x, y, z) + self.center

    def view_matrix(self):
        """
        Retorna a matriz de view (modelo de câmera).
        Chamado em paintGL.
        """
        self.update_position()
        return glm.lookAt(self.position, self.center, glm.vec3(0.0, 1.0, 0.0))

    def projection_matrix(self):
        """
        Retorna a matriz de projeção perspectiva.
        """
        return glm.perspective(self.fov, self.aspect, self.near, self.far)

    def set_aspect(self, aspect: float):
        """
        Atualiza o aspect ratio (largura/altura da janela).
        Chamado em resizeGL.
        """
        self.aspect = aspect

    def resetar(self, fator: float):
        """Reposiciona a câmera para enxergar todo o planeta.
        A câmera é colocada a 4× o raio do planeta do centro.
        """
        # Raio do planeta: fator / (2 * sin(π/5))
        raio_planeta = fator / (2 * glm.sin(glm.pi() / 5))

        # Distância do centro: 4× o raio (3× acima da superfície)
        self.distance = 4.0 * raio_planeta

        # Ângulos iniciais
        self.theta = 0.0
        self.phi = glm.radians(30.0)  # Evita olhar diretamente de cima

        # Atualiza posição
        self.update_position()

================================================================================
📄 client/rendering/opengl_widget.py
================================================================================
# client/rendering/opengl_widget.py
import OpenGL.GL as gl
import ctypes
import numpy as np
from pyglm import glm
from PyQt6.QtOpenGLWidgets import QOpenGLWidget
from PyQt6.QtCore import Qt
from client.rendering.camera import Camera


class MeuOpenGLWidget(QOpenGLWidget):
    def __init__(self):
        super().__init__()

        # --- Estado de Renderização ---
        self.modulo_jogo = False  # Ativa renderização do planeta
        self.mundo = None  # Referência ao mundo atual
        self._geometria_necessaria = False  # ✅ Flag: geometria precisa ser criada em paintGL

        # --- Recursos OpenGL ---
        self.shader_program = None  # Programa de shader ativo
        self.VAO = None  # VAO temporário (triângulo de teste)
        self.VBO = None  # VBO temporário (triângulo de teste)

        # --- Geometria do Planeta ---
        self.vaos = {}  # {coord: vao} – um VAO por polígono
        self.vbos = {}  # {coord: vbo} – um VBO por polígono

        # --- Câmera 3D ---
        self.camera = Camera()  # Câmera orbital (posição, rotação, zoom)

        # --- Entrada do Usuário ---
        self.setFocusPolicy(Qt.FocusPolicy.StrongFocus)  # Para eventos de teclado/mouse

        # --- Debug e Estado Interno ---
        # Pronto para expansão (ex: modo de depuração, FPS, etc)

    def initializeGL(self):
        """Configuração inicial do contexto OpenGL.
        - Define estado padrão do pipeline
        - Compila shaders
        - Configura geometria inicial (temporária ou do planeta)
        """
        # === 1. Estado inicial do OpenGL ===
        gl.glClearColor(0.0, 0.0, 0.0, 1.0)  # Fundo preto
        gl.glEnable(gl.GL_DEPTH_TEST)  # Teste de profundidade
        gl.glDepthFunc(gl.GL_LESS)  # Z-test padrão
        gl.glEnable(gl.GL_BLEND)  # Blend para transparência
        gl.glBlendFunc(gl.GL_SRC_ALPHA, gl.GL_ONE_MINUS_SRC_ALPHA)
        gl.glEnable(gl.GL_CULL_FACE)  # Otimização: cull back-face
        gl.glCullFace(gl.GL_BACK)

        print("🎮 Inicializando OpenGL...")

        # === 2. Compilar Shader Program ===
        try:
            vertex_source = """
            #version 330 core
            uniform mat4 MVP;
            layout (location = 0) in vec3 aPos;
            layout (location = 1) in vec3 aColor;
            out vec3 vColor;
            void main() {
                vColor = aColor;
                gl_Position = MVP * vec4(aPos, 1.0);
            }
            """

            fragment_source = """
            #version 330 core
            in vec3 vColor;
            out vec4 FragColor;
            void main() {
                FragColor = vec4(vColor, 1.0);
            }
            """

            from client.rendering.shader import ShaderProgram
            self.shader_program = ShaderProgram(vertex_source, fragment_source)

            if not self.shader_program.program_id:
                raise RuntimeError("Falha ao criar o programa de shader")

        except Exception as e:
            print(f"❌ Erro ao compilar shaders: {e}")
            self.shader_program = None
            return

        # === 3. Configurar Geometria Inicial ===
        try:
            # Se já temos um mundo carregado (ex: durante hot-reload), renderizamos ele
            if hasattr(self, 'mundo') and self.mundo:
                self._criar_geometria_planeta()
            else:
                # Caso contrário, usamos um triângulo temporário para teste
                self._criar_geometria_triângulo()

            print("✅ OpenGL inicializado com sucesso: shaders e geometria prontos.")
        except Exception as e:
            print(f"❌ Erro ao configurar geometria: {e}")
            self.shader_program = None
            self.VAO = None
            self.VBO = None

    def _criar_geometria_triângulo(self):
        vertices = np.array([
            -0.5, -0.5, 0.0,  1.0, 0.0, 0.0,
             0.5, -0.5, 0.0,  0.0, 1.0, 0.0,
             0.0,  0.5, 0.0,  0.0, 0.0, 1.0,
        ], dtype=np.float32)

        self.VAO = gl.glGenVertexArrays(1)
        self.VBO = gl.glGenBuffers(1)

        gl.glBindVertexArray(self.VAO)
        gl.glBindBuffer(gl.GL_ARRAY_BUFFER, self.VBO)
        gl.glBufferData(gl.GL_ARRAY_BUFFER, vertices.nbytes, vertices, gl.GL_STATIC_DRAW)

        stride = 6 * 4  # 3 pos + 3 cor
        gl.glVertexAttribPointer(0, 3, gl.GL_FLOAT, False, stride, None)
        gl.glEnableVertexAttribArray(0)
        gl.glVertexAttribPointer(1, 3, gl.GL_FLOAT, False, stride, ctypes.c_void_p(3 * 4))
        gl.glEnableVertexAttribArray(1)

        gl.glBindBuffer(gl.GL_ARRAY_BUFFER, 0)
        gl.glBindVertexArray(0)

    def resizeGL(self, w: int, h: int):
        """Atualiza viewport e aspecto da câmera."""
        if h > 0:
            self.camera.set_aspect(w / h)
        gl.glViewport(0, 0, w, h)

    def paintGL(self):
        """Renderiza o frame atual.
        - Modo jogo: renderiza o planeta com MVP e câmera orbital
        - Modo espera: apenas limpa o fundo (overlay está por cima)
        """
        # === 1. Limpar buffers ===
        gl.glClear(gl.GL_COLOR_BUFFER_BIT | gl.GL_DEPTH_BUFFER_BIT)

        # === 2. Modo Jogo: Renderizar o planeta ===
        if self.modulo_jogo and self.mundo and self.shader_program and self.shader_program.program_id:
            try:
                # Depuração: estado atual
                print(f"🔧 [DEBUG] paintGL: modulo_jogo={self.modulo_jogo}, mundo={self.mundo is not None}, "
                      f"shader={self.shader_program is not None}, geometria_necessaria={self._geometria_necessaria}")

                # Atualizar aspecto da câmera
                if self.width() > 0 and self.height() > 0:
                    self.camera.set_aspect(self.width() / self.height())

                # Calcular matrizes MVP
                view = self.camera.view_matrix()
                proj = self.camera.projection_matrix()
                model = glm.mat4(1.0)  # Pode ser rotacionado (ex: auto-rotação)
                mvp = proj * view * model

                # Ativar shader e enviar uniform
                self.shader_program.usar()
                self.shader_program.set_uniform_mat4("MVP", glm.value_ptr(mvp))

                # ✅ Criar geometria do planeta no contexto ativo, se necessário
                if self._geometria_necessaria:
                    print("🔧 [DEBUG] Criando geometria do planeta em paintGL...")
                    self._criar_geometria_planeta()
                    self._geometria_necessaria = False
                    print(f"✅ Geometria criada: {len(self.vaos)} polígonos")

                # Renderizar o planeta
                self._renderizar_planeta()

                # Desativar shader
                self.shader_program.limpar()

            except Exception as e:
                print(f"❌ Erro ao renderizar o planeta: {e}")
                # Fundo vermelho para indicar falha crítica
                gl.glClearColor(0.2, 0.0, 0.0, 1.0)
                gl.glClear(gl.GL_COLOR_BUFFER_BIT)

        # === 3. Modo Espera ou Estado Inválido ===
        else:
            # Apenas limpa com fundo escuro — o overlay está por cima
            gl.glClearColor(0.1, 0.1, 0.1, 1.0)
            gl.glClear(gl.GL_COLOR_BUFFER_BIT)

    def _renderizar_planeta(self):
        """Renderiza o planeta usando os polígonos e biomas."""
        print("🎨 [DEBUG] Iniciando _renderizar_planeta")

        # === 1. Atualizar câmera ===
        if self.width() > 0 and self.height() > 0:
            self.camera.set_aspect(self.width() / self.height())
            print(f"🔧 [DEBUG] Aspecto da câmera atualizado: {self.width()}x{self.height()} → {self.camera.aspect:.3f}")
        else:
            print("⚠️ [DEBUG] Tamanho do widget inválido para atualizar câmera")

        # === 2. Calcular MVP ===
        try:
            view = self.camera.view_matrix()
            proj = self.camera.projection_matrix()
            model = glm.mat4(1.0)
            mvp = proj * view * model
            print(f"📐 [DEBUG] Matriz MVP calculada. View: pos=({view[3][0]:.2f}, {view[3][1]:.2f}, {view[3][2]:.2f})")
        except Exception as e:
            print(f"❌ [DEBUG] Falha ao calcular MVP: {e}")
            return

        # === 3. Ativar shader e enviar uniform ===
        try:
            self.shader_program.usar()
            self.shader_program.set_uniform_mat4("MVP", glm.value_ptr(mvp))
            print("✅ [DEBUG] Shader ativado e MVP enviado")
        except Exception as e:
            print(f"❌ [DEBUG] Erro ao usar shader ou enviar MVP: {e}")
            return

        # === 4. Renderizar cada polígono ===
        if not self.vaos:
            print("❌ [DEBUG] self.vaos está vazio! Nenhum VAO para desenhar.")
            return

        print(f"📊 [DEBUG] Iterando {len(self.vaos)} polígonos...")
        for i, (coords, vao) in enumerate(self.vaos.items()):
            try:
                # Mostrar apenas os primeiros 5 polígonos no log
                if i < 5:
                    print(
                        f"   → Polígono {coords}: VAO={vao}, num_vertices={len(self.mundo.planeta.poligonos[coords]) // 3}")
                elif i == 5:
                    print("   → (mais polígonos...)")

                gl.glBindVertexArray(vao)
                num_vertices = len(self.mundo.planeta.poligonos[coords])
                gl.glDrawArrays(gl.GL_TRIANGLE_FAN, 0, num_vertices)

            except Exception as e:
                print(f"❌ [DEBUG] Erro ao renderizar polígono {coords}: {e}")
                continue  # Continua com o próximo

        # === 5. Limpeza final ===
        gl.glBindVertexArray(0)
        self.shader_program.limpar()
        print("🎨 [DEBUG] Renderização do planeta concluída")

    def _desenhar_triângulo_temporario(self):
        """Desenha um triângulo de teste no modo espera, usando o shader corretamente."""
        if not self.shader_program or not self.shader_program.program_id:
            return

        # Matriz MVP para visualização
        aspect = self.width() / self.height() if self.height() > 0 else 1.0
        mvp = glm.perspective(glm.radians(45), aspect, 0.1, 100.0) * \
              glm.lookAt(glm.vec3(0, 0, 3), glm.vec3(0, 0, 0), glm.vec3(0, 1, 0)) * \
              glm.mat4(1.0)

        # ✅ Usa a abstração da classe ShaderProgram
        self.shader_program.usar()
        self.shader_program.set_uniform_mat4("MVP", glm.value_ptr(mvp))

        # Desenha
        if self.VAO:
            gl.glBindVertexArray(self.VAO)
            gl.glDrawArrays(gl.GL_TRIANGLES, 0, 3)
            gl.glBindVertexArray(0)

        # ✅ Desativa o shader de forma segura
        self.shader_program.limpar()

    def _criar_geometria_planeta(self):
        """Gera VAOs/VBOs para todos os polígonos do planeta."""
        self.vaos.clear()
        self.vbos.clear()

        print("🔧 [DEBUG] Iniciando _criar_geometria_planeta")
        if not self.mundo or not self.mundo.planeta:
            print("❌ [DEBUG] Erro: self.mundo ou self.mundo.planeta é None")
            return

        planeta = self.mundo.planeta
        print(f"🔧 [DEBUG] Criando geometria para {len(planeta.poligonos)} polígonos")

        for coords, vertices_3d in planeta.poligonos.items():
            node_data = planeta.geografia.nodes[coords]
            cor_bioma = [c / 255.0 for c in node_data.get('cor_bioma', [128, 128, 128])]

            # Converter vértices para array NumPy
            vertex_data = []
            for v in vertices_3d:
                vertex_data.extend(v)  # v é [x, y, z]
                vertex_data.extend(cor_bioma)

            vertex_array = np.array(vertex_data, dtype=np.float32)

            # Gerar VAO e VBO
            vao = gl.glGenVertexArrays(1)
            vbo = gl.glGenBuffers(1)

            # ✅ Bind completo: VAO → VBO → atributos → desvincular
            gl.glBindVertexArray(vao)
            gl.glBindBuffer(gl.GL_ARRAY_BUFFER, vbo)
            gl.glBufferData(
                gl.GL_ARRAY_BUFFER,
                vertex_array.nbytes,
                vertex_array,
                gl.GL_STATIC_DRAW
            )

            stride = 6 * 4  # pos(3) + cor(3) = 6 floats

            # Layout: posição (0), cor (1)
            gl.glEnableVertexAttribArray(0)
            gl.glVertexAttribPointer(0, 3, gl.GL_FLOAT, False, stride, None)

            gl.glEnableVertexAttribArray(1)
            gl.glVertexAttribPointer(1, 3, gl.GL_FLOAT, False, stride, ctypes.c_void_p(3 * 4))

            # ✅ Desvincular VBO antes do VAO
            gl.glBindBuffer(gl.GL_ARRAY_BUFFER, 0)
            gl.glBindVertexArray(0)

            self.vaos[coords] = vao
            self.vbos[coords] = vbo

        print(f"✅ Geometria do planeta criada: {len(self.vaos)} polígonos")

    def carregar_mundo(self, mundo):
        self.mundo = mundo
        self.modulo_jogo = True
        self.vaos.clear()  # Limpar qualquer geometria antiga
        self.vbos.clear()
        self._geometria_necessaria = True  # ✅ Flag: geometria será criada em paintGL
        self.update()  # Força paintGL
        print(f"🌍 Mundo carregado. Geometria será criada em paintGL.")

    def ativar_modo_jogo(self):
        self.modulo_jogo = True
        self.update()

================================================================================
📄 client/rendering/shader.py
================================================================================
# client/rendering/shader.py
import OpenGL.GL as gl
from typing import Dict, Optional
import ctypes


class ShaderProgram:
    """
    Wrapper para programas de shader OpenGL.
    Compila vertex/fragment shaders e gerencia o programa linkado.
    """

    def __init__(self, vertex_source: str, fragment_source: str):
        self.program_id = None
        self.vertex_source = vertex_source
        self.fragment_source = fragment_source
        self._uniform_locations: Dict[str, int] = {}
        self._compile_and_link()

    def _compile_shader(self, source: str, shader_type) -> int:
        shader = gl.glCreateShader(shader_type)
        gl.glShaderSource(shader, source)
        gl.glCompileShader(shader)

        success = gl.glGetShaderiv(shader, gl.GL_COMPILE_STATUS)
        if not success:
            log = gl.glGetShaderInfoLog(shader).decode('utf-8')
            raise RuntimeError(f"Erro ao compilar shader ({shader_type}):\n{log}")

        return shader

    def _compile_and_link(self):
        """Compila e linka os shaders."""
        try:
            vertex_shader = self._compile_shader(self.vertex_source, gl.GL_VERTEX_SHADER)
            fragment_shader = self._compile_shader(self.fragment_source, gl.GL_FRAGMENT_SHADER)

            self.program_id = gl.glCreateProgram()
            gl.glAttachShader(self.program_id, vertex_shader)
            gl.glAttachShader(self.program_id, fragment_shader)
            gl.glLinkProgram(self.program_id)

            # Verifica link
            success = gl.glGetProgramiv(self.program_id, gl.GL_LINK_STATUS)
            if not success:
                log = gl.glGetProgramInfoLog(self.program_id).decode('utf-8')
                raise RuntimeError(f"Erro ao linkar shader program:\n{log}")

            # Limpa shaders intermediários
            gl.glDeleteShader(vertex_shader)
            gl.glDeleteShader(fragment_shader)

            print("✅ Shader program criado com sucesso.")

        except Exception as e:
            print(f"❌ Falha ao criar shader program: {e}")
            self.program_id = None
            if vertex_shader:
                gl.glDeleteShader(vertex_shader)
            if fragment_shader:
                gl.glDeleteShader(fragment_shader)

    def usar(self):
        """Ativa o programa de shader."""
        if self.program_id:
            gl.glUseProgram(self.program_id)
        else:
            raise RuntimeError("Tentando usar shader inválido.")

    def obter_localizacao_uniform(self, nome: str) -> int:
        """Cache da localização de uniforms."""
        if nome not in self._uniform_locations:
            loc = gl.glGetUniformLocation(self.program_id, nome)
            if loc == -1:
                print(f"⚠️ Uniform '{nome}' não encontrado no shader.")
            self._uniform_locations[nome] = loc
        return self._uniform_locations[nome]

    def set_uniform_mat4(self, nome: str, mat4):
        """Envia uma matriz 4x4 para o shader."""
        loc = self.obter_localizacao_uniform(nome)
        if loc != -1:
            gl.glUniformMatrix4fv(loc, 1, False, mat4)

    def set_uniform_int(self, nome: str, valor: int):
        """Envia um inteiro para o shader."""
        loc = self.obter_localizacao_uniform(nome)
        if loc != -1:
            gl.glUniform1i(loc, valor)

    def limpar(self):
        """Desativa o programa."""
        gl.glUseProgram(0)

    def deletar(self):
        """Libera o recurso de GPU."""
        if self.program_id:
            gl.glDeleteProgram(self.program_id)
            self.program_id = None

================================================================================
📄 client/dialogs/auth_dialog.py
================================================================================
# client/dialogs/auth_dialog.py
from PyQt6.QtWidgets import (
    QDialog, QTabWidget, QWidget, QFormLayout, QLineEdit,
    QDialogButtonBox, QMessageBox, QVBoxLayout
)
import requests


class DialogoAutenticacao(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Autenticação")
        self.setModal(True)
        self.resize(350, 200)

        layout_principal = QVBoxLayout(self)

        # Abas: Login e Registro
        self.abas = QTabWidget()  # Salvando como atributo para acesso futuro
        self.abas.addTab(self.criar_aba_login(), "Entrar")
        self.abas.addTab(self.criar_aba_registro(), "Registrar")
        layout_principal.addWidget(self.abas)

        # Botões comuns → AGORA salvo como atributo: self.buttons
        self.buttons = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel
        )
        self.buttons.accepted.connect(self.on_ok)
        self.buttons.rejected.connect(self.reject)
        layout_principal.addWidget(self.buttons)

    def criar_aba_login(self):
        widget = QWidget()
        layout = QFormLayout()

        self.username_login = QLineEdit()
        self.username_login.setPlaceholderText("seu_username ou email")
        self.username_login.setToolTip("Digite seu username ou email para login.")
        layout.addRow("Username:", self.username_login)  # ← Aqui também

        self.senha_login = QLineEdit()
        self.senha_login.setEchoMode(QLineEdit.EchoMode.Password)
        layout.addRow("Senha:", self.senha_login)

        widget.setLayout(layout)
        return widget

    def criar_aba_registro(self):
        widget = QWidget()
        layout = QFormLayout()

        self.username_registro = QLineEdit()
        self.username_registro.setPlaceholderText("ex: jogador_42")
        self.username_registro.setToolTip("Seu nome de usuário único. Usado para login.")
        layout.addRow("Username:", self.username_registro)  # ← Alterado de "Usuário"

        self.senha_registro = QLineEdit()
        self.senha_registro.setEchoMode(QLineEdit.EchoMode.Password)
        layout.addRow("Senha:", self.senha_registro)

        self.confirmar_senha = QLineEdit()
        self.confirmar_senha.setEchoMode(QLineEdit.EchoMode.Password)
        layout.addRow("Confirmar:", self.confirmar_senha)

        widget.setLayout(layout)
        return widget

    def on_ok(self):
        """Chamado quando o botão OK é pressionado. Executa login ou registro conforme aba ativa."""
        aba_atual = self.abas.currentIndex()  # ✅ Acesso direto ao QTabWidget
        if aba_atual == 0:
            self.tentar_login()
        else:
            self.tentar_registro()

    def tentar_login(self):
        username = self.username_login.text().strip()
        password = self.senha_login.text()

        if not username or not password:
            QMessageBox.warning(self, "Erro", "Usuário e senha são obrigatórios.")
            return

        try:
            response = requests.post(
                "http://localhost:5000/auth/login",
                json={"username": username, "password": password}
            )
            data = response.json()

            if response.status_code == 200 and data.get("success"):
                with open("session.txt", "w") as f:
                    f.write(username)
                QMessageBox.information(self, "Sucesso", f"Bem-vindo, {username}!")
                self.accept()  # Fecha o diálogo com sucesso
            else:
                QMessageBox.critical(self, "Erro", data.get("message", "Falha no login."))
        except requests.exceptions.ConnectionError:
            QMessageBox.critical(self, "Erro", "Não foi possível conectar ao servidor.")
        except Exception as e:
            QMessageBox.critical(self, "Erro", f"Erro inesperado: {e}")

    def tentar_registro(self):
        username = self.username_registro.text().strip()
        password = self.senha_registro.text()
        confirmar = self.confirmar_senha.text()

        if not username or not password or not confirmar:
            QMessageBox.warning(self, "Erro", "Todos os campos são obrigatórios.")
            return
        if password != confirmar:
            QMessageBox.warning(self, "Erro", "As senhas não coincidem.")
            return
        if len(password) < 6:
            QMessageBox.warning(self, "Erro", "A senha deve ter pelo menos 6 caracteres.")
            return

        try:
            response = requests.post(
                "http://localhost:5000/auth/registrar",
                json={"username": username, "password": password}
            )
            data = response.json()

            if response.status_code == 200 and data.get("success"):
                QMessageBox.information(self, "Sucesso", "Conta criada com sucesso! Faça login.")
                # Podemos mudar para aba de login automaticamente
                self.parent().findChild(QTabWidget).setCurrentIndex(0)
                self.username_login.setText(username)
            else:
                QMessageBox.critical(self, "Erro", data.get("message", "Falha no registro."))
        except requests.exceptions.ConnectionError:
            QMessageBox.critical(self, "Erro", "Não foi possível conectar ao servidor.")
        except Exception as e:
            QMessageBox.critical(self, "Erro", f"Erro inesperado: {e}")

================================================================================
📄 client/components/icon_manager.py
================================================================================
# client/components/icon_manager.py
"""Componentes para gerenciar ícones interativos na barra lateral esquerda."""

import os
from PyQt6.QtWidgets import QLabel, QVBoxLayout, QWidget, QHBoxLayout
from PyQt6.QtCore import Qt, pyqtSignal
from PyQt6.QtGui import QPixmap, QCursor


class IconeInterativo(QLabel):
    """
    Um QLabel que exibe uma imagem e emite um sinal quando clicado.
    """
    clicado = pyqtSignal(str)  # Sinal emitido ao ser clicado, passando um identificador

    def __init__(self, icone_path, identificador, tamanho=(64, 64), parent=None):
        """
        :param icone_path: Caminho para o arquivo PNG do ícone.
        :param identificador: String única para identificar este ícone ("login", "play", "sair").
        :param tamanho: Tupla (largura, altura) para redimensionar o ícone.
        :param parent: Widget pai.
        """
        super().__init__(parent)
        self.identificador = identificador
        self.tamanho = tamanho
        self.setAlignment(Qt.AlignmentFlag.AlignCenter)

        # Estilo para feedback visual (opcional)
        self.setStyleSheet("""
            IconeInterativo {
                border: 2px solid transparent; /* Borda invisível por padrão */
                border-radius: 5px; /* Bordas arredondadas */
            }
            IconeInterativo:hover {
                border: 2px solid #3498db; /* Borda azul ao passar o mouse */
                background-color: rgba(52, 152, 219, 30); /* Fundo azul claro transparente */
            }
        """)
        self.setCursor(QCursor(Qt.CursorShape.PointingHandCursor))  # Muda o cursor para mãozinha

        self.carregar_icone(icone_path)
        # Redimensionar o QLabel para o tamanho desejado
        self.setFixedSize(*self.tamanho)

    def carregar_icone(self, caminho):
        """
        Carrega e define a imagem do ícone.
        Inclui verificações detalhadas e logs para facilitar depuração.
        """
        print(f"[DEBUG] [IconeInterativo] Tentando carregar ícone '{self.identificador}' de: '{caminho}'")

        # --- Verificações detalhadas do caminho ---
        caminho_absoluto = os.path.abspath(caminho)
        existe = os.path.exists(caminho)
        eh_arquivo = os.path.isfile(caminho) if existe else False

        print(f"[DEBUG] [IconeInterativo] Caminho absoluto resolvido: '{caminho_absoluto}'")
        print(f"[DEBUG] [IconeInterativo] os.path.exists('{caminho}') = {existe}")
        print(f"[DEBUG] [IconeInterativo] os.path.isfile('{caminho}') = {eh_arquivo}")

        # --- Determinar se o carregamento pode prosseguir ---
        pixmap = None
        if not existe:
            print(
                f"⚠️ [IconeInterativo] O caminho '{caminho}' NÃO EXISTE. Diretório de execução pode estar incorreto. Usando placeholder.")
        elif not eh_arquivo:
            print(
                f"⚠️ [IconeInterativo] O caminho '{caminho}' EXISTE, mas NÃO É um arquivo (pode ser um diretório). Usando placeholder.")
        else:
            # Caminho existe e é um arquivo, tentar carregar com QPixmap
            print(f"[DEBUG] [IconeInterativo] Caminho válido, tentando QPixmap('{caminho}')...")
            try:
                pixmap = QPixmap(caminho)

                # Verificar se o carregamento foi bem-sucedido
                if pixmap.isNull():
                    print(f"⚠️ [IconeInterativo] QPixmap falhou ao carregar o arquivo '{caminho}'. "
                          f"O arquivo pode estar corrompido ou não ser uma imagem válida. Usando placeholder.")
                    pixmap = None  # Forçar uso do placeholder
                else:
                    print(
                        f"[DEBUG] [IconeInterativo] QPixmap carregou com sucesso. Tamanho original: {pixmap.width()}x{pixmap.height()}")

            except Exception as e:
                print(f"❌ [IconeInterativo] Erro inesperado ao carregar QPixmap de '{caminho}': {e}")
                import traceback
                traceback.print_exc()  # Imprime o stack trace completo
                pixmap = None  # Forçar uso do placeholder

        # --- Criar pixmap final (carregada ou placeholder) ---
        if pixmap is None:
            # Criar um pixmap de placeholder se a imagem não for carregada
            pixmap = QPixmap(self.tamanho[0], self.tamanho[1])
            pixmap.fill(Qt.GlobalColor.gray)  # Cor cinza para placeholder
            print(f"[DEBUG] [IconeInterativo] Placeholder cinza criado para '{self.identificador}'.")
        else:
            # Redimensionar a pixmap carregada para o tamanho desejado
            pixmap = pixmap.scaled(
                self.tamanho[0],
                self.tamanho[1],
                Qt.AspectRatioMode.KeepAspectRatio,
                Qt.TransformationMode.SmoothTransformation
            )
            print(
                f"[DEBUG] [IconeInterativo] Pixmap (carregada) redimensionada para {self.tamanho[0]}x{self.tamanho[1]}.")

        # --- Definir a pixmap (carregada ou placeholder) no QLabel ---
        self.setPixmap(pixmap)
        print(f"[DEBUG] [IconeInterativo] Pixmap definida para o ícone '{self.identificador}'.")

    def mousePressEvent(self, event):
        """Sobrescreve para emitir o sinal ao ser clicado."""
        if event.button() == Qt.MouseButton.LeftButton:
            print(f"🖱️ Ícone '{self.identificador}' clicado.")
            self.clicado.emit(self.identificador)  # Emite o sinal com o identificador
        super().mousePressEvent(event)  # Chama o método da classe base


class GerenciadorIconesEsquerda(QWidget):
    """
    Widget que contém e organiza os ícones interativos na barra esquerda.
    """
    icone_clicado = pyqtSignal(str)  # Re-emite o sinal dos ícones filhos

    def __init__(self, caminho_recursos="client/resources", parent=None):
        """
        :param caminho_recursos: Caminho para a pasta com os ícones PNG.
        :param parent: Widget pai.
        """
        super().__init__(parent)
        self.caminho_recursos = caminho_recursos
        self.icones = {}  # Dicionário para armazenar referências aos ícones {identificador: IconeInterativo}
        self.TAMANHO_ICONE = (48, 48)

        # Layout vertical para os ícones
        layout = QVBoxLayout(self)
        layout.setContentsMargins(10, 10, 10, 10)  # Margens internas
        layout.setSpacing(20)  # Espaço entre os ícones
        layout.setAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft)

        # --- Criar e adicionar ícones ---
        # --- Ícone de Login com nome do usuário ---
        icone_login_path = os.path.join(self.caminho_recursos, "log-in.png")
        self.icone_login = IconeInterativo(icone_login_path, "login", tamanho=self.TAMANHO_ICONE)
        self.icone_login.clicado.connect(self._ao_clicar_icone)

        # Layout horizontal para ícone + nome
        self.login_layout = QHBoxLayout()
        self.login_layout.setContentsMargins(0, 0, 0, 0)
        self.login_layout.setSpacing(8)
        self.login_layout.setAlignment(Qt.AlignmentFlag.AlignLeft)

        # Adicionar ícone
        self.login_layout.addWidget(self.icone_login)

        # Label para nome do usuário
        self.label_nome_usuario = QLabel()
        self.label_nome_usuario.setStyleSheet("""
            color: #ecf0f1;
            background: transparent;
            border: none;
            font-size: 14px;
            font-weight: bold;
        """)
        self.label_nome_usuario.hide()
        self.login_layout.addWidget(self.label_nome_usuario)

        # Container final
        self.login_container = QWidget()
        self.login_container.setLayout(self.login_layout)

        # Adicionar ao layout principal
        layout.addWidget(self.login_container)

        # Referência
        self.icones["login"] = self.icone_login

        # Criar um layout horizontal para o ícone + nome
        self.login_layout = QHBoxLayout()
        self.login_layout.setContentsMargins(0, 0, 0, 0)
        self.login_layout.setSpacing(8)  # Espaço entre ícone e texto
        self.login_layout.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)

        # Adicionar ícone
        self.login_layout.addWidget(self.icone_login)

        # Adicionar label de nome (inicialmente oculto)
        self.label_nome_usuario = QLabel()
        self.label_nome_usuario.setStyleSheet("""
            color: #ecf0f1;
            background: transparent;
            border: none;
            font-family: Arial, sans-serif;
            font-size: 14px;
            font-weight: bold;
        """)
        self.label_nome_usuario.hide()  # Esconde por padrão
        self.login_layout.addWidget(self.label_nome_usuario)

        # Container widget para o layout horizontal
        self.login_container = QWidget()
        self.login_container.setLayout(self.login_layout)

        # Adicionar o container ao layout principal
        layout.addWidget(self.login_container)

        # Armazenar referência
        self.icones["login"] = self.icone_login  # Mantém compatibilidade

        # Ícone de Play (Mais abaixo)
        icone_play_path = os.path.join(self.caminho_recursos, "play.png")
        self.icone_play = IconeInterativo(icone_play_path, "play", tamanho=self.TAMANHO_ICONE)
        self.icone_play.clicado.connect(self._ao_clicar_icone)
        layout.addWidget(self.icone_play)
        self.icones["play"] = self.icone_play

        # Espaço elástico para empurrar o ícone de sair para baixo
        layout.addStretch()

        # Ícone de Sair (Inferior Esquerdo)
        icone_sair_path = os.path.join(self.caminho_recursos, "arrow-left.png")
        self.icone_sair = IconeInterativo(icone_sair_path, "sair", tamanho=self.TAMANHO_ICONE)
        self.icone_sair.clicado.connect(self._ao_clicar_icone)
        layout.addWidget(self.icone_sair)
        self.icones["sair"] = self.icone_sair

    def atualizar_estado_login(self, esta_logado: bool, nome_usuario: str = None):
        """Atualiza o ícone de login e mostra/esconde o nome do usuário."""
        if esta_logado and nome_usuario:
            # Trocar ícone para o de usuário logado
            caminho = os.path.join(self.caminho_recursos, "smile.png")
            self.icone_login.carregar_icone(caminho)
            # Mostrar e atualizar nome do usuário
            self.label_nome_usuario.setText(nome_usuario)
            self.label_nome_usuario.show()  # ✅ Garante que o label apareça
        else:
            # Voltar para ícone de login
            caminho = os.path.join(self.caminho_recursos, "log-in.png")
            self.icone_login.carregar_icone(caminho)
            # Esconder nome do usuário
            self.label_nome_usuario.hide()

    def _ao_clicar_icone(self, identificador):
        """Slot interno para reemitir o sinal do ícone clicado."""
        print(f"📡 GerenciadorIconesEsquerda: Ícone '{identificador}' acionado.")
        self.icone_clicado.emit(identificador)  # Re-emite o sinal para o consumidor (JanelaPrincipal)

    # Métodos para atualizar ícones, se necessário (ex: login/logout)
    def atualizar_icone(self, identificador, novo_caminho):
        """Atualiza a imagem de um ícone existente."""
        if identificador in self.icones:
            self.icones[identificador].carregar_icone(novo_caminho)
        else:
            print(f"⚠️ GerenciadorIconesEsquerda: Ícone '{identificador}' não encontrado para atualizar.")

    def remover_status_sala(self):
        """Remove o widget de status da sala da barra lateral, se existir."""
        if hasattr(self, 'widget_status_sala') and self.widget_status_sala is not None:
            layout = self.container.layout()
            if layout is not None and self.widget_status_sala in layout:
                layout.removeWidget(self.widget_status_sala)
            self.widget_status_sala.deleteLater()
            self.widget_status_sala = None
            print("🗑️ Widget de status da sala removido da barra lateral.")

================================================================================
📄 shared/polygons.py
================================================================================
import math
import numpy

def dicionario_poligonos(fator):

    def icosaedro():
        
        def triangulo_original():
            
            def primeira_definicao_pontos():
                lista_pontos = []
                for x in range(fator ** 2):
                    if x % 2 == 0:
                        coord_x = x / 2 + 0.5
                        coord_y = math.sin(math.pi / 6)
                    else:
                        coord_x = x / 2 + 0.5
                        coord_y = math.sqrt(3) / 3
                    lista_pontos.append((round(coord_x, 15), round(coord_y, 15)))
                return lista_pontos
            
            def ponto_por_linha():
                lista_pontos = [0]
                ppf = fator * 2 - 1
                una = fator * 2 - 1
                while una != 1:
                    lista_pontos.append(ppf)
                    ppf += una - 2
                    una -= 2
                return lista_pontos

            def processar_coordenadas(coordenadas, indices):
                r = math.sqrt(3) / 3
                h = math.sqrt(0.75) * fator
                coords = []
                for i in range(len(indices)):
                    if i == len(indices) - 1:
                        segmento = [coordenadas[-1]]
                    else:
                        inicio, fim = indices[i], indices[i + 1]
                        segmento = coordenadas[inicio:fim]
                    for x in range(len(segmento)):
                        coefy = math.sin(math.pi / 6) * r
                        cx = (0.5 * i + 0.5 * x) + 0.5 - fator / 2
                        if x % 2 == 0:
                            cy = 0 + math.sqrt(0.75) * i + coefy - h / 2
                        else:
                            cy = r - coefy + math.sqrt(0.75) * i + coefy - h / 2
                        coords.append((cx, cy))
                return coords
            return processar_coordenadas(primeira_definicao_pontos(), ponto_por_linha())

        to = triangulo_original()

        def triangulos_equatoriais_em_pe():
            raio = fator / (2 * math.sin(math.pi / 5))
            apotema = fator / (2 * math.tan(math.pi / 5))
            theta = math.asin((raio - apotema) / fator)
            h = fator * math.sqrt(0.75)
            t1 = [(x, math.cos(theta) * y, math.sin(theta) * y) for x, y in to]
            t1 = [(x, y, z + apotema + math.sin(theta) * h / 2) for x, y, z in t1]
            return t1

        t1 = triangulos_equatoriais_em_pe()

        def rotacionar_em_torno_do_eixo_y(coordenadas, angulo_graus):
            angulo_radianos = math.radians(angulo_graus)
            cos_theta = math.cos(angulo_radianos)
            sin_theta = math.sin(angulo_radianos)
            coordenadas_rotacionadas = []
            for x, y, z in coordenadas:
                x_novo = cos_theta * x + sin_theta * z
                y_novo = y
                z_novo = -sin_theta * x + cos_theta * z
                coordenadas_rotacionadas.append((x_novo, y_novo, z_novo))
            return coordenadas_rotacionadas

        t2 = rotacionar_em_torno_do_eixo_y(t1, 72)
        t3 = rotacionar_em_torno_do_eixo_y(t1, 144)
        t4 = rotacionar_em_torno_do_eixo_y(t1, 216)
        t5 = rotacionar_em_torno_do_eixo_y(t1, 288)

        def triangulos_equatoriais_invertidos():
            raio = fator / (2 * math.sin(math.pi / 5))
            apotema = fator / (2 * math.tan(math.pi / 5))
            theta = math.asin((raio - apotema) / fator)
            h = fator * math.sqrt(0.75)
            t6 = [(x, -y) for x, y in to]
            t6 = [(x, math.cos(theta) * y, math.sin(theta) * -y) for x, y in t6]
            t6 = [(x, y, z + apotema + math.sin(theta) * h / 2) for x, y, z in t6]
            return t6

        tr = triangulos_equatoriais_invertidos()
        t6 = rotacionar_em_torno_do_eixo_y(tr, 36)
        t7 = rotacionar_em_torno_do_eixo_y(tr, 108)
        t8 = rotacionar_em_torno_do_eixo_y(tr, 180)
        t9 = rotacionar_em_torno_do_eixo_y(tr, 252)
        t10 = rotacionar_em_torno_do_eixo_y(tr, 324)

        def triangulos_polares_norte():
            alpha = math.acos(1 / (2 * math.tan(math.pi / 5) * math.sqrt(0.75)))
            apotema = fator / (2 * math.tan(math.pi / 5))
            h = fator * math.sqrt(0.75)
            deslocamento = apotema - math.cos(alpha) * h / 2
            raio = fator / (2 * math.sin(math.pi / 5))
            theta = math.asin((raio - apotema) / fator)
            deslocamento_vertical = (math.cos(theta) * h / 2) + (math.sin(alpha) * h / 2)
            tr = [(x, 0, -y) for x, y in to]
            tr = [(x, math.sin(alpha) * -z + deslocamento_vertical,
                z * math.cos(alpha) + deslocamento) for x, y, z in tr]
            return tr

        tr = triangulos_polares_norte()

        t11 = rotacionar_em_torno_do_eixo_y(tr, 36)
        t12 = rotacionar_em_torno_do_eixo_y(tr, 108)
        t13 = rotacionar_em_torno_do_eixo_y(tr, 180)
        t14 = rotacionar_em_torno_do_eixo_y(tr, 252)
        t15 = rotacionar_em_torno_do_eixo_y(tr, 324)

        def triangulos_polares_sul():
            alpha = math.acos(1 / (2 * math.tan(math.pi / 5) * math.sqrt(0.75)))
            apotema = fator / (2 * math.tan(math.pi / 5))
            h = fator * math.sqrt(0.75)
            deslocamento = apotema - math.cos(alpha) * h / 2
            raio = fator / (2 * math.sin(math.pi / 5))
            theta = math.asin((raio - apotema) / fator)
            deslocamento_vertical = (math.cos(theta) * h / 2) + (math.sin(alpha) * h / 2)
            t16 = [(x, 0, -y) for x, y in to]
            t16 = [(x, math.sin(alpha) * z - deslocamento_vertical,
                    z * math.cos(alpha) + deslocamento) for x, y, z in t16]
            return t16

        t16 = triangulos_polares_sul()
        t17 = rotacionar_em_torno_do_eixo_y(t16, 72)
        t18 = rotacionar_em_torno_do_eixo_y(t16, 144)
        t19 = rotacionar_em_torno_do_eixo_y(t16, 216)
        t20 = rotacionar_em_torno_do_eixo_y(t16, 288)
        return [t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20]

    def esfera(pontos, raio):

        def projetar_ponto_na_esfera(ponto, raio):
            x, y, z = ponto
            magnitude = math.sqrt(x**2 + y**2 + z**2)
            return (
                raio * x / magnitude,
                raio * y / magnitude,
                raio * z / magnitude
            )

        return [[projetar_ponto_na_esfera(ponto, raio) for ponto in lista] for lista in pontos]

    esfera = esfera(icosaedro(), fator)

    def poligonos():
        poligonos = []
        
        def ponto_por_linha():
            lista_pontos = [0]
            ppf = fator * 2 - 1
            una = fator * 2 - 1
            while una != 1:
                lista_pontos.append(ppf)
                ppf += una - 2
                una -= 2
            return lista_pontos

        p = ponto_por_linha()

        def hexagonos_centrais():
            hexagonos = []
            for t in esfera:
                i = 0
                for x in range(fator - 2, 0, -1):
                    for y in range(x):
                        hexagonos.append(numpy.array([
                            t[p[y] + i * 2 + 1],
                            t[p[y] + i * 2 + 2],
                            t[p[y] + i * 2 + 3],
                            t[p[y + 1] + i * 2 + 2],
                            t[p[y + 1] + i * 2 + 1],
                            t[p[y + 1] + i * 2]
                        ]))
                    i += 1
            return hexagonos

        poligonos.append(hexagonos_centrais())

        def hexagonos_tropicais_sul():
            hexagonos = []
            for x in range(5):
                for y in range(fator - 1):
                    hexagonos.append(numpy.array([
                        esfera[x][y * 2],
                        esfera[x][y * 2 + 1],
                        esfera[x][y * 2 + 2],
                        esfera[x + 15][y * 2 + 2],
                        esfera[x + 15][y * 2 + 1],
                        esfera[x + 15][y * 2]
                    ]))
            return hexagonos

        poligonos.append(hexagonos_tropicais_sul())

        def hexagonos_tropicais_norte():
            hexagonos = []
            for x in range(5, 10, 1):
                for y in range(fator - 1):
                    hexagonos.append(numpy.array([
                        esfera[x][y * 2],
                        esfera[x][y * 2 + 1],
                        esfera[x][y * 2 + 2],
                        esfera[x + 5][y * 2 + 2],
                        esfera[x + 5][y * 2 + 1],
                        esfera[x + 5][y * 2]
                    ]))
            return hexagonos

        poligonos.append(hexagonos_tropicais_norte())

        def hexagonos_equatoriais_ascendentes():
            hexagonos = []
            for x in range(5):
                for y in range(fator - 1):
                    if x == 0:
                        hexagonos.append(numpy.array([
                            esfera[x][p[y]],
                            esfera[x][p[y] + 1],
                            esfera[x][p[y + 1]],
                            esfera[x + 9][p[fator - y - 1] - 1],
                            esfera[x + 9][p[fator - y - 1] - 2],
                            esfera[x + 9][p[fator - y - 1] + 2 * y]
                        ]))
                    else:
                        hexagonos.append(numpy.array([
                            esfera[x][p[y]],
                            esfera[x][p[y] + 1],
                            esfera[x][p[y + 1]],
                            esfera[x + 4][p[fator - y - 1] - 1],
                            esfera[x + 4][p[fator - y - 1] - 2],
                            esfera[x + 4][p[fator - y - 1] + 2 * y]
                        ]))
            return hexagonos

        poligonos.append(hexagonos_equatoriais_ascendentes())

        def hexagonos_equatoriais_descendentes():
            hexagonos = []
            for x in range(5):
                for y in range(fator - 1):
                    hexagonos.append(numpy.array([
                        esfera[x][p[fator - 1 - y] + 2 * y],
                        esfera[x][p[fator - 1 - y] - 2],
                        esfera[x][p[fator - 1 - y] - 1],
                        esfera[x + 5][p[y + 1]],
                        esfera[x + 5][p[y] + 1],
                        esfera[x + 5][p[y]]
                    ]))
            return hexagonos

        poligonos.append(hexagonos_equatoriais_descendentes())

        def hexagonos_polares_norte():
            hexagonos = []
            for x in range(10, 15, 1):
                for y in range(fator - 1):
                    if x == 10:
                        hexagonos.append(numpy.array([
                            esfera[x][p[y]],
                            esfera[x][p[y] + 1],
                            esfera[x][p[y + 1]],
                            esfera[x + 4][p[y + 1] + (fator - y - 2) * 2],
                            esfera[x + 4][p[y + 1] - 2],
                            esfera[x + 4][p[y + 1] - 1]
                        ]))
                    else:
                        hexagonos.append(numpy.array([
                            esfera[x][p[y]],
                            esfera[x][p[y] + 1],
                            esfera[x][p[y + 1]],
                            esfera[x - 1][p[y + 1] + (fator - y - 2) * 2],
                            esfera[x - 1][p[y + 1] - 2],
                            esfera[x - 1][p[y + 1] - 1]
                        ]))
            return hexagonos

        poligonos.append(hexagonos_polares_norte())

        def hexagonos_polares_sul():
            hexagonos = []
            for x in range(15, 20):
                for y in range(fator - 1):
                    if x == 15:
                        hexagonos.append(numpy.array([
                            esfera[x][p[y]],
                            esfera[x][p[y] + 1],
                            esfera[x][p[y + 1]],
                            esfera[x + 4][p[y + 1] + (fator - y - 2) * 2],
                            esfera[x + 4][p[y + 1] - 2],
                            esfera[x + 4][p[y + 1] - 1]
                        ]))
                    else:
                        hexagonos.append(numpy.array([
                            esfera[x][p[y]],
                            esfera[x][p[y] + 1],
                            esfera[x][p[y + 1]],
                            esfera[x - 1][p[y + 1] + (fator - y - 2) * 2],
                            esfera[x - 1][p[y + 1] - 2],
                            esfera[x - 1][p[y + 1] - 1]
                        ]))
            return hexagonos

        poligonos.append(hexagonos_polares_sul())

        def pentagonos():

            pentagonos = []

            def pentagonos_tropicais_sul():
                pentagonos = []
                for x in range(5):
                    if x == 0:
                        pentagonos.append(numpy.array([
                            esfera[0][0],
                            esfera[9][p[fator - 1]],
                            esfera[4][p[1] - 1],
                            esfera[19][p[1] - 1],
                            esfera[15][0]
                        ]))
                    else:
                        pentagonos.append(numpy.array([
                            esfera[x][0],
                            esfera[x + 4][p[fator - 1]],
                            esfera[x - 1][p[1] - 1],
                            esfera[x + 14][p[1] - 1],
                            esfera[x + 15][0]
                        ]))
                return pentagonos

            pentagonos.extend(pentagonos_tropicais_sul())

            def pentagonos_tropicais_norte():
                pentagonos = []
                for x in range(5):
                    if x == 0:
                        pentagonos.append(numpy.array([
                            esfera[0][p[fator - 1]],
                            esfera[5][0],
                            esfera[10][0],
                            esfera[14][p[1] - 1],
                            esfera[9][p[1] - 1]
                        ]))
                    else:
                        pentagonos.append(numpy.array([
                            esfera[x][p[fator - 1]],
                            esfera[x + 5][0],
                            esfera[x + 10][0],
                            esfera[x + 9][p[1] - 1],
                            esfera[x + 4][p[1] - 1]
                        ]))
                return pentagonos

            pentagonos.extend(pentagonos_tropicais_norte())

            def pentagono_polo_norte():
                return numpy.array([
                    esfera[10][p[fator - 1]],
                    esfera[11][p[fator - 1]],
                    esfera[12][p[fator - 1]],
                    esfera[13][p[fator - 1]],
                    esfera[14][p[fator - 1]]
                ])

            pentagonos.append(pentagono_polo_norte())

            def pentagono_polo_sul():
                return numpy.array([
                    esfera[15][p[fator - 1]],
                    esfera[16][p[fator - 1]],
                    esfera[17][p[fator - 1]],
                    esfera[18][p[fator - 1]],
                    esfera[19][p[fator - 1]]
                ])

            pentagonos.append(pentagono_polo_sul())
            
            return pentagonos

        poligonos.append(pentagonos())

        return poligonos

    poligonos = poligonos()

    def dic_pol():
        coord_vert = {}
        h = 0
        for x in range(5):        
            for i, z in enumerate(range(fator - 2, 0, -1)):
                n = fator * 2 - 1
                for a in range(z):
                    coord_vert[(n - a, fator * x + i + 1)] = poligonos[0][h]
                    h += 1

        for x in range(5):
            for i, z in enumerate(range(fator - 2, 0, -1)):
                n = fator + 1
                for a in range(z):
                    coord_vert[(n + a, fator * x + 2 + i + a)] = poligonos[0][h]
                    h += 1

        for x in range(5):
            for i, z in enumerate(range(fator - 2, 0, -1)):
                n = fator - 1
                for a in range(z):
                    coord_vert[(n - a, fator * x + 1 - x * (a + 1) + i)] = poligonos[0][h]
                    h += 1

        for x in range(5):
            b = fator * x + 1 - x
            for i, z in enumerate(range(fator - 2, 0, -1)):
                n = fator * 2 + 1
                for a in range(z):
                    coord_vert[(n + a, b + i - a * x)] = poligonos[0][h]
                    h += 1
        h = 0
        for x in range(5):
            for z in range(fator - 1):
                coord_vert[(fator * 2, fator * x + z + 1)] = poligonos[1][h]
                h += 1
        h = 0
        for x in range(5):
            for z in range(fator - 1):
                coord_vert[(fator, fator * x + z + 1)] = poligonos[2][h]
                h += 1
        h = 0
        for x in range(5):
            for z in range(fator - 1):
                coord_vert[(fator * 2 - z - 1, fator * x)] = poligonos[3][h]
                h += 1
        h = 0
        for x in range(5):
            for z in range(fator - 1):
                coord_vert[(fator + z + 1, fator * x + z + 1)] = poligonos[4][h]
                h += 1
        h = 0
        for x in range(5):
            for z in range(fator - 1):
                coord_vert[(fator - z - 1, (fator - z - 1) * x)] = poligonos[5][h]
                h += 1
        h = 0
        for x in range(5):
            for i, z in enumerate(range(fator - 1, 0, -1)):
                coord_vert[(fator * 2 + i + 1, z * x)] = poligonos[6][h]
                h += 1
        h = 0
        for x in range(5):
            coord_vert[(fator * 2, fator * x)] = poligonos[7][h]
            h += 1
        for x in range(5):
            coord_vert[(fator, fator * x)] = poligonos[7][h]
            h += 1
        coord_vert[(0, 0)] = poligonos[7][h]
        h += 1
        coord_vert[(fator * 3, 0)] = poligonos[7][h]

        return coord_vert
    
    return dic_pol()

if __name__ == "__main__":
    import numpy as np
    import json
    import os

    # === CONFIGURE AQUI OS PARÂMETROS ===
    fator_teste = 4
    # ====================================

    print(f"\n🔧 Gerando dicionário de polígonos com fator={fator_teste}...")
    poligonos = dicionario_poligonos(fator_teste)

    print(f"✅ Gerado: {len(poligonos)} polígonos.")
    print("\n🔍 Exibindo as primeiras 5 coordenadas e seus vértices:")
    for i, (coords, vertices) in enumerate(poligonos.items()):
        if i >= 5:
            break
        print(f"   {coords}: {vertices.shape}")
        print(f"     {np.round(vertices, 3).tolist()}")

    # === SALVAR EM ARQUIVO ===

    # 1. Salvar como .npy (seguro, eficiente)
    npy_file = f"poligonos_fator{fator_teste}.npy"
    np.save(npy_file, poligonos)
    print(f"\n💾 Dados salvos em: {os.path.abspath(npy_file)}")

    # 2. Preparar dicionário para JSON (chaves como string, valores convertidos)
    def convert_for_json(obj):
        if isinstance(obj, np.ndarray):
            return np.round(obj, 6).tolist()
        if isinstance(obj, tuple):
            return f"{obj[0]},{obj[1]}"  # (x,y) → "x,y"
        if isinstance(obj, (np.integer, int)):
            return int(obj)
        if isinstance(obj, (np.floating, float)):
            return round(float(obj), 6)
        raise TypeError(f"Tipo {type(obj)} não serializável")

    print("📝 Convertendo dados para JSON...")
    try:
        # Conversão explícita
        poligonos_json = {}
        for k, v in poligonos.items():
            key = convert_for_json(k)
            value = convert_for_json(v)
            poligonos_json[key] = value

        # Testar serialização (sem salvar)
        json_string = json.dumps(poligonos_json, ensure_ascii=False, indent=2)
        print(f"✅ Conversão para JSON bem-sucedida! Tamanho: {len(json_string)} caracteres")

        # Salvar
        json_file = f"poligonos_fator{fator_teste}.json"
        with open(json_file, 'w', encoding='utf-8') as f:
            f.write(json_string)
        print(f"📄 Dados salvos em: {os.path.abspath(json_file)}")

    except Exception as e:
        print(f"❌ Falha ao gerar JSON: {e}")
        print("💡 Dica: Verifique se todos os dados são serializáveis.")
        raise

    print("\n🎉 Geração e salvamento concluídos!")
    print("💡 Dica: Abra o arquivo .json em qualquer editor de texto para inspeção.")

================================================================================
📄 shared/planet.py
================================================================================
import random
from shared.polygons import dicionario_poligonos
from shared.geography import definir_geografia

class Planeta:
    def __init__(self, fator, bioma):
        self.fator = fator
        self.bioma_inicial = bioma
        self.poligonos = dicionario_poligonos(fator)
        print(f"🌍 [DEBUG] Planeta criado: {len(self.poligonos)} polígonos")
        print(f"   Exemplo: chave={list(self.poligonos.keys())[0]}, shape={list(self.poligonos.values())[0].shape}")
        self.geografia, self.capitais_players = definir_geografia(self.poligonos, fator, bioma) # capitais = [(int, int), ...]
        random.shuffle(self.capitais_players)
        self.numero_de_jogadores = len(self.capitais_players)
        biomas_invalidos = {"Ice", "Sea", "Ocean", "Coast", bioma}
        capitais_player_set = set(self.capitais_players)
        nodos_validos = [
            n for n in self.geografia.nodes()
            if self.geografia.nodes[n]["bioma"] not in biomas_invalidos and n not in capitais_player_set
        ]
        npn = 27 - len(self.capitais_players)  # Lembrar de evitar npn (países neutros) negativo
        self.capitais_neutros = random.sample(nodos_validos, npn)
        random.shuffle(self.capitais_neutros)
        self.civilizacoes = []

================================================================================
📄 shared/geography.py
================================================================================
import networkx
import random
import math
from statistics import mean
from random import choice

# CUSTOS BASE
CUSTOS_BASE = {
    'Ice': 20.0,
    'Mountains': 12.0,
    'Hills': 6.0,
    'Forest': 4.0,
    'Meadow': 3.0,
    'Savanna': 4.0,
    'Desert': 5.0,
    'Coast': 0.8,
    'Sea': 0.6,
    'Ocean': 0.4
}

PENALIDADE_TRANSICAO = 15.0

def letra_grega(placa):
    letras_gregas_dict = {
        "Alpha": "Α", "Beta": "Β", "Gamma": "Γ", "Delta": "Δ",
        "Epsilon": "Ε", "Zeta": "Ζ", "Eta": "Η", "Theta": "Θ",
        "Iota": "Ι", "Kappa": "Κ", "Lambda": "Λ", "Mu": "Μ",
        "Nu": "Ν", "Xi": "Ξ", "Omicron": "Ο", "Pi": "Π",
        "Rho": "Ρ", "Sigma": "Σ", "Tau": "Τ", "Upsilon": "Υ",
        "Phi": "Φ", "Chi": "Χ", "Psi": "Ψ", "Omega": "Ω"
    }
    return letras_gregas_dict.get(placa)

def definir_geografia(poligonos, fator, bioma):

    geografia = networkx.DiGraph()

    for coordenadas in poligonos:
        geografia.add_node(coordenadas)

    def tipo_de_poligono(c):
        if c == (0, 0):
            geografia.nodes[c]['tipo'] = 'pn'
            return "pn"
        elif 0 < c[0] < fator and c[1] % c[0] == 0:
            geografia.nodes[c]['tipo'] = 'ipn'
            return "ipn"
        elif 0 < c[0] < fator and c[1] % c[0] != 0:
            geografia.nodes[c]['tipo'] = 'cpn'
            return "cpn"
        elif c[0] == fator and c[1] % c[0] == 0:
            geografia.nodes[c]['tipo'] = 'ntn'
            return "ntn"
        elif c[0] == fator and c[1] % c[0] != 0:
            geografia.nodes[c]['tipo'] = 'itn'
            return "itn"
        elif fator < c[0] < fator * 2:
            geografia.nodes[c]['tipo'] = 'e'
            return "e"
        elif c[0] == fator * 2 and c[1] % fator != 0:
            geografia.nodes[c]['tipo'] = 'its'
            return "its"
        elif c[0] == fator * 2 and c[1] % fator == 0:
            geografia.nodes[c]['tipo'] = 'nts'
            return "nts"
        elif fator * 2 < c[0] < fator * 3 and c[1] % (fator * 3 - c[0]) != 0:
            geografia.nodes[c]['tipo'] = 'cps'
            return "cps"
        elif fator * 2 < c[0] < fator * 3 and c[1] % (fator * 3 - c[0]) == 0:
            geografia.nodes[c]['tipo'] = 'ips'
            return "ips"
        elif c[0] == fator * 3:
            geografia.nodes[c]['tipo'] = 'ps'
            return "ps"

    for n in list(geografia.nodes):
        no = tipo_de_poligono(n)
        if no == "pn":
            for y in range(5):
                geografia.add_edge(n, (1, y), direcao=f'S{y+1}')
            continue
        if no == "ps":
            for y in range(5):
                geografia.add_edge(n, (fator * 3 - 1, y), direcao=f'N{y+1}')
            continue
        x = n[1] // n[0]
        y = n[1] // (fator * 3 - n[0])
        if no == "ipn":
            if n[1] != n[0] * 5 - 1:
                geografia.add_edge(n, (n[0] + 1, n[1] + x), direcao='S')
                geografia.add_edge(n, (n[0] + 1, n[1] + x + 1), direcao='SE')
                geografia.add_edge(n, (n[0], n[1] + 1), direcao='E')
                geografia.add_edge(n, (n[0] - 1, n[1] - x), direcao='N')
                geografia.add_edge(n, (n[0], n[1] - 1), direcao='W') if n[1] != 0 else geografia.add_edge(n, (n[0], n[0] * 5 - 1), direcao='W')
                geografia.add_edge(n, (n[0] + 1, n[1] + x - 1), direcao='SW') if n[1] != 0 else \
                                        geografia.add_edge(n, (n[0] + 1, (n[0] + 1) * 5 - 1), direcao='SW')
            else:
                geografia.add_edge(n, (n[0] + 1, n[1] + x), direcao='S')
                geografia.add_edge(n, (n[0] + 1, n[1] + x + 1), direcao='SE')
                geografia.add_edge(n, (n[0], 0), direcao='E')
                geografia.add_edge(n, (n[0] - 1, n[1] - x), direcao='N')
                geografia.add_edge(n, (n[0], n[1] - 1), direcao='W')
                geografia.add_edge(n, (n[0] + 1, n[1] + x - 1), direcao='SW')
        elif no == "cpn":
            if n[1] != n[0] * 5 - 1:
                geografia.add_edge(n, (n[0] + 1, n[1] + x + 1), direcao='SE')
                geografia.add_edge(n, (n[0], n[1] + 1), direcao='E')
                geografia.add_edge(n, (n[0] - 1, n[1] - x), direcao='NE')
                geografia.add_edge(n, (n[0] - 1, n[1] - x - 1), direcao='NW')
                geografia.add_edge(n, (n[0], n[1] - 1), direcao='W')
                geografia.add_edge(n, (n[0] + 1, n[1] + x), direcao='SW')
            else:
                geografia.add_edge(n, (n[0] + 1, n[1] + x + 1), direcao='SE')
                geografia.add_edge(n, (n[0], 0), direcao='E')
                geografia.add_edge(n, (n[0] - 1, 0), direcao='NE')
                geografia.add_edge(n, (n[0] - 1, n[1] - x - 1), direcao='NW')
                geografia.add_edge(n, (n[0], n[1] - 1), direcao='W')
                geografia.add_edge(n, (n[0] + 1, n[1] + x), direcao='SW')
        elif no == "ntn":
            geografia.add_edge(n, (n[0] + 1, n[1]), direcao='SW')
            geografia.add_edge(n, (n[0] + 1, n[1] + 1), direcao='SE')
            geografia.add_edge(n, (n[0], n[1] + 1), direcao='NE')
            geografia.add_edge(n, (n[0] - 1, n[1] - x), direcao='N')
            geografia.add_edge(n, (n[0], n[1] - 1), direcao='NW') if n[1] != 0 else geografia.add_edge(n, (n[0], n[0] * 5 - 1), direcao='NW')
        elif no == "itn":
            if n[1] != fator * 5 - 1:
                geografia.add_edge(n, (n[0] + 1, n[1]), direcao='SW')
                geografia.add_edge(n, (n[0] + 1, n[1] + 1), direcao='NE')
                geografia.add_edge(n, (n[0], n[1] + 1), direcao='E')
                geografia.add_edge(n, (n[0] - 1, n[1] - x), direcao='NE')
                geografia.add_edge(n, (n[0] - 1, n[1] - x - 1), direcao='NW')
                geografia.add_edge(n, (n[0], n[1] - 1), direcao='W')
            else:
                geografia.add_edge(n, (n[0] + 1, n[1]), direcao='SW')
                geografia.add_edge(n, (n[0] + 1, 0), direcao='NE')
                geografia.add_edge(n, (n[0], 0), direcao='E')
                geografia.add_edge(n, (n[0] - 1, 0), direcao='NE')
                geografia.add_edge(n, (n[0] - 1, n[1] - x - 1), direcao='NW')
                geografia.add_edge(n, (n[0], n[1] - 1), direcao='W')
        elif no == "e":
            if n[1] != fator * 5 - 1:
                geografia.add_edge(n, (n[0] + 1, n[1]), direcao='SW')
                geografia.add_edge(n, (n[0] + 1, n[1] + 1), direcao='SE')
                geografia.add_edge(n, (n[0], n[1] + 1), direcao='E')
                geografia.add_edge(n, (n[0] - 1, n[1]), direcao='NE')
                geografia.add_edge(n, (n[0] - 1, n[1] - 1), direcao='NW') if n[1] != 0 else geografia.add_edge(n, (n[0] - 1, fator * 5 - 1), direcao='NW')
                geografia.add_edge(n, (n[0], n[1] - 1), direcao='W') if n[1] != 0 else geografia.add_edge(n, (n[0], fator * 5 - 1), direcao='W')
            else:
                geografia.add_edge(n, (n[0] + 1, n[1]), direcao='SW')
                geografia.add_edge(n, (n[0] + 1, 0), direcao='SE')
                geografia.add_edge(n, (n[0], 0), direcao='E')
                geografia.add_edge(n, (n[0] - 1, n[1]), direcao='NE')
                geografia.add_edge(n, (n[0] - 1, n[1] - 1), direcao='NW')
                geografia.add_edge(n, (n[0], n[1] - 1), direcao='W')
        elif no == "its":
            if n[1] != fator * 5 - 1:
                geografia.add_edge(n, (n[0] + 1, n[1] - y), direcao='SE')
                geografia.add_edge(n, (n[0], n[1] + 1), direcao='E')
                geografia.add_edge(n, (n[0] - 1, n[1]), direcao='NE')
                geografia.add_edge(n, (n[0] - 1, n[1] - 1), direcao='NW')
                geografia.add_edge(n, (n[0], n[1] - 1), direcao='W')
                geografia.add_edge(n, (n[0] + 1, n[1] - y - 1), direcao='SW')
            else:
                geografia.add_edge(n, (n[0] + 1, 0), direcao='SE')
                geografia.add_edge(n, (n[0], 0), direcao='E')
                geografia.add_edge(n, (n[0] - 1, n[1]), direcao='NE')
                geografia.add_edge(n, (n[0] - 1, n[1] - 1), direcao='NW')
                geografia.add_edge(n, (n[0], n[1] - 1), direcao='W')
                geografia.add_edge(n, (n[0] + 1, n[1] - y - 1), direcao='SW')
        elif no == "nts":
            geografia.add_edge(n, (n[0] + 1, n[1] - y), direcao='S')
            geografia.add_edge(n, (n[0], n[1] + 1), direcao='SE')
            geografia.add_edge(n, (n[0] - 1, n[1]), direcao='NE')
            geografia.add_edge(n, (n[0] - 1, n[1] - 1), direcao='NW') if n[1] != 0 else geografia.add_edge(n, (n[0] - 1, fator * 5 - 1), direcao='NW')
            geografia.add_edge(n, (n[0], n[1] - 1), direcao='SW') if n[1] != 0 else geografia.add_edge(n, (n[0], fator * 5 - 1), direcao='SW')
        elif no == "cps":
            if n[1] != (fator * 3 - n[0]) * 5 - 1:
                geografia.add_edge(n, (n[0] + 1, n[1] - y), direcao='SE')
                geografia.add_edge(n, (n[0], n[1] + 1), direcao='E')
                geografia.add_edge(n, (n[0] - 1, n[1] + y + 1), direcao='NE')
                geografia.add_edge(n, (n[0] - 1, n[1] + y), direcao='NW')
                geografia.add_edge(n, (n[0], n[1] - 1), direcao='W')
                geografia.add_edge(n, (n[0] + 1, n[1] - y - 1), direcao='SW')
            else:
                geografia.add_edge(n, (n[0] + 1, 0), direcao='SE')
                geografia.add_edge(n, (n[0], 0), direcao='E')
                geografia.add_edge(n, (n[0] - 1, n[1] + y + 1), direcao='NE')
                geografia.add_edge(n, (n[0] - 1, n[1] + y), direcao='NW')
                geografia.add_edge(n, (n[0], n[1] - 1), direcao='W')
                geografia.add_edge(n, (n[0] + 1, n[1] - y - 1), direcao='SW')
        elif no == "ips":
            if n[1] != (fator * 3 - n[0]) * 5 - 1:
                geografia.add_edge(n, (n[0] + 1, n[1] - y), direcao='S')
                geografia.add_edge(n, (n[0], n[1] + 1), direcao='SE')
                geografia.add_edge(n, (n[0] - 1, n[1] + y + 1), direcao='NE')
                geografia.add_edge(n, (n[0] - 1, n[1] + y), direcao='N')
                geografia.add_edge(n, (n[0] - 1, n[1] + y - 1), direcao='NW') if n[1] != 0 else \
                                        geografia.add_edge(n, (n[0] - 1, (fator * 3 - n[0] + 1) * 5 - 1), direcao='NW')
                geografia.add_edge(n, (n[0], n[1] - 1), direcao='SW') if n[1] != 0 else \
                                        geografia.add_edge(n, (n[0], (fator * 3 - n[0]) * 5 - 1), direcao='SW')
            else:
                geografia.add_edge(n, (n[0] + 1, n[1] - y), direcao='S')
                geografia.add_edge(n, (n[0], 0), direcao='SE')
                geografia.add_edge(n, (n[0] - 1, n[1] + y + 1), direcao='NE')
                geografia.add_edge(n, (n[0] - 1, n[1] + y), direcao='N')
                geografia.add_edge(n, (n[0] - 1, n[1] + y - 1), direcao='NW')
                geografia.add_edge(n, (n[0], n[1] - 1), direcao='SW')

    areas = list(poligonos.keys())
    areas_sem_definicao = {}
    areas_definidas = {}
    referencias_relevo = random.sample(areas, fator * 20)

    for area in areas:
        areas_sem_definicao[area] = []
        areas_definidas[area] = []

    for n in range(fator * 3 // 2):
        if not areas_sem_definicao:
            break
        for node in referencias_relevo:
            altitude = random.randint(0, 12)
            areas_definidas[node].append(altitude)
            if node in areas_sem_definicao:
                del areas_sem_definicao[node]
            distancias = networkx.single_source_shortest_path_length(geografia, node)
            nos_a_n_arestas = [node for node, distance in distancias.items() if distance == n + 1]
            for neighbor in nos_a_n_arestas:
                if neighbor in areas_sem_definicao and neighbor not in referencias_relevo:
                    areas_sem_definicao[neighbor].append(altitude)
        for chave in list(areas_sem_definicao.keys()):
            if areas_sem_definicao[chave]:
                areas_definidas[chave].append(round(mean(areas_sem_definicao[chave]), 3))
                del areas_sem_definicao[chave]

    chaves = list(areas_definidas.keys())
    random.shuffle(chaves)
    chaves_ordenadas = sorted(chaves, key=lambda chave: areas_definidas[chave])
    percentual_terra = random.randint(35, 45)
    limite_abissal = (100 - percentual_terra) // 2
    limite_barreira = limite_abissal + (100 - percentual_terra) // 3
    nivel_do_mar = 100 - percentual_terra
    limite_planicie = nivel_do_mar + (100 - nivel_do_mar) * 4 // 6
    limite_planalto = limite_planicie + (100 - limite_planicie) // 2

    for i, chave in enumerate(chaves_ordenadas):
        if i <= len(chaves_ordenadas) * limite_abissal // 100:
            geografia.nodes[chave]['altitude'] = 'abissal'
        elif i <= len(chaves_ordenadas) * limite_barreira // 100:
            geografia.nodes[chave]['altitude'] = 'barreira'
        elif i <= len(chaves_ordenadas) * nivel_do_mar // 100:
            geografia.nodes[chave]['altitude'] = 'plataforma'
        elif i <= len(chaves_ordenadas) * limite_planicie // 100:
            geografia.nodes[chave]['altitude'] = 'planicie'
        elif i <= len(chaves_ordenadas) * limite_planalto // 100:
            geografia.nodes[chave]['altitude'] = 'planalto'
        else:
            geografia.nodes[chave]['altitude'] = 'cordilheira'

    areas_sem_definicao = {}
    areas_definidas = {}
    referencias_umidade = random.sample(areas, 60)

    for area in areas:
        areas_sem_definicao[area] = []
        areas_definidas[area] = []

    for n in range(fator * 3 // 2):
        if not areas_sem_definicao:
            break
        for node in referencias_umidade:
            altitude = random.randint(0, 12)
            areas_definidas[node].append(altitude)
            if node in areas_sem_definicao:
                del areas_sem_definicao[node]
            distancias = networkx.single_source_shortest_path_length(geografia, node)
            nos_a_n_arestas = [node for node, distance in distancias.items() if distance == n + 1]
            for neighbor in nos_a_n_arestas:
                if neighbor in areas_sem_definicao and neighbor not in referencias_umidade:
                    areas_sem_definicao[neighbor].append(altitude)
        for chave in list(areas_sem_definicao.keys()):
            if areas_sem_definicao[chave]:
                areas_definidas[chave].append(round(mean(areas_sem_definicao[chave]), 3))
                del areas_sem_definicao[chave]

    chaves = list(areas_definidas.keys())
    random.shuffle(chaves)
    chaves_ordenadas = sorted(chaves, key=lambda chave: areas_definidas[chave])

    for i, chave in enumerate(chaves_ordenadas):
        if i <= len(chaves_ordenadas) * 25 // 100:
            geografia.nodes[chave]['umidade'] = 'arido'
        elif i <= len(chaves_ordenadas) * 50 // 100:
            geografia.nodes[chave]['umidade'] = 'semi-arido'
        elif i <= len(chaves_ordenadas) * 75 // 100:
            geografia.nodes[chave]['umidade'] = 'fertil'
        else:
            geografia.nodes[chave]['umidade'] = 'umido'

    # Definição das placas com dois pontos de referência cada
    placas = ['Alpha', 'Beta', 'Gamma', 'Delta', 'Epsilon', 'Zeta',
            'Eta', 'Theta', 'Iota', 'Kappa', 'Lambda', 'Mu',
            'Nu', 'Xi', 'Omicron', 'Pi', 'Rho', 'Sigma',
            'Tau', 'Upsilon', 'Phi', 'Chi', 'Psi', 'Omega']
    
    # Gerar duas referências para cada placa (total 48)
    placas_duplicadas = placas * 2
    random.shuffle(placas_duplicadas)
    referencias_geologia = random.sample(areas, 48)

    # Atribuir cada referência a uma placa
    areas_definidas = {area: None for area in areas}
    for i, node in enumerate(referencias_geologia):
        areas_definidas[node] = placas_duplicadas[i]

    # Calcular a placa para cada nó baseado na proximidade
    for node in areas_definidas:
        if areas_definidas[node] is not None:
            continue  # Pula pontos de referência já definidos
        
        # Encontrar todas as distâncias para pontos de referência
        distancias = []
        for ref in referencias_geologia:
            try:
                dist = networkx.shortest_path_length(geografia, ref, node)
                distancias.append( (ref, dist) )
            except networkx.exception.NetworkXNoPath:
                continue
        
        if not distancias:
            areas_definidas[node] = random.choice(placas)
            continue
        
        # Encontrar a distância mínima
        min_dist = min(d[1] for d in distancias)
        candidatos = [d[0] for d in distancias if d[1] == min_dist]
        
        # Escolher aleatoriamente entre candidatos equidistantes
        ref_escolhida = random.choice(candidatos)
        areas_definidas[node] = areas_definidas[ref_escolhida]
    
    coeficiente_movimento = 300

    # Gerar cores para as placas
    cores_placas = []
    for _ in range(24):
        while True:
            r = random.randint(0, 255)
            g = random.randint(0, 255)
            b = random.randint(0, 255)
            if (r + g + b) > 127.5:
                cores_placas.append((r, g, b))
                break

    latitude_equador = fator * 3 / 2

    for chave, valor in areas_definidas.items():
        geografia.nodes[chave]['placa'] = valor
        geografia.nodes[chave]['cor_placa'] = cores_placas[placas.index(valor)]
        geografia.nodes[chave]['letra_grega'] = letra_grega(geografia.nodes[chave]['placa'])
        if chave[0] < latitude_equador:
            distancia_para_equador = latitude_equador - chave[0]
            angulo = distancia_para_equador * 90 / latitude_equador
            incidencia_solar = math.cos(math.radians(angulo))
        elif chave[0] == latitude_equador:
            distancia_para_equador = 0
            angulo = distancia_para_equador * 90 / latitude_equador
            incidencia_solar = math.cos(math.radians(angulo))
        else:
            distancia_para_equador = chave[0] - latitude_equador
            angulo = distancia_para_equador * 90 / latitude_equador
            incidencia_solar = math.cos(math.radians(angulo))
        if geografia.nodes[chave]['altitude'] == 'abissal' \
        or geografia.nodes[chave]['altitude'] == 'barreira' \
        or geografia.nodes[chave]['altitude'] == 'plataforma':
            fator_altitude = 3
        elif geografia.nodes[chave]['altitude'] == 'planicie':
            fator_altitude = 1
        elif geografia.nodes[chave]['altitude'] == 'planalto':
            fator_altitude = -1
        elif geografia.nodes[chave]['altitude'] == 'cordilheira':
            fator_altitude = -3
        if geografia.nodes[chave]['umidade'] == 'umido':
            fator_umidade = 1.5
        elif geografia.nodes[chave]['umidade'] == 'fertil':
            fator_umidade = 0.5
        elif geografia.nodes[chave]['umidade'] == 'semi-arido':
            fator_umidade = -0.5
        elif geografia.nodes[chave]['umidade'] == 'arido':
            fator_umidade = -1.5
        geografia.nodes[chave]['temperatura'] = round(40 * incidencia_solar - 8 + fator_altitude + fator_umidade, 1) - 4

    for node, atributos in geografia.nodes(data=True):
        temperatura = atributos.get('temperatura')
        altitude = atributos.get('altitude')
        umidade = atributos.get('umidade')
        
        if temperatura < 0:
            atributos['bioma'] = 'Ice'
        else:
            if altitude == 'cordilheira':
                atributos['bioma'] = 'Mountains'
            elif altitude == 'planalto':
                atributos['bioma'] = 'Hills'
            elif altitude == 'planicie':
                if umidade == 'umido':
                    atributos['bioma'] = 'Forest'
                elif umidade == 'fertil':
                    atributos['bioma'] = 'Meadow'
                elif umidade == 'semi-arido':
                    atributos['bioma'] = 'Savanna'
                else:
                    atributos['bioma'] = 'Desert'
            elif altitude == 'plataforma':
                atributos['bioma'] = 'Coast'
            elif altitude == 'barreira':
                atributos['bioma'] = 'Sea'
            else:
                atributos['bioma'] = 'Ocean'
        
        # Aplica custo base diretamente do dicionário
        atributos['cust_mob'] = CUSTOS_BASE[atributos['bioma']] * coeficiente_movimento

    for u, v in geografia.edges():
        mob_u = geografia.nodes[u]['cust_mob']
        mob_v = geografia.nodes[v]['cust_mob']
        
        u_maritimo = geografia.nodes[u]['bioma'] in ['Coast', 'Sea', 'Ocean']
        v_maritimo = geografia.nodes[v]['bioma'] in ['Coast', 'Sea', 'Ocean']
        
        if u_maritimo != v_maritimo:  # Transição terra-mar
            geografia[u][v]['cust_mob'] = max(mob_u, mob_v) * 2 + PENALIDADE_TRANSICAO * coeficiente_movimento
        else:
            geografia[u][v]['cust_mob'] = (mob_u + mob_v) / 2

        # Bônus para rotas oceânicas longas
        if u_maritimo and v_maritimo:
            geografia[u][v]['cust_mob'] *= 0.7

    cores_biomas = {
        'Ocean': (0, 23, 98), 'Sea': (8, 33, 113), 'Coast': (12, 71, 108), 'Meadow': (91, 174, 70), 'Savanna': (231, 190, 141),
        'Forest': (75, 129, 66), 'Desert': (242, 242, 166), 'Hills': (201, 147, 121), 'Mountains': (158, 86, 86), 'Ice': (245, 255, 245)
    }

    bioma_escolhido = []

    for node in geografia.nodes:
        geografia.nodes[node]['cor_bioma'] = cores_biomas[geografia.nodes[node]['bioma']]
        if geografia.nodes[node]['bioma'] == f'{bioma}':
            bioma_escolhido.append(node)

    bioma_escolhido = [n for n, attr in geografia.nodes(data=True) if attr['bioma'] == f'{bioma}']
    lista_capitais = [choice(bioma_escolhido)]
    while len(lista_capitais) < len(bioma_escolhido) // 2:
        d2 = {}
        for candidato in bioma_escolhido:
            if candidato in lista_capitais:
                continue
            d = {}
            for capital in lista_capitais:
                d[capital] = networkx.shortest_path_length(geografia, source=candidato, target=capital, weight='custo_mobilidade')
            d2[candidato] = min(d.values())
        if not d2:  # Se não houver candidatos possíveis, o planeta não comporta a quantidade desejada
            print("d2 vazio")
            raise ValueError("O planeta não comporta essa quantidade de civilizações!")
        maior_valor = max(d2.values())
        chaves_maior_valor = [chave for chave, valor in d2.items() if valor == maior_valor]
        lista_capitais.append(choice(chaves_maior_valor))

    print(f"número de {bioma}:", len(bioma_escolhido))
    return geografia, lista_capitais


================================================================================
📄 shared/civilization.py
================================================================================
import random
from shared.flags import bandeira

class Civilizacao:
    def __init__(self, ref, indice, nome, player=False, ponto_inicial=None):
        self.player = player
        self.nome = nome
        self.cultura = ref.culturas[indice % len(ref.culturas)]
        self.cor = ref.civs_cores[self.nome]
        self.modalidade_bandeira = random.randint(0, 82)
        self.cores_bandeira = bandeira(self.nome, self.modalidade_bandeira)
        self.ponto_inicial = ponto_inicial
        self.provincias = []
        self.unidades = []

================================================================================
📄 shared/province.py
================================================================================
from shared.naming import formar_nome

class Provincia:
    def __init__(self, civilizacao, coordenadas):
        self.civilizacao = civilizacao
        self.coordenadas = coordenadas
        self.nome = formar_nome(civilizacao.cultura)

================================================================================
📄 shared/world.py
================================================================================
# shared/world.py
import random
from uuid import uuid4
from shared.references import Referencias
from shared.planet import Planeta
from shared.civilization import Civilizacao
from shared.province import Provincia


class Mundo:
    def __init__(self, fator=4, bioma='Meadow', id_mundo=None):
        self.id_mundo = id_mundo or str(uuid4())
        ref = Referencias()
        random.shuffle(ref.culturas)
        lista_de_cores = list(ref.civs_cores.keys())
        random.shuffle(lista_de_cores)
        self.planeta = Planeta(fator=fator, bioma=bioma)
        self.civs = []

        # Criar civilizações com capitais corretas
        for i, capital in enumerate(self.planeta.capitais_players):
            nome = lista_de_cores[i % len(lista_de_cores)]
            civ = Civilizacao(ref, i, nome, True, capital)
            self.civs.append(civ)

        for i, capital in enumerate(self.planeta.capitais_neutros):
            indice = i + len(self.planeta.capitais_players)
            nome = lista_de_cores[indice % len(lista_de_cores)]
            civ = Civilizacao(ref, indice, nome, False, capital)
            self.civs.append(civ)

        # Atribuir província inicial usando o ponto_inicial de cada civ
        for civ in self.civs:
            provincia = Provincia(civ, civ.ponto_inicial)
            civ.provincias.append(provincia)

================================================================================
📄 shared/references.py
================================================================================
class Referencias:
    def __init__(self):
        self.culturas = [
            'English', 'Chinese', 'Spanish',
            'French', 'Indian', 'Russian',
            'Vietnamese', 'Turkish', 'Arabic',
            'Indonesian', 'Persian', 'Hausa',
            'Swahili', 'Portuguese', 'Telugu',
            'Bengali', 'Japanese', 'Marathi',
            'Wu', 'Yue', 'Min',
            'Korean', 'Italian', 'German'
        ]
        self.civs_cores = {
            'Black': (16, 16, 16), 'Midnight Blue': (0, 0, 127), 'Blue': (0, 0, 255),
            'Dark Green': (0, 127, 0), 'Teal': (0, 127, 127), 'Sky Blue': (32, 127, 223),
            'Green': (0, 255, 0), 'Spring Green': (0, 255, 127), 'Cyan': (0, 223, 223),
            'Maroon': (127, 0, 0), 'Purple': (127, 0, 127), 'Violet': (127, 0, 255),
            'Olive': (127, 127, 0), 'Gray': (127, 127, 127), 'Lavender': (127, 127, 255),
            'Chartreuse': (127, 255, 0), 'Light Green': (127, 223, 127), 'Pale Cyan': (127, 255, 255),
            'Red': (234, 33, 37), 'Rose': (255, 0, 127), 'Magenta': (255, 0, 255),
            'Orange': (223, 127, 32), 'Salmon': (255, 127, 127), 'Orchid': (255, 127, 255),
            'Yellow': (255, 255, 0), 'Light Yellow': (255, 255, 127), 'White': (250, 255, 253)
        }

        self.tons_de_pele = [(245, 212, 205), (212, 160, 147), (163, 106, 95), (101, 61, 53)]
        self.tons_de_cabelo = [(209, 195, 2), (140, 106, 0), (99, 55, 26), (52, 48, 47)]

================================================================================
✅ Total de 18 arquivos incluídos.
================================================================================