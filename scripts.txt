ARQUIVO DE C√ìDIGO CONSOLIDADO
Gerado em: 2025-08-24 17:41:04
Diret√≥rio: /home/mariagoreti/quan_qiu_wu_tai
Conte√∫do dos scripts principais reunidos.

================================================================================

================================================================================
üìÅ ESTRUTURA DO PROJETO
================================================================================

üìÅ .
‚îú‚îÄ‚îÄ server
‚îÇ   ‚îú‚îÄ‚îÄ config
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ config.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ extensions.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ initializer.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ signals.py
‚îÇ   ‚îú‚îÄ‚îÄ core
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ commander.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ interface.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ manager.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ registrar_players.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ simulador_players.py
‚îÇ   ‚îú‚îÄ‚îÄ integrations
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ aws_loader.py
‚îÇ   ‚îú‚îÄ‚îÄ routes
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ game.py
‚îÇ   ‚îú‚îÄ‚îÄ saves
‚îÇ   ‚îú‚îÄ‚îÄ services
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ matchmaking_service.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ queue_service.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user_service.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ world_pool.py
‚îÇ   ‚îú‚îÄ‚îÄ tools
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ sei_la_o_que.py
‚îÇ   ‚îú‚îÄ‚îÄ app.py
‚îÇ   ‚îî‚îÄ‚îÄ serialization.py
‚îú‚îÄ‚îÄ client
‚îÇ   ‚îú‚îÄ‚îÄ components
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ icon_manager.py
‚îÇ   ‚îú‚îÄ‚îÄ dialogs
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ auth_dialog.py
‚îÇ   ‚îú‚îÄ‚îÄ resources
‚îÇ   ‚îú‚îÄ‚îÄ states
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ waiting_room.py
‚îÇ   ‚îú‚îÄ‚îÄ widgets
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ game_placeholder.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ status_room.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ waiting_room_overlay.py
‚îÇ   ‚îî‚îÄ‚îÄ main.py
‚îú‚îÄ‚îÄ shared
‚îÇ   ‚îú‚îÄ‚îÄ civilization.py
‚îÇ   ‚îú‚îÄ‚îÄ geography.py
‚îÇ   ‚îú‚îÄ‚îÄ planet.py
‚îÇ   ‚îú‚îÄ‚îÄ polygons.py
‚îÇ   ‚îú‚îÄ‚îÄ province.py
‚îÇ   ‚îú‚îÄ‚îÄ references.py
‚îÇ   ‚îî‚îÄ‚îÄ world.py

================================================================================
üìÑ CONTE√öDO DOS ARQUIVOS
================================================================================

================================================================================
üìÑ server/app.py
================================================================================
# server/app.py
from flask import Flask, jsonify
from server.config.config import config
from server.config.extensions import ext
from server.services.user_service import UserService
from server.routes.auth import auth_bp, register_routes
from server.routes.game import jogo_bp, register_jogo_routes
from server.services.matchmaking_service import MatchmakingService
from server.services.world_pool import MundoPoolService  # ‚úÖ Importe o novo servi√ßo
from server.integrations.aws_loader import AWSLoader
from server.core.manager import Gerenciador


def create_app(config_name='default'):
    """Factory function para criar a aplica√ß√£o Flask."""
    app = Flask(__name__)

    # 1. Carrega a configura√ß√£o
    app.config.from_object(config[config_name])

    # 2. Inicializa as extens√µes
    ext.init_app(app)

    # 3. Cria inst√¢ncias de servi√ßos, injetando depend√™ncias
    user_service = UserService(ext.dynamodb, app.config['DYNAMODB_TABLE_NAME'])
    print(f"‚úÖ DEBUG: UserService criado: {user_service}")

    # --- üîπ AWS Loader e Gerenciador de Mundos ---
    aws_loader = AWSLoader(
        profile_name=app.config.get('AWS_PROFILE_NAME'),
        region_name=app.config.get('AWS_REGION_NAME')
    )

    # ‚úÖ Passando o nome da tabela DynamoDB para o Gerenciador
    gerenciador = Gerenciador(
        aws_loader=aws_loader,
        save_dir="saves",
        dynamodb_table_name=app.config['DYNAMODB_TABLE_NAME']  # ‚Üê Corre√ß√£o essencial
    )

    # --- üîπ World Pool: Gerencia mundos pr√©-criados ---
    world_pool = MundoPoolService(
        gerenciador=gerenciador,
        fator=4,
        bioma="Meadow",
        min_mundos=3,
        max_mundos=10,
        intervalo_verificacao=5.0
    )

    # --- üîπ Matchmaking: Sistema Avan√ßado de Salas ---
    # MatchmakingService agora recebe o world_pool, n√£o o gerenciador diretamente
    matchmaking_service = MatchmakingService(world_pool=world_pool)

    # Callback para quando uma partida for formada
    def partida_formada(jogadores):
        print(f"\nüéâüéâüéâ PARTIDA INICIADA COM: {jogadores}")
        print(f"üéÆ Os jogadores est√£o prontos para o combate!\n")
        # Aqui voc√™ pode:
        # - Notificar jogadores via WebSocket
        # - Registrar a partida no DynamoDB
        # - Iniciar a l√≥gica do jogo

    # ‚úÖ Registra o callback no novo servi√ßo
    matchmaking_service.partida_iniciada_callback = partida_formada

    # Armazena servi√ßos no app.config para acesso futuro, se necess√°rio
    app.config['USER_SERVICE'] = user_service
    app.config['MATCHMAKING_SERVICE'] = matchmaking_service

    # 4. Registra os Blueprints e injeta depend√™ncias
    print("üìã DEBUG: Iniciando inje√ß√£o de depend√™ncias e registro de blueprints...")

    # --- üîπ Auth ---
    print("üîß DEBUG: Injetando UserService em auth_bp...")
    register_routes(user_service)
    print(f"‚úÖ DEBUG: register_routes(user_service) chamado com sucesso.")
    app.register_blueprint(auth_bp)
    print("‚úÖ DEBUG: auth_bp registrado no app.")

    # --- üîπ Jogo Online (NOVO) ---
    register_jogo_routes(user_service, matchmaking_service)
    app.register_blueprint(jogo_bp)
    print("‚úÖ DEBUG: jogo_bp registrado no app.")

    # 5. Rotas principais (opcional)
    @app.route('/')
    def home():
        return "üöÄ Servidor Global Arena - API (Refatorado com Classes)", 200

    # üîç Rota de status do matchmaking (monitoramento)
    @app.route('/status')
    def status():
        return jsonify({
            "success": True,
            "total_na_fila": world_pool.total_jogadores_na_fila(),  # ‚úÖ Agora existe
            "mundos_no_pool": world_pool.quantidade_total(),
            "vagas_disponiveis": world_pool.quantidade_vagas(),
            "partidas_ativas": len(matchmaking_service.salas)
        })

    return app


# Para execu√ß√£o direta (ex: python server/app.py)
if __name__ == '__main__':
    app = create_app('development')  # Ou 'production'
    print("üöÄ Iniciando Servidor Global Arena (Flask - Refatorado)...")
    print("üìÑ Endpoints dispon√≠veis:")
    print("   GET  /                        - Status do servidor")
    print("   GET  /status                  - Status do matchmaking e pool de mundos")
    print("   GET  /auth/teste_dynamodb     - Teste de conex√£o com DynamoDB")
    print("   POST /jogo/entrar             - Entrar na fila de jogo online (novo)")
    print("-" * 40)
    app.run(host='127.0.0.1', port=5000, debug=app.config['DEBUG'])

================================================================================
üìÑ server/serialization.py
================================================================================
# server/serialization.py
import json
import networkx as nx
import numpy as np
from pathlib import Path
from typing import Any, Dict, Optional
from shared.world import Mundo
from shared.references import Referencias


class Serializador:
    """
    Classe respons√°vel por serializar e desserializar o estado completo de um Mundo.
    Converte para dict serializ√°vel em JSON, salva em disco e recarrega.
    """

    @staticmethod
    def _convert(value: Any) -> Any:
        """
        Converte valores n√£o serializ√°veis em tipos compat√≠veis com JSON.
        """
        if isinstance(value, np.integer):
            return int(value)
        if isinstance(value, np.floating):
            return float(value)
        if isinstance(value, np.ndarray):
            return value.tolist()
        if isinstance(value, tuple):
            return list(value)
        if hasattr(value, '__dict__'):
            return {k: Serializador._convert(v) for k, v in value.__dict__.items() if not k.startswith('_')}
        return value

    @classmethod
    def to_serializable_dict(cls, mundo: Mundo) -> Dict[str, Any]:
        """
        Converte um objeto Mundo em um dicion√°rio compat√≠vel com JSON.
        Remove atributos deriv√°veis para reduzir tamanho.
        """
        if not hasattr(mundo, 'planeta') or not hasattr(mundo, 'civs'):
            raise ValueError("Objeto mundo inv√°lido: falta atributos 'planeta' ou 'civs'")

        G = mundo.planeta.geografia.copy()

        # Atributos que podem ser recalculados, ent√£o n√£o precisam ser salvos
        node_attrs_to_remove = {
            'cor_placa', 'cor_bioma', 'letra_grega', 'cust_mob', 'tipo', 'altitude', 'umidade', 'temperatura',
        }
        for node in G.nodes:
            for attr in node_attrs_to_remove:
                G.nodes[node].pop(attr, None)  # Remove silenciosamente

        # Remover arestas (ser√£o recalculadas com custo de mobilidade)
        G.remove_edges_from(list(G.edges))

        # Converter atributos dos n√≥s
        for node in G.nodes:
            attrs = G.nodes[node]
            for key in list(attrs.keys()):
                attrs[key] = cls._convert(attrs[key])

        # Usa 'edges="links"' para manter compatibilidade com o formato antigo
        # O padr√£o futuro ser√° 'edges="edges"', mas queremos evitar mudan√ßas inesperadas
        G_data = nx.node_link_data(G, edges="links")
        G_data.pop("directed", None)
        G_data.pop("multigraph", None)
        G_data.pop("graph", None)

        # Serializar civiliza√ß√µes
        civilizacoes_data = []
        for civ in mundo.civs:
            civ_data = {
                'nome': civ.nome,
                'cultura': civ.cultura,
                'cor': cls._convert(civ.cor),
                'modalidade_bandeira': civ.modalidade_bandeira,
                'cores_bandeira': cls._convert(civ.cores_bandeira),
                'player': civ.player,
                'provincias': [
                    {
                        'coordenadas': cls._convert(p.coordenadas),
                        'nome': p.nome
                    }
                    for p in civ.provincias
                ]
            }
            civilizacoes_data.append(civ_data)

        return {
            "id_mundo": mundo.id_mundo,
            "fator": mundo.planeta.fator,
            "bioma_inicial": mundo.planeta.bioma_inicial,
            "vagas": mundo.planeta.numero_de_jogadores,
            "geografia": G_data,
            "civilizacoes": civilizacoes_data
        }

    @classmethod
    def from_serializable_dict(cls, data: Dict[str, Any], ref: Optional[Referencias] = None):
        """
        Reconstroi um objeto Mundo a partir de um dicion√°rio.
        Requer uma inst√¢ncia de Referencias para inicializa√ß√£o.
        """
        """
        Ainda a ser implementado
        retorna Mundo
        """

    @classmethod
    def save_to_json(cls, mundo: Mundo, filepath: str) -> bool:
        try:
            data = cls.to_serializable_dict(mundo)
            path = Path(filepath)
            path.parent.mkdir(exist_ok=True, parents=True)
            with open(path, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
            print(f"‚úÖ Mundo salvo em JSON: {filepath}")
            return True
        except Exception as e:
            print(f"‚ùå Falha ao salvar mundo: {e}")
            return False

    @classmethod
    def save_mundo(cls, mundo: Mundo, filepath: str = None) -> str:
        """
        Salva um objeto Mundo em JSON.
        Se filepath n√£o for fornecido, gera um nome autom√°tico em 'saves/'.
        :param mundo: Inst√¢ncia de Mundo
        :param filepath: Caminho opcional para salvar
        :return: Caminho final usado, ou string vazia se falhar
        """
        from pathlib import Path

        if filepath is None:
            # Gera caminho padr√£o: saves/mundo_{id}.json
            saves_dir = Path("saves")
            saves_dir.mkdir(exist_ok=True)
            filepath = saves_dir / f"mundo_{mundo.id_mundo}.json"
        else:
            # Garante que o diret√≥rio pai exista
            path = Path(filepath)
            path.parent.mkdir(exist_ok=True, parents=True)

        sucesso = cls.save_to_json(mundo, filepath)
        return str(filepath) if sucesso else ""

================================================================================
üìÑ server/services/matchmaking_service.py
================================================================================
# server/services/matchmaking_service.py
from typing import List, Optional, Callable
import threading
from shared.world import Mundo
from server.services.world_pool import MundoPoolService  # ‚úÖ Inje√ß√£o de depend√™ncia

class SalaDeEspera:
    def __init__(self, mundo: Mundo, callback: Callable[[List[str]], None]):
        self.mundo = mundo
        self.vagas = len(mundo.planeta.capitais_players)  # ‚úÖ Vagas definidas pelo mundo
        self.jogadores = []
        self.lock = threading.Lock()
        self.callback = callback

    def adicionar_jogador(self, username: str) -> str:
        with self.lock:
            if username in self.jogadores:
                return f"Erro ao entrar na fila: {username} j√° est√° na sala."
            if len(self.jogadores) >= self.vagas:
                return "Erro ao entrar na fila: sala cheia."

            self.jogadores.append(username)

            if len(self.jogadores) == self.vagas:
                self.callback(self.jogadores.copy())

            return f"{username} entrou na sala {self.mundo.id_mundo} ({len(self.jogadores)}/{self.vagas})"

    def esta_cheia(self) -> bool:
        with self.lock:
            return len(self.jogadores) >= self.vagas

    def tamanho(self) -> int:
        with self.lock:
            return len(self.jogadores)

    def remover_jogador(self, username: str) -> bool:
        """Remove um jogador da sala. Retorna True se encontrado."""
        if username in self.jogadores:
            self.jogadores.remove(username)
            print(f"üóëÔ∏è Jogador '{username}' removido da sala de espera.")
            return True
        return False


class MatchmakingService:
    """
    Matchmaking baseado em MUNDOS PR√â-CRIADOS fornecidos pelo MundoPoolService.
    O MatchmakingService n√£o cria mundos ‚Äî apenas aloca jogadores.
    """
    def __init__(self, world_pool: MundoPoolService):
        self.world_pool = world_pool
        self.salas: List[SalaDeEspera] = []  # Salas ativas com vagas
        self.lock = threading.Lock()
        self.partida_iniciada_callback: Optional[Callable[[List[str]], None]] = None

    def _on_partida_cheia(self, jogadores: List[str]):
        """Callback interno chamado quando uma sala enche."""
        if self.partida_iniciada_callback:
            self.partida_iniciada_callback(jogadores)

    def entrar_na_fila(self, username: str) -> str:
        """
        1. Obt√©m um mundo com vaga do MundoPoolService.
        2. Associa o jogador a esse mundo (cria ou entra em sala).
        3. Registra ocupa√ß√£o no pool.
        """
        with self.lock:
            # 1. Obter um mundo com vaga dispon√≠vel
            mundo = self.world_pool.obter_mundo_com_vaga()
            if not mundo:
                return f"Erro ao entrar na fila: nenhum mundo dispon√≠vel para {username}."

            # 2. Verificar se j√° existe uma sala para esse mundo
            sala_existente = next((s for s in self.salas if s.mundo.id_mundo == mundo.id_mundo), None)

            if sala_existente:
                mensagem = sala_existente.adicionar_jogador(username)
            else:
                # Criar nova sala para esse mundo
                nova_sala = SalaDeEspera(mundo=mundo, callback=self._on_partida_cheia)
                self.salas.append(nova_sala)
                mensagem = nova_sala.adicionar_jogador(username)

            # 3. Registrar no pool que o jogador ocupou uma vaga
            if "Erro" not in mensagem:
                self.world_pool.registrar_jogador_no_mundo(username, mundo)

            print(mensagem)
            return mensagem

    def sair_da_fila(self, username: str) -> bool:
        """Remove o jogador da fila de qualquer sala."""
        with self.lock:
            for sala in self.salas:
                if sala.remover_jogador(username):
                    print(f"üì§ {username} removido da sala {sala.mundo.id_mundo}")
                    return True
            return False

================================================================================
üìÑ server/services/queue_service.py
================================================================================
# server/services/queue_service.py
"""
Servi√ßo de fila de espera para matchmaking online.
Gerencia a entrada de jogadores e forma√ß√£o de partidas quando h√° 4+ jogadores.
"""

import threading
from typing import Optional, Callable


class FilaService:
    """
    Servi√ßo respons√°vel por gerenciar a fila de jogadores online.
    Forma partidas automaticamente quando 4 jogadores est√£o na fila.
    """

    def __init__(self):
        self.fila = []
        self.lock = threading.Lock()
        self.partida_iniciada_callback: Optional[Callable[[list], None]] = None

    def adicionar_jogador(self, username: str) -> bool:
        with self.lock:
            if username in self.fila:
                print(f"‚ö†Ô∏è '{username}' j√° est√° na fila. Bloqueado.")
                return False
            self.fila.append(username)
            print(f"üì• Jogador '{username}' adicionado √† fila. Total: {len(self.fila)}")
            self._tentar_formar_partida()
            return True

    def remover_jogador(self, username: str):
        """
        Remove um jogador da fila, se estiver presente.
        """
        with self.lock:
            if username in self.fila:
                self.fila.remove(username)
                print(f"üì§ Jogador '{username}' removido da fila.")

    def _tentar_formar_partida(self):
        with self.lock:
            print(f"üîç Verificando forma√ß√£o de partida. Fila atual: {self.fila} (total: {len(self.fila)})")  # ‚Üê Novo log
            if len(self.fila) >= 4:
                partida = [self.fila.pop(0) for _ in range(4)]
                print(f"üéâ Partida formada com: {partida}")
                if self.partida_iniciada_callback:
                    try:
                        self.partida_iniciada_callback(partida)
                    except Exception as e:
                        print(f"‚ùå Erro ao executar partida_iniciada_callback: {e}")
                else:
                    print("‚ÑπÔ∏è Nenhum callback configurado.")

================================================================================
üìÑ server/services/user_service.py
================================================================================
# server/services/user_service.py
import bcrypt
from botocore.exceptions import ClientError


class UserService:
    def __init__(self, dynamodb_client, table_name):
        self.dynamodb = dynamodb_client
        self.table_name = table_name

    def _format_user_key(self, username: str) -> dict:
        """Formata a chave prim√°ria do usu√°rio no DynamoDB."""
        return {
            'PK': {'S': f'USER#{username}'},
            'SK': {'S': 'PROFILE'}
        }

    def get_user(self, username: str) -> dict:
        """Busca um usu√°rio pelo username."""
        if not self.dynamodb:
            print("‚ö†Ô∏è Cliente DynamoDB n√£o dispon√≠vel no UserService.")
            return None
        try:
            response = self.dynamodb.get_item(
                TableName=self.table_name,
                Key=self._format_user_key(username)
            )
            return response.get('Item')
        except ClientError as e:
            print(f"‚ùå Erro do DynamoDB ao buscar usu√°rio '{username}': {e.response['Error']['Message']}")
            return None
        except Exception as e:
            print(f"‚ùå Erro inesperado ao buscar usu√°rio '{username}': {e}")
            return None

    def create_user_item(self, username: str, **attributes) -> bool:
        """
        Cria um novo item de usu√°rio no DynamoDB.
        `attributes` pode conter {'password_hash': bytes, 'outro_attr': valor, ...}
        """
        if not self.dynamodb:
            print("‚ö†Ô∏è Cliente DynamoDB n√£o dispon√≠vel no UserService.")
            return False
        try:
            # Inicia o item com a chave prim√°ria
            item = self._format_user_key(username)

            # Adiciona outros atributos fornecidos
            for attr_name, attr_value in attributes.items():
                # Trata tipos espec√≠ficos
                if isinstance(attr_value, bytes):
                    # Para password_hash, salva como tipo bin√°rio 'B'
                    item[attr_name] = {'B': attr_value}
                elif isinstance(attr_value, str):
                    # Para strings, salva como tipo string 'S'
                    item[attr_name] = {'S': attr_value}
                elif isinstance(attr_value, (int, float)):
                    # Para n√∫meros, salva como tipo n√∫mero 'N' (convertido para string)
                    item[attr_name] = {'N': str(attr_value)}
                else:
                    # Para outros tipos, converte para string e salva como 'S'
                    # (voc√™ pode querer ser mais espec√≠fico aqui dependendo das suas necessidades)
                    print(
                        f"‚ö†Ô∏è Atributo '{attr_name}' tem tipo inesperado ({type(attr_value)}). Convertendo para string.")
                    item[attr_name] = {'S': str(attr_value)}

            self.dynamodb.put_item(
                TableName=self.table_name,
                Item=item
            )
            print(f"‚úÖ Item de usu√°rio '{username}' criado/Atualizado no DynamoDB.")
            return True
        except ClientError as e:
            print(f"‚ùå Erro do DynamoDB ao criar usu√°rio '{username}': {e.response['Error']['Message']}")
            return False
        except Exception as e:
            print(f"‚ùå Erro inesperado ao criar usu√°rio '{username}': {e}")
            return False

    def authenticate_user(self, username: str, password: str) -> tuple[bool, str]:
        """
        Autentica um usu√°rio verificando a senha com bcrypt.

        :param username: Nome de usu√°rio.
        :param password: Senha em texto plano.
        :return: (sucesso: bool, mensagem: str)
        """
        if not username or not password:
            return False, "Usu√°rio ou senha ausentes."

        # 1. Buscar usu√°rio
        user = self.get_user(username)
        if not user:
            return False, "Usu√°rio n√£o encontrado."

        # 2. Extrair o hash da senha
        password_hash_attr = user.get('password_hash')
        if not password_hash_attr:
            return False, "Usu√°rio sem senha cadastrada."

        # 3. O hash pode vir como {'B': bytes} do DynamoDB
        if isinstance(password_hash_attr, dict) and 'B' in password_hash_attr:
            stored_hash = password_hash_attr['B']
        elif isinstance(password_hash_attr, bytes):
            stored_hash = password_hash_attr
        else:
            return False, "Formato de hash de senha inv√°lido."

        # 4. Verificar com bcrypt
        try:
            if bcrypt.checkpw(password.encode('utf-8'), stored_hash):
                return True, "Login bem-sucedido."
            else:
                return False, "Senha incorreta."
        except Exception as e:
            print(f"‚ùå Erro ao verificar senha com bcrypt: {e}")
            return False, "Erro interno ao processar autentica√ß√£o."


================================================================================
üìÑ server/services/world_pool.py
================================================================================
# server/services/world_pool.py
from typing import List, Optional, Dict
import threading
from shared.world import Mundo
from server.core.manager import Gerenciador


class MundoPoolService:
    """
    Servi√ßo ativo que mant√©m um n√∫mero m√≠nimo de mundos com vagas dispon√≠veis.
    Reabastece automaticamente o pool quando necess√°rio.
    """
    def __init__(
        self,
        gerenciador: Gerenciador,
        fator: int = 4,
        bioma: str = "Meadow",
        min_mundos: int = 3,        # ‚úÖ M√≠nimo que queremos manter ativo
        max_mundos: int = 10,       # Limite total de mundos no sistema
        intervalo_verificacao: float = 5.0  # Tempo entre verifica√ß√µes (segundos)
    ):
        self.gerenciador = gerenciador
        self.fator = fator
        self.bioma = bioma
        self.min_mundos = min_mundos
        self.max_mundos = max_mundos
        self.intervalo_verificacao = intervalo_verificacao

        self.mundos_com_vaga: List[Mundo] = []  # Apenas mundos com pelo menos 1 vaga
        self.jogadores_por_mundo: Dict[str, List[str]] = {}  # id_mundo ‚Üí [user1, ...]
        self.lock = threading.Lock()

        # Controle da thread de reabastecimento
        self._thread_reabastecimento = None
        self._parar_reabastecimento = threading.Event()

        # Inicializa o pool e inicia o servi√ßo ativo
        self._inicializar_pool()
        self.iniciar_servico()

    def total_jogadores_na_fila(self) -> int:
        """Retorna o n√∫mero total de jogadores j√° alocados nos mundos do pool."""
        total = 0
        with self.lock:
            for jogadores in self.jogadores_por_mundo.values():
                total += len(jogadores)
        return total

    def quantidade_total(self) -> int:
        """Retorna o n√∫mero total de mundos com vagas dispon√≠veis no pool."""
        return self.quantidade_mundos_ativos()

    def _inicializar_pool(self):
        """Inicializa o pool com mundos existentes e cria novos apenas se necess√°rio."""
        print("üîÑ Inicializando pool de mundos...")

        # Etapa 1: Carregar mundos existentes com vagas
        self._carregar_mundos_existentes()

        # Etapa 2: Contar quantos ainda precisamos criar
        with self.lock:
            atual = len(self.mundos_com_vaga)
        print(f"üì¶ {atual} mundos com vagas j√° carregados.")

        # Etapa 3: Criar apenas o necess√°rio para atingir min_mundos
        a_criar = max(0, self.min_mundos - atual)
        print(f"üèóÔ∏è  Criando {a_criar} novos mundos para atingir o m√≠nimo ({self.min_mundos})...")

        for _ in range(a_criar):
            sucesso, mundo = self.gerenciador.criar_e_upload_mundo_com_retorno(
                fator=self.fator,
                bioma=self.bioma,
                bucket_name="global-arena-tiles",
                s3_prefix="planetas/"
            )
            if sucesso and mundo:
                with self.lock:
                    self.mundos_com_vaga.append(mundo)
                    self.jogadores_por_mundo[mundo.id_mundo] = []
                print(f"‚úÖ Mundo {mundo.id_mundo} adicionado ao pool inicial.")
            else:
                print("‚ö†Ô∏è Falha ao criar mundo durante inicializa√ß√£o.")

    def iniciar_servico(self):
        """Inicia o loop de monitoramento e reabastecimento."""
        if self._thread_reabastecimento is None:
            self._parar_reabastecimento.clear()
            self._thread_reabastecimento = threading.Thread(target=self._loop_reabastecimento, daemon=True)
            self._thread_reabastecimento.start()
            print(f"‚úÖ MundoPoolService: servi√ßo ativo iniciado (min={self.min_mundos}, max={self.max_mundos})")

    def parar_servico(self):
        """Para o servi√ßo de reabastecimento (para testes ou desligamento)."""
        if self._thread_reabastecimento is not None:
            self._parar_reabastecimento.set()
            self._thread_reabastecimento.join(timeout=2)
            print("üõë MundoPoolService: servi√ßo ativo parado.")

    def _loop_reabastecimento(self):
        """Loop cont√≠nuo que verifica e reabastece o pool."""
        while not self._parar_reabastecimento.is_set():
            self._parar_reabastecimento.wait(self.intervalo_verificacao)
            if self._parar_reabastecimento.is_set():
                break
            self._reabastecer()

    def _reabastecer(self):
        """Cria mundos at√© atingir min_mundos, respeitando max_mundos."""
        with self.lock:
            atual = len(self.mundos_com_vaga)
            if atual >= self.min_mundos:
                return  # J√° temos o m√≠nimo

            # Quantos mundos precisamos criar?
            a_criar = min(self.min_mundos - atual, self.max_mundos - len(self.mundos_com_vaga))
            for _ in range(a_criar):
                sucesso, mundo = self.gerenciador.criar_e_upload_mundo_com_retorno(
                    fator=self.fator,
                    bioma=self.bioma,
                    bucket_name="global-arena-tiles",
                    s3_prefix="planetas/"
                )
                if sucesso and mundo:
                    self.mundos_com_vaga.append(mundo)
                    self.jogadores_por_mundo[mundo.id_mundo] = []
                    print(f"üîÑ Mundo {mundo.id_mundo} criado. Pool agora tem {len(self.mundos_com_vaga)} mundos com vaga.")
                else:
                    print("‚ö†Ô∏è Falha ao criar mundo durante reabastecimento.")
                    break

    def obter_mundo_com_vaga(self) -> Optional[Mundo]:
        """Retorna um mundo com vaga dispon√≠vel, se houver."""
        with self.lock:
            for mundo in self.mundos_com_vaga:
                ocupadas = len(self.jogadores_por_mundo[mundo.id_mundo])
                if ocupadas < len(mundo.planeta.capitais_players):
                    return mundo
            return None

    def registrar_jogador_no_mundo(self, username: str, mundo: Mundo):
        """Registra um jogador em um mundo. Remove o mundo do pool se encher."""
        with self.lock:
            lista = self.jogadores_por_mundo[mundo.id_mundo]
            if username not in lista:
                lista.append(username)

            # Se o mundo encheu, remova do pool
            if len(lista) >= len(mundo.planeta.capitais_players):
                if mundo in self.mundos_com_vaga:
                    self.mundos_com_vaga.remove(mundo)
                    print(f"üóëÔ∏è Mundo {mundo.id_mundo} removido do pool (partida formada).")

    def quantidade_mundos_ativos(self) -> int:
        """Retorna quantos mundos ainda t√™m vagas dispon√≠veis."""
        with self.lock:
            return len(self.mundos_com_vaga)

    def quantidade_vagas_totais(self) -> int:
        """Retorna o n√∫mero total de vagas dispon√≠veis no pool."""
        total = 0
        with self.lock:
            for mundo in self.mundos_com_vaga:
                ocupadas = len(self.jogadores_por_mundo[mundo.id_mundo])
                total += len(mundo.planeta.capitais_players) - ocupadas
        return total

    def quantidade_vagas(self) -> int:
        """Retorna o n√∫mero total de vagas dispon√≠veis em todos os mundos do pool."""
        total = 0
        with self.lock:
            for mundo in self.mundos_com_vaga:
                ocupadas = len(self.jogadores_por_mundo.get(mundo.id_mundo, []))
                total += len(mundo.planeta.capitais_players) - ocupadas
        return total

    def _carregar_mundos_existentes(self):
        """Carrega mundos com vagas do DynamoDB para o pool, usando o gerenciador."""
        try:
            dynamodb = self.gerenciador.aws_loader.get_client('dynamodb')
            response = dynamodb.scan(
                TableName=self.gerenciador.dynamodb_table_name,
                # ‚úÖ Corrigido: usa begins_with para PK que come√ßa com "PLANET#"
                FilterExpression="begins_with(PK, :pk_prefix) AND vagas > :zero",
                ExpressionAttributeValues={
                    ":pk_prefix": {"S": "PLANET#"},
                    ":zero": {"N": "0"}
                }
            )

            with self.lock:
                for item in response.get('Items', []):
                    id_mundo = item['PK']['S'].split('#')[1]
                    vagas = int(item['vagas']['N'])
                    if vagas > 0:
                        if not any(m.id_mundo == id_mundo for m in self.mundos_com_vaga):
                            mundo_stub = Mundo(fator=self.fator, bioma=self.bioma)
                            mundo_stub.id_mundo = id_mundo
                            self.mundos_com_vaga.append(mundo_stub)
                            self.jogadores_por_mundo[id_mundo] = []
                            print(f"üîÅ Mundo carregado do DynamoDB: {id_mundo} ({vagas} vagas)")
        except Exception as e:
            print(f"‚ö†Ô∏è Falha ao carregar mundos existentes: {e}")
            import traceback
            traceback.print_exc()

================================================================================
üìÑ server/tools/sei_la_o_que.py
================================================================================
# sei_la_o_que.py

from server.integrations.aws_loader import AWSLoader  # ou from server.aws_loader import AWSLoader

def main():
    print("üöÄ Iniciando aplica√ß√£o...\n")

    # --- Configura√ß√£o ---
    loader = AWSLoader(
        region_name='us-east-2',
        # profile_name='seu-perfil'  # opcional
    )

    # --- 1. Informa√ß√µes da conta ---
    try:
        account = loader.get_account_info()
        print(f"‚úÖ Logado na conta AWS: {account['account_id']}")
        print(f"üë§ Usu√°rio/Role: {account['arn']}\n")
    except Exception as e:
        print(f"‚ùå Falha ao obter conta: {e}")
        return

    # --- 2. Listar buckets S3 ---
    try:
        buckets = loader.list_s3_buckets()
        print(f"üì¶ Buckets S3 encontrados ({len(buckets)}):")
        for bucket in buckets:
            print(f"  - {bucket}")
    except Exception as e:
        print(f"‚ùå Erro ao listar buckets S3: {e}")

    # --- 3. Listar tabelas DynamoDB ---
    try:
        tables = loader.list_dynamodb_tables()
        print(f"\nüìä Tabelas DynamoDB encontradas ({len(tables)}):")
        for table in tables:
            print(f"  - {table}")
    except Exception as e:
        print(f"‚ùå Erro ao listar tabelas DynamoDB: {e}")

    # --- 4. Exemplo: usar cliente S3 ---
    try:
        s3 = loader.get_client('s3')
        response = s3.list_buckets()
        print(f"\nüåç Conex√£o S3 bem-sucedida. Total de buckets: {len(response['Buckets'])}")
    except Exception as e:
        print(f"‚ùå Falha ao usar cliente S3: {e}")


if __name__ == "__main__":
    main()

================================================================================
üìÑ server/integrations/aws_loader.py
================================================================================
# aws_loader.py

import boto3
from botocore.exceptions import NoCredentialsError, PartialCredentialsError


class AWSLoader:
    def __init__(self, profile_name=None, region_name='us-east-2'):
        """
        Inicializa o loader de credenciais AWS.

        :param profile_name: Nome do perfil no arquivo ~/.aws/credentials (opcional)
        :param region_name: Regi√£o AWS padr√£o
        """
        self.profile_name = profile_name
        self.region_name = region_name
        self.session = None
        self._create_session()

    def _create_session(self):
        """Cria uma sess√£o boto3 com base no perfil ou nas credenciais padr√£o."""
        try:
            if self.profile_name:
                self.session = boto3.Session(profile_name=self.profile_name, region_name=self.region_name)
            else:
                self.session = boto3.Session(region_name=self.region_name)

            # Testa credenciais
            sts = self.session.client('sts')
            sts.get_caller_identity()
            print("‚úÖ Credenciais AWS carregadas com sucesso.")

        except NoCredentialsError:
            raise Exception("‚ùå Credenciais AWS n√£o encontradas. Configure AWS_ACCESS_KEY_ID e AWS_SECRET_ACCESS_KEY.")
        except PartialCredentialsError:
            raise Exception("‚ùå Credenciais incompletas. Verifique AWS_ACCESS_KEY_ID e AWS_SECRET_ACCESS_KEY.")
        except Exception as e:
            raise Exception(f"‚ùå Erro ao carregar credenciais: {e}")

    def get_credentials(self):
        """
        Retorna as credenciais (access key, secret key, token).
        """
        credentials = self.session.get_credentials()
        frozen_creds = credentials.get_frozen_credentials()
        return {
            'access_key': frozen_creds.access_key,
            'secret_key': frozen_creds.secret_key,
            'token': frozen_creds.token
        }

    def get_client(self, service_name):
        """Retorna um cliente boto3 para o servi√ßo especificado."""
        return self.session.client(service_name)

    def get_resource(self, service_name):
        """Retorna um recurso boto3 (ex: S3 resource)."""
        return self.session.resource(service_name)

    # --- üîß Novos m√©todos adicionados ---
    def get_account_info(self):
        """Retorna informa√ß√µes da conta AWS: ID, ARN, usu√°rio, regi√£o."""
        sts = self.session.client('sts')
        identity = sts.get_caller_identity()
        return {
            'account_id': identity['Account'],
            'user_id': identity['UserId'],
            'arn': identity['Arn'],
            'region': self.region_name
        }

    def list_s3_buckets(self):
        """Lista todos os buckets S3 da conta."""
        s3 = self.get_client('s3')
        response = s3.list_buckets()
        return [bucket['Name'] for bucket in response['Buckets']]

    def list_dynamodb_tables(self):
        """Lista todas as tabelas DynamoDB da conta."""
        dynamodb = self.get_client('dynamodb')
        response = dynamodb.list_tables()
        return response['TableNames']

================================================================================
üìÑ server/config/initializer.py
================================================================================
# server/initializer.py
"""
M√≥dulo para inicializar ou reinicializar a infraestrutura AWS:
- Cria/recria a tabela DynamoDB 'GlobalArena' com PK/SK.
- Limpa os dados no S3 nos prefixos usados.
- Garante que o bucket S3 exista.

Pode ser executado como script: python server/inicializador.py
"""

from botocore.exceptions import ClientError
from server.integrations.aws_loader import AWSLoader


class InicializadorAWS:
    def __init__(self, aws_loader: AWSLoader):
        self.aws_loader = aws_loader
        self.dynamodb = self.aws_loader.get_client('dynamodb')
        self.s3 = self.aws_loader.get_client('s3')
        self.bucket_name = "global-arena-tiles"
        self.region = aws_loader.region_name

    def inicializar(self, confirmar: bool = True):
        """
        Inicializa ou reinicializa toda a infraestrutura.
        :param confirmar: Se True, pede confirma√ß√£o antes de apagar dados.
        """
        if confirmar:
            resposta = input(
                "‚ö†Ô∏è  Isso apagar√° todos os mundos e metadados no S3 e DynamoDB.\n"
                "Deseja continuar? (s/N): "
            )
            if resposta.lower() not in ['s', 'sim', 'y', 'yes']:
                print("‚ùå Opera√ß√£o cancelada.")
                return False

        print("üîÑ Inicializando infraestrutura AWS...")

        try:
            # 1. Garantir que o bucket S3 existe
            self._criar_bucket_se_nao_existir()

            # 2. Limpar dados no S3
            prefixos = ["planetas/", "saves/"]
            for prefix in prefixos:
                self._limpar_prefixo_s3(prefix)

            # 3. Recriar tabela DynamoDB (√∫nica: GlobalArena)
            self._recriar_tabela_globalarena()

            print("‚úÖ Infraestrutura AWS reinicializada com sucesso!")
            return True

        except Exception as e:
            print(f"‚ùå Erro ao inicializar infraestrutura: {e}")
            return False

    def _criar_bucket_se_nao_existir(self):
        """Cria o bucket S3 se ele n√£o existir."""
        try:
            self.s3.head_bucket(Bucket=self.bucket_name)
            print(f"‚ÑπÔ∏è  Bucket S3 '{self.bucket_name}' j√° existe.")
        except ClientError:
            print(f"üì¶ Criando bucket S3 '{self.bucket_name}'...")
            try:
                if self.region == "us-east-1":
                    self.s3.create_bucket(Bucket=self.bucket_name)
                else:
                    self.s3.create_bucket(
                        Bucket=self.bucket_name,
                        CreateBucketConfiguration={'LocationConstraint': self.region}
                    )
                print(f"‚úÖ Bucket '{self.bucket_name}' criado com sucesso.")
            except ClientError as e:
                print(f"‚ùå Falha ao criar bucket: {e}")
                raise

    def _limpar_prefixo_s3(self, prefix: str):
        """Remove todos os objetos com o prefixo dado no S3."""
        print(f"üßπ Limpando S3: s3://{self.bucket_name}/{prefix}")
        paginator = self.s3.get_paginator('list_objects_v2')
        apagados = 0

        try:
            pages = paginator.paginate(Bucket=self.bucket_name, Prefix=prefix)
            for page in pages:
                if 'Contents' not in page:
                    continue
                keys = [{'Key': obj['Key']} for obj in page['Contents']]
                if keys:
                    self.s3.delete_objects(Bucket=self.bucket_name, Delete={'Objects': keys})
                    apagados += len(keys)
            print(f"‚úÖ {apagados} objetos apagados no prefixo '{prefix}'.")
        except ClientError as e:
            print(f"‚ùå Erro ao limpar S3 no prefixo '{prefix}': {e}")

    def _recriar_tabela_globalarena(self):
        """Deleta e recria a tabela GlobalArena com PK/SK."""
        table_name = "GlobalArena"
        try:
            print(f"üîç Verificando tabela '{table_name}'...")
            self.dynamodb.describe_table(TableName=table_name)
            print(f"üóëÔ∏è  Tabela '{table_name}' encontrada. Deletando...")
            self.dynamodb.delete_table(TableName=table_name)

            # Aguardar exclus√£o
            waiter = self.dynamodb.get_waiter('table_not_exists')
            waiter.wait(TableName=table_name, WaiterConfig={'Delay': 2, 'MaxAttempts': 30})
            print(f"‚úÖ Tabela '{table_name}' deletada.")
        except ClientError as e:
            if e.response['Error']['Code'] != 'ResourceNotFoundException':
                raise e
            print(f"‚ÑπÔ∏è  Tabela '{table_name}' n√£o existe. Ser√° criada.")

        # Criar tabela com PK/SK
        print(f"üÜï Criando tabela '{table_name}' com PK/SK...")
        try:
            self.dynamodb.create_table(
                TableName=table_name,
                AttributeDefinitions=[
                    {'AttributeName': 'PK', 'AttributeType': 'S'},
                    {'AttributeName': 'SK', 'AttributeType': 'S'}
                ],
                KeySchema=[
                    {'AttributeName': 'PK', 'KeyType': 'HASH'},
                    {'AttributeName': 'SK', 'KeyType': 'RANGE'}
                ],
                BillingMode='PAY_PER_REQUEST'
            )

            # Aguardar ativa√ß√£o
            waiter = self.dynamodb.get_waiter('table_exists')
            waiter.wait(TableName=table_name, WaiterConfig={'Delay': 2, 'MaxAttempts': 30})
            print(f"‚úÖ Tabela '{table_name}' criada e ativa.")
        except ClientError as e:
            print(f"‚ùå Falha ao criar tabela '{table_name}': {e}")
            raise


# ========================== CLI ==========================
if __name__ == "__main__":
    """
    Execu√ß√£o direta do m√≥dulo:
    $ python server/inicializador.py
    """
    print("üîß Inicializador AWS - Reinicializa√ß√£o de Infraestrutura\n")

    # Cria o loader AWS
    try:
        aws_loader = AWSLoader()
        print(f"‚úÖ Conectado √† AWS (regi√£o: {aws_loader.region_name})")
    except Exception as e:
        print(f"‚ùå Falha ao conectar √† AWS: {e}")
        exit(1)

    # Inicializa
    inicializador = InicializadorAWS(aws_loader)
    inicializador.inicializar(confirmar=True)

================================================================================
üìÑ server/config/extensions.py
================================================================================
# server/extensions.py
from server.integrations.aws_loader import AWSLoader

class Extensions:
    def __init__(self):
        self.dynamodb = None
        # self.redis = None # Futuro

    def init_app(self, app):
        """Inicializa as extens√µes com base na configura√ß√£o da app Flask."""
        try:
            aws_loader = AWSLoader(
                profile_name=app.config['AWS_PROFILE_NAME'],
                region_name=app.config['AWS_REGION_NAME']
            )
            self.dynamodb = aws_loader.get_client('dynamodb')
            print("‚úÖ Cliente DynamoDB conectado via Extensions.")
        except Exception as e:
            print(f"‚ùå Falha ao conectar ao DynamoDB na inicializa√ß√£o: {e}")
            self.dynamodb = None # Ou lan√ßar exce√ß√£o, dependendo da pol√≠tica de falhas

# Inst√¢ncia global
ext = Extensions()

================================================================================
üìÑ server/config/signals.py
================================================================================
# server/signals.py
from PyQt6.QtCore import QObject, pyqtSignal

class WorkerSignals(QObject):
    """
    Define sinais para comunica√ß√£o segura com a thread da UI.
    Usado pelo Comandante para enviar feedback.
    """
    success = pyqtSignal(object)   # resultado
    error = pyqtSignal(str)        # mensagem de erro
    finished = pyqtSignal()        # opera√ß√£o conclu√≠da

================================================================================
üìÑ server/config/config.py
================================================================================
# server/config.py
import os


class Config:
    # Flask
    SECRET_KEY = os.environ.get(
        'SECRET_KEY') or 'chave_secreta_dev_super_segura'  # Em produ√ß√£o, use vari√°vel de ambiente

    # AWS
    AWS_PROFILE_NAME = os.environ.get('AWS_PROFILE_NAME') or None
    AWS_REGION_NAME = os.environ.get('AWS_REGION_NAME') or 'us-east-2'  # Certifique-se de usar a mesma regi√£o

    # DynamoDB
    DYNAMODB_TABLE_NAME = os.environ.get(
        'DYNAMODB_TABLE_NAME') or 'GlobalArena'  # Ou 'UsuariosGlobalArena' se criar uma nova

    # Futuras configura√ß√µes (ex: Redis, Logging)
    # REDIS_URL = os.environ.get('REDIS_URL') or 'redis://localhost:6379/0'


class DevelopmentConfig(Config):
    DEBUG = True


class ProductionConfig(Config):
    DEBUG = False
    # SECRET_KEY = os.environ.get('SECRET_KEY') # Obrigat√≥rio em produ√ß√£o


config = {
    'development': DevelopmentConfig,
    'production': ProductionConfig,
    'default': DevelopmentConfig
}

================================================================================
üìÑ server/routes/game.py
================================================================================
# server/routes/game.py
from flask import Blueprint, jsonify, request
from server.services.user_service import UserService
from server.services.matchmaking_service import MatchmakingService  # ‚úÖ Usa o servi√ßo de matchmaking


jogo_bp = Blueprint('jogo', __name__, url_prefix='/jogo')

# Vari√°veis para inje√ß√£o de depend√™ncia
_user_service = None
_matchmaking_service = None


def register_jogo_routes(user_service: UserService, matchmaking_service: MatchmakingService):
    """Fun√ß√£o para injetar depend√™ncias no blueprint jogo."""
    global _user_service, _matchmaking_service
    _user_service = user_service
    _matchmaking_service = matchmaking_service


@jogo_bp.route('/entrar', methods=['POST'])
def entrar_na_fila():
    """Adiciona o jogador √† fila de matchmaking online."""
    if not request.is_json:
        return jsonify({"success": False, "message": "JSON esperado"}), 400

    data = request.get_json()
    modo = data.get("modo")
    username = data.get("username")

    if modo != "online":
        return jsonify({"success": False, "message": "Modo inv√°lido. Use 'online'."}), 400

    if not username:
        return jsonify({"success": False, "message": "Username necess√°rio."}), 400

    # ‚úÖ Validar se o usu√°rio existe
    usuario = _user_service.get_user(username)
    if not usuario:
        return jsonify({"success": False, "message": "Usu√°rio n√£o encontrado."}), 404

    # ‚úÖ Tenta entrar na fila
    mensagem = _matchmaking_service.entrar_na_fila(username)
    if "Erro ao entrar na fila" in mensagem:
        return jsonify({"success": False, "message": mensagem}), 409

    # ‚úÖ Encontra a sala onde o jogador foi alocado
    sala_atual = None
    for sala in _matchmaking_service.salas:
        if username in sala.jogadores:
            sala_atual = sala
            break

    if not sala_atual:
        return jsonify({
            "success": False,
            "message": "Erro interno: jogador n√£o encontrado em nenhuma sala."
        }), 500

    # ‚úÖ Total de jogadores em todas as salas ativas
    total_na_fila = sum(len(sala.jogadores) for sala in _matchmaking_service.salas)

    return jsonify({
        "success": True,
        "message": mensagem,
        "modo": modo,
        "total_na_fila": total_na_fila,
        "max_jogadores": sala_atual.vagas  # Limite da sala
    }), 200


@jogo_bp.route('/sair', methods=['POST'])
def sair_da_fila():
    """
    Permite que um jogador saia da fila de matchmaking.
    √ötil quando clica em 'Cancelar' na UI.
    """
    if not request.is_json:
        return jsonify({"success": False, "message": "JSON esperado"}), 400

    data = request.get_json()
    username = data.get("username")

    if not username:
        return jsonify({"success": False, "message": "Username necess√°rio."}), 400

    # ‚úÖ Tenta remover o jogador da fila
    if _matchmaking_service.sair_da_fila(username):
        return jsonify({
            "success": True,
            "message": f"{username} saiu da fila com sucesso."
        }), 200
    else:
        return jsonify({
            "success": False,
            "message": "Voc√™ n√£o estava na fila."
        }), 400

@jogo_bp.route('/limpar_usuario', methods=['POST'])
def limpar_usuario():
    """Remove o jogador de qualquer fila ou sala, mesmo que n√£o esteja na fila."""
    if not request.is_json:
        return jsonify({"success": False, "message": "JSON esperado"}), 400
    data = request.get_json()
    username = data.get("username")
    if not username:
        return jsonify({"success": False, "message": "Username necess√°rio"}), 400

    # Tenta remover da fila (n√£o importa se j√° saiu, s√≥ garante o cleanup)
    _matchmaking_service.sair_da_fila(username)

    return jsonify({"success": True, "message": f"Estado de {username} limpo."}), 200


@jogo_bp.route('/status', methods=['GET'])
def status():
    """Retorna o status do jogador: se est√° na fila ou em partida."""
    username = request.args.get("username")
    if not username:
        return jsonify({"error": "Username necess√°rio"}), 400

    # Verificar se est√° na fila
    em_fila = any(username in sala.jogadores for sala in _matchmaking_service.salas)

    # Verificar se est√° em partida (voc√™ pode ter um servi√ßo de "partidas ativas")
    # Por enquanto, assumimos que se est√° na fila e a partida iniciou, est√° em partida
    em_partida = False
    for sala in _matchmaking_service.salas:
        if username in sala.jogadores and len(sala.jogadores) >= 4:
            em_partida = True
            break

    return jsonify({
        "em_fila": em_fila,
        "em_partida": em_partida,
        "total_na_fila": sum(len(s.jogadores) for s in _matchmaking_service.salas)
    })

================================================================================
üìÑ server/routes/auth.py
================================================================================
# server/routes/auth.py
"""
M√≥dulo de rotas de autentica√ß√£o (login, registro).
Gerencia a inje√ß√£o de depend√™ncia do UserService.
"""
import re
import bcrypt
import unicodedata
from flask import Blueprint, request, jsonify, current_app

# Cria o Blueprint com prefixo
auth_bp = Blueprint('auth', __name__, url_prefix='/auth')

# Vari√°vel global para inje√ß√£o de depend√™ncia
_user_service = None


def normalizar_username(username: str) -> str:
    """
    Normaliza o username: remove acentos, converte para min√∫sculas,
    substitui caracteres especiais por underscores.
    Retorna None se resultar em string vazia.
    """
    if not username:
        return None
    # Remove acentos
    username = unicodedata.normalize('NFKD', username)
    username = ''.join(c for c in username if not unicodedata.combining(c))
    # Substitui n√£o alfanum√©ricos por underscore
    username = re.sub(r'[^a-zA-Z0-9]', '_', username)
    # Min√∫sculas
    username = username.lower()
    # Underscores m√∫ltiplos ‚Üí √∫nico
    username = re.sub(r'_+', '_', username).strip('_')
    return username or None


def register_routes(user_service):
    """
    Fun√ß√£o de inje√ß√£o de depend√™ncia.
    Configura as rotas do auth_bp com o UserService fornecido.
    Deve ser chamada ANTES de registrar o blueprint no app.
    """
    global _user_service
    print(f"üì• DEBUG: Injetando user_service: {user_service}")
    _user_service = user_service

    # Valida se o servi√ßo foi injetado
    if not _user_service:
        print("‚ùå ERRO GRAVE: user_service √© None em register_routes!")
        raise RuntimeError("UserService n√£o injetado em auth_bp.")
    else:
        print(f"‚úÖ DEBUG: _user_service atribu√≠do com sucesso: {_user_service}")


# --- ENDPOINT: Teste de Conex√£o ---
@auth_bp.route('/teste_dynamodb', methods=['GET'])
def teste_dynamodb():
    """Testa a conex√£o com o DynamoDB via UserService."""
    if not _user_service or not _user_service.dynamodb:
        return jsonify({
            "status": "erro",
            "message": "Cliente DynamoDB n√£o dispon√≠vel."
        }), 500

    try:
        response = _user_service.dynamodb.list_tables()
        tabelas = response.get('TableNames', [])
        return jsonify({
            "status": "sucesso",
            "message": "Conex√£o com DynamoDB bem-sucedida.",
            "tabelas": tabelas
        }), 200
    except Exception as e:
        return jsonify({
            "status": "erro",
            "message": f"Falha ao acessar DynamoDB: {str(e)}"
        }), 500


# --- ENDPOINT: Registrar Usu√°rio ---
@auth_bp.route('/registrar', methods=['POST'])
def registrar():
    """
    Registra um novo usu√°rio.
    Expects: {"username": "str", "password": "str"}
    Returns: {"success": bool, "message": str}
    """
    if not request.is_json:
        return jsonify({"success": False, "message": "JSON esperado."}), 400

    data = request.get_json()
    username = data.get('username', '').strip()
    password = data.get('password', '')

    # Validar campos
    if not username or not password:
        return jsonify({"success": False, "message": "Username e senha s√£o obrigat√≥rios."}), 400
    if len(username) < 3:
        return jsonify({"success": False, "message": "Username deve ter pelo menos 3 caracteres."}), 400
    if len(password) < 6:
        return jsonify({"success": False, "message": "Senha deve ter pelo menos 6 caracteres."}), 400

    # Normalizar username (opcional)
    username_normalizado = normalizar_username(username)
    if not username_normalizado:
        return jsonify({"success": False, "message": "Username inv√°lido ap√≥s normaliza√ß√£o."}), 400

    # Verificar se j√° existe (usando o nome original)
    if _user_service.get_user(username):
        return jsonify({"success": False, "message": "Username j√° est√° em uso."}), 409

    # Hashear senha
    try:
        salt = bcrypt.gensalt()
        password_hash = bcrypt.hashpw(password.encode('utf-8'), salt)
    except Exception as e:
        print(f"‚ùå Erro ao hashear senha para '{username}': {e}")
        return jsonify({"success": False, "message": "Erro ao processar senha."}), 500

    # Salvar no DynamoDB
    sucesso = _user_service.create_user_item(username, password_hash=password_hash)
    if sucesso:
        print(f"‚úÖ Usu√°rio '{username}' registrado com sucesso.")
        return jsonify({"success": True, "message": "Usu√°rio registrado com sucesso."}), 201
    else:
        return jsonify({"success": False, "message": "Falha ao salvar no banco."}), 500


# --- ENDPOINT: Login ---
@auth_bp.route('/login', methods=['POST'])
def login():
    """
    Autentica um usu√°rio.
    Expects: {"username": "str", "password": "str"}
    Returns: {"success": bool, "message": str, "token": str (opcional)}
    """
    print("üîç DEBUG: Rota /auth/login foi chamada!")

    # Garantir acesso ao servi√ßo injetado via register_routes
    global _user_service
    if not _user_service:
        print("üí• ERRO: _user_service n√£o foi injetado!")
        return jsonify({
            "success": False,
            "message": "Erro interno do servidor."
        }), 500

    try:
        # 1. Validar formato da requisi√ß√£o
        if not request.is_json:
            print("‚ùå Requisi√ß√£o n√£o √© JSON")
            return jsonify({
                "success": False,
                "message": "JSON esperado."
            }), 400

        data = request.get_json()
        username = data.get('username', '').strip()
        password = data.get('password', '')

        print(f"üîê Tentativa de login - username: {username}")

        # 2. Validar campos obrigat√≥rios
        if not username:
            print("‚ö†Ô∏è Username ausente")
            return jsonify({
                "success": False,
                "message": "Username √© obrigat√≥rio."
            }), 400
        if not password:
            print("‚ö†Ô∏è Senha ausente")
            return jsonify({
                "success": False,
                "message": "Senha √© obrigat√≥ria."
            }), 400

        # 3. Buscar usu√°rio no DynamoDB
        usuario = _user_service.get_user(username)
        if not usuario:
            print(f"‚ùå Credenciais inv√°lidas para '{username}'.")
            return jsonify({
                "success": False,
                "message": "Credenciais inv√°lidas."
            }), 401

        # 4. Extrair e validar hash da senha
        password_hash_attr = usuario.get('password_hash')
        if not password_hash_attr:
            print(f"‚ùå Usu√°rio '{username}' sem password_hash.")
            return jsonify({
                "success": False,
                "message": "Credenciais inv√°lidas."
            }), 401

        # Suporta formato DynamoDB {'B': bytes} ou bytes direto
        stored_hash = password_hash_attr.get('B') if isinstance(password_hash_attr, dict) else password_hash_attr

        if not isinstance(stored_hash, bytes):
            print(f"‚ö†Ô∏è Hash inv√°lido para '{username}': {type(stored_hash)}")
            return jsonify({
                "success": False,
                "message": "Credenciais inv√°lidas."
            }), 401

        # 5. Verificar senha com bcrypt
        if bcrypt.checkpw(password.encode('utf-8'), stored_hash):
            print(f"‚úÖ Login bem-sucedido para '{username}'.")

            # üîê Gera um token fake para compatibilidade com o simulador
            # (Futuro: substituir por JWT real)
            fake_token = f"fake-jwt-{username}-{hash(username) % 10000}"

            return jsonify({
                "success": True,
                "message": "Login bem-sucedido.",
                "token": fake_token  # ‚Üê Adicionado para o simulador usar
            }), 200
        else:
            print(f"‚ùå Senha incorreta para '{username}'.")
            return jsonify({
                "success": False,
                "message": "Credenciais inv√°lidas."
            }), 401

    except Exception as e:
        print(f"üí• ERRO N√ÉO TRATADO em /auth/login: {type(e).__name__}: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({
            "success": False,
            "message": "Erro interno no servidor."
        }), 500

================================================================================
üìÑ server/core/commander.py
================================================================================
# server/commander.py
import queue
import threading
import time
import uuid
import random
from typing import Callable, Optional
from server.config.signals import WorkerSignals
from server.core.manager import Gerenciador
from server.config.initializer import InicializadorAWS


class Comando:
    def __init__(
        self,
        nome: str,
        callback: Callable,
        args=None,
        kwargs=None,
        on_success: Callable = None,
        on_error: Callable = None,
        signals: Optional[WorkerSignals] = None  # ‚úÖ Novo: sinais PyQt6
    ):
        self.id = str(uuid.uuid4())[:8]
        self.nome = nome
        self.callback = callback
        self.args = args or ()
        self.kwargs = kwargs or {}
        self.on_success = on_success  # ‚ö†Ô∏è Evite UI aqui
        self.on_error = on_error      # ‚ö†Ô∏è Evite UI aqui
        self.signals = signals        # ‚úÖ Use para UI segura
        self.timestamp = time.time()

    def __repr__(self):
        return f"<Comando(id={self.id}, nome='{self.nome}')>"


class Comandante:
    """
    Orquestrador de opera√ß√µes de dom√≠nio.
    Deve ser usado pela interface gr√°fica para disparar a√ß√µes ass√≠ncronas.
    Nunca deve conter l√≥gica de UI.
    """
    def __init__(self, gerenciador: Gerenciador, aws_loader):
        self.gerenciador = gerenciador
        self.aws_loader = aws_loader
        self.fila = queue.Queue()
        self.ativo = True
        self.thread = threading.Thread(target=self._loop, daemon=True)
        # üîÅ Estado da simula√ß√£o
        self.simulacao_ativa = False
        self.thread_simulacao: Optional[threading.Thread] = None

    def iniciar(self):
        """Inicia a thread de processamento de comandos."""
        self.thread.start()
        print("‚úÖ Comandante iniciado. Pronto para executar comandos.")

    def parar(self, timeout: float = 2.0):
        """Para o loop de comandos de forma segura."""
        self.ativo = False
        while not self.fila.empty():
            try:
                self.fila.get_nowait()
            except queue.Empty:
                break
        self.thread.join(timeout=timeout)
        if self.thread.is_alive():
            print("‚ö†Ô∏è Thread do Comandante n√£o encerrou a tempo.")
        else:
            print("üõë Comandante parado com sucesso.")

    def _loop(self):
        """Loop principal: executa comandos da fila."""
        while self.ativo:
            try:
                comando = self.fila.get(timeout=0.2)
                print(f"‚öôÔ∏è Executando [{comando.id}]: {comando.nome}")
                try:
                    resultado = comando.callback(*comando.args, **comando.kwargs)
                    print(f"‚úÖ [{comando.id}] {comando.nome} conclu√≠do.")

                    # ‚úÖ Primeiro: emitir sinais (seguro para UI)
                    if comando.signals:
                        comando.signals.success.emit(resultado)
                        comando.signals.finished.emit()

                    # ‚ö†Ô∏è Segundo: callbacks (cuidado! est√£o na thread secund√°ria)
                    if comando.on_success:
                        try:
                            comando.on_success(resultado)
                        except Exception as cb_e:
                            print(f"‚ö†Ô∏è Erro no callback on_success: {cb_e}")

                except Exception as e:
                    print(f"‚ùå [{comando.id}] Erro em '{comando.nome}': {e}")

                    # ‚úÖ Sinais de erro
                    if comando.signals:
                        comando.signals.error.emit(str(e))
                        comando.signals.finished.emit()

                    # ‚ö†Ô∏è Callbacks de erro
                    if comando.on_error:
                        try:
                            comando.on_error(str(e))
                        except Exception as cb_e:
                            print(f"‚ö†Ô∏è Erro no callback on_error: {cb_e}")

                finally:
                    self.fila.task_done()

            except queue.Empty:
                continue

    def _enviar_comando(self, nome: str, callback: Callable, *args, **kwargs):
        """
        M√©todo auxiliar para criar e enviar um comando.
        Aceita on_success, on_error e signals nos kwargs.
        """
        on_success = kwargs.pop('on_success', None)
        on_error = kwargs.pop('on_error', None)
        signals = kwargs.pop('signals', None)  # ‚úÖ Extrai os sinais

        comando = Comando(
            nome=nome,
            callback=callback,
            args=args,
            kwargs=kwargs,
            on_success=on_success,
            on_error=on_error,
            signals=signals  # ‚úÖ Passa os sinais
        )
        self.fila.put(comando)

    # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
    # Comandos de Dom√≠nio
    # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

    def criar_e_upload_mundo(
        self,
        fator: int,
        bioma: str,
        bucket_name: str = "global-arena-tiles",
        s3_prefix: str = "planetas/",
        dynamodb_table_name: str = "GlobalArena",
        on_success: Callable = None,
        on_error: Callable = None,
        signals: Optional[WorkerSignals] = None  # ‚úÖ Novo par√¢metro
    ):
        """Comando: cria e faz upload de um novo mundo."""
        def task():
            sucesso, mundo = self.gerenciador.criar_e_upload_mundo_com_retorno(
                fator=fator,
                bioma=bioma,
                bucket_name=bucket_name,
                s3_prefix=s3_prefix,
                dynamodb_table_name=dynamodb_table_name
            )
            return sucesso, mundo

        self._enviar_comando(
            nome=f"Criar e Upload Mundo (fator={fator}, bioma={bioma})",
            callback=task,
            on_success=on_success,
            on_error=on_error,
            signals=signals  # ‚úÖ Passa os sinais
        )

    def reinicializar_infra(
        self,
        confirmar: bool = False,
        on_success: Callable = None,
        on_error: Callable = None,
        signals: Optional[WorkerSignals] = None  # ‚úÖ Novo par√¢metro
    ):
        """Comando: reinicializa a infra AWS (S3 + DynamoDB)."""
        def task():
            inicializador = InicializadorAWS(self.aws_loader)
            sucesso = inicializador.inicializar(confirmar=confirmar)
            return sucesso

        self._enviar_comando(
            nome="Reinicializar Infra AWS",
            callback=task,
            on_success=on_success,
            on_error=on_error,
            signals=signals  # ‚úÖ Passa os sinais
        )

    def testar_conexao_aws(
        self,
        on_success: Callable = None,
        on_error: Callable = None,
        signals: Optional[WorkerSignals] = None  # ‚úÖ Novo par√¢metro
    ):
        """Comando: testa conex√£o com AWS (conta, S3, DynamoDB)."""
        def task():
            try:
                account = self.aws_loader.get_account_info()
                buckets = self.aws_loader.list_s3_buckets()
                tables = self.aws_loader.list_dynamodb_tables()
                return {
                    'success': True,
                    'account': account,
                    'buckets': buckets,
                    'tables': tables
                }
            except Exception as e:
                raise e

        self._enviar_comando(
            nome="Testar Conex√£o AWS",
            callback=task,
            on_success=on_success,
            on_error=on_error,
            signals=signals  # ‚úÖ Passa os sinais
        )

    def iniciar_simulacao_players(self, signals: Optional[WorkerSignals] = None):
        """Inicia a simula√ß√£o de players online."""
        def task():
            if self.simulacao_ativa:
                return

            self.simulacao_ativa = True
            contador = 0

            def entrar_na_fila(usuario):
                nonlocal contador
                try:
                    import requests
                    print(f"üîÑ [Comandante] Tentando login com: {usuario['username']}")  # ‚Üê Novo log
                    response = requests.post("http://localhost:5000/auth/login", json=usuario)
                    if response.status_code == 200:
                        token = response.json().get("token")
                        headers = {"Authorization": f"Bearer {token}"} if token else {}
                        print(f"üîÑ [Comandante] {usuario['username']} logado. Tentando entrar na fila...")  # ‚Üê Novo log

                        # Chamada para /jogo/entrar
                        response_entrar = requests.post(
                            "http://localhost:5000/jogo/entrar",
                            json={"modo": "online", "username": usuario["username"]},
                            headers=headers
                        )

                        # ‚úÖ Log da resposta
                        print(
                            f"üì® Resposta de /jogo/entrar para {usuario['username']}: {response_entrar.status_code} - {response_entrar.text}")

                        if response_entrar.status_code == 200:
                            contador += 1
                            if signals:
                                signals.success.emit(f"‚úÖ {usuario['username']} entrou na fila ({contador})")
                        else:
                            print(f"‚ùå Falha ao entrar na fila: {response_entrar.text}")
                    else:
                        print(f"‚ùå Login falhou para {usuario['username']}: {response.text}")

                except Exception as e:
                    print(f"‚ùå Erro ao processar {usuario['username']}: {e}")
                    if signals:
                        signals.error.emit(f"‚ùå Falha com {usuario['username']}")

            USUARIOS_SIMULADOS = [{"username": f"player{i:03d}", "password": "senha123"} for i in range(1, 51)]

            while self.simulacao_ativa:
                usuario = random.choice(USUARIOS_SIMULADOS)
                thread = threading.Thread(target=entrar_na_fila, args=(usuario,), daemon=True)
                thread.start()
                time.sleep(random.uniform(1.0, 3.0))

            if signals:
                signals.success.emit("üõë Simula√ß√£o encerrada.")

        self._enviar_comando(
            nome="Simular Players Online",
            callback=task,
            on_success=lambda msg: signals.success.emit(msg) if signals else None,
            on_error=lambda err: signals.error.emit(err) if signals else None,
            signals=signals
        )

    def parar_simulacao_players(self):
        """Para a simula√ß√£o de players."""
        self.simulacao_ativa = False

================================================================================
üìÑ server/core/simulador_players.py
================================================================================
# server/simulador_players.py
import requests
import random
import time
import threading

# Configura√ß√£o
URL_BASE = "http://localhost:5000"
NUM_PLAYERS = 50  # Quantidade de players simulados: player001 at√© player050

# Gera usu√°rios dinamicamente
USUARIOS_SIMULADOS = [{"username": f"player{i:03d}", "password": "senha123"} for i in range(1, 51)]
print("üéØ Simulador carregado com formatos: player001, player002, ...")

def registrar_usuario(usuario):
    """Tenta registrar o usu√°rio no servidor."""
    try:
        response = requests.post(f"{URL_BASE}/auth/registrar", json=usuario, timeout=3)
        data = response.json()
        if data.get("success"):
            print(f"üÜï Registrado: {usuario['username']}")
            return True
        else:
            # Pode j√° existir ‚Üí n√£o √© erro
            if "j√° est√° em uso" in data.get("message", ""):
                return True
            print(f"‚ùå Falha ao registrar {usuario['username']}: {data.get('message')}")
            return False
    except Exception as e:
        print(f"‚ö†Ô∏è Erro ao registrar {usuario['username']}: {e}")
        return False

def login_usuario(usuario):
    """Tenta fazer login. Se falhar por usu√°rio n√£o encontrado, tenta registrar."""
    try:
        response = requests.post(f"{URL_BASE}/auth/login", json=usuario, timeout=3)
        data = response.json()

        if data.get("success"):
            print(f"‚úÖ {usuario['username']} logou com sucesso.")
            return data.get("token")  # futuro: JWT
        else:
            mensagem = data.get("message", "")
            if "n√£o encontrado" in mensagem:
                print(f"üîÅ {usuario['username']} n√£o existe. Tentando registrar...")
                if registrar_usuario(usuario):
                    return login_usuario(usuario)  # Tenta logar novamente ap√≥s registrar
            else:
                print(f"‚ùå {usuario['username']} falhou: {mensagem}")
        return None
    except requests.exceptions.ConnectionError:
        print("üõë Erro: N√£o foi poss√≠vel conectar ao servidor. Certifique-se de que o servidor est√° rodando em http://localhost:5000")
        return None
    except Exception as e:
        print(f"‚ö†Ô∏è Erro inesperado ao logar {usuario['username']}: {e}")
        return None

def entrar_na_fila(usuario):
    """Ap√≥s login, entra na fila de jogo online."""
    token = login_usuario(usuario)
    if not token:
        return

    headers = {"Authorization": f"Bearer {token}"} if token else {}
    try:
        response = requests.post(
            f"{URL_BASE}/jogo/entrar",
            json={"modo": "online", "username": usuario["username"]},
            headers=headers,
            timeout=3
        )
        data = response.json()
        print(f"üéÆ {usuario['username']} ‚Üí {data.get('message')}")
    except Exception as e:
        print(f"‚ö†Ô∏è Falha ao entrar na fila: {e}")

def simular_entrada_periodica(intervalo_min=2, intervalo_max=5):
    """
    Simula entrada peri√≥dica e aleat√≥ria de players no sistema.
    Cada player tenta:
    1. Logar (ou se registrar, se necess√°rio)
    2. Entrar na fila de matchmaking
    """
    print(f"üîÑ Iniciando simula√ß√£o com {len(USUARIOS_SIMULADOS)} players...")
    print(f"üí° Intervalo: {intervalo_min}s a {intervalo_max}s entre tentativas")
    print("‚ÑπÔ∏è  Pressione Ctrl+C para parar.")

    while True:
        usuario = random.choice(USUARIOS_SIMULADOS)
        thread = threading.Thread(target=entrar_na_fila, args=(usuario,), daemon=True)
        thread.start()
        time.sleep(random.uniform(intervalo_min, intervalo_max))

if __name__ == "__main__":
    print("üöÄ Iniciando simulador de players online...")
    try:
        simular_entrada_periodica(intervalo_min=1.5, intervalo_max=4.0)
    except KeyboardInterrupt:
        print("\nüõë Simula√ß√£o encerrada pelo usu√°rio.")
    except Exception as e:
        print(f"\n‚ùå Erro inesperado: {e}")

================================================================================
üìÑ server/core/registrar_players.py
================================================================================
# server/registrar_players.py
import requests

# Lista de players a serem registrados
USUARIOS = [
    {"username": f"player{i:03d}", "password": "senha123"} for i in range(1, 51)
]

print("üìù Registrando 50 players de teste...")

for usuario in USUARIOS:
    response = requests.post("http://localhost:5000/auth/registrar", json=usuario)
    data = response.json()
    if data.get("success"):
        print(f"‚úÖ {usuario['username']} registrado com sucesso.")
    else:
        # Pode j√° existir ‚Üí n√£o √© erro
        if "j√° existe" in data.get("message", ""):
            print(f"üîÅ {usuario['username']} j√° registrado.")
        else:
            print(f"‚ùå Falha ao registrar {usuario['username']}: {data['message']}")

================================================================================
üìÑ server/core/manager.py
================================================================================
# server/manager.py
import json
import time
from pathlib import Path
from typing import Optional, Tuple

from server.serialization import Serializador
from server.integrations.aws_loader import AWSLoader
from shared.world import Mundo


class Gerenciador:
    """
    Gerencia opera√ß√µes de mundo: cria√ß√£o, serializa√ß√£o, upload S3 e salvamento de metadados no DynamoDB.
    Nada √© salvo localmente.
    """

    def __init__(self,
                 aws_loader: AWSLoader,
                 save_dir: str = "saves",
                 dynamodb_table_name: str = "GlobalArena"):  # ‚úÖ Adicione o par√¢metro
        self.aws_loader = aws_loader
        self.save_dir = Path(save_dir)
        self.save_dir.mkdir(exist_ok=True)
        self.dynamodb_table_name = dynamodb_table_name  # ‚úÖ Armazena o nome da tabela

    # server/manager.py

    def upload_mundo(self,
                     mundo: Mundo,
                     bucket_name: str = "global-arena-tiles",
                     s3_prefix: str = "planetas/",
                     dynamodb_table_name: str = "GlobalArena") -> bool:
        """
        Faz upload do mundo: dados pesados para S3, metadados leves para DynamoDB.
        Agora com rollback se falhar no DynamoDB.
        """
        try:
            pk = f"PLANET#{mundo.id_mundo}"
            sk = "METADATA"
            s3_key = f"{s3_prefix}{mundo.id_mundo}.json"

            # --- Verificar se j√° existe no DynamoDB ---
            dynamodb = self.aws_loader.get_client('dynamodb')
            response = dynamodb.get_item(
                TableName=dynamodb_table_name,
                Key={'PK': {'S': pk}, 'SK': {'S': sk}}
            )
            if 'Item' in response:
                print(f"‚ùå Mundo com ID {mundo.id_mundo} j√° existe no DynamoDB.")
                return False

            # --- Serializar e enviar para S3 ---
            dados_s3 = Serializador.to_serializable_dict(mundo)
            dados_json = json.dumps(dados_s3, ensure_ascii=False, indent=2)

            s3 = self.aws_loader.get_client('s3')
            s3.put_object(
                Bucket=bucket_name,
                Key=s3_key,
                Body=dados_json,
                ContentType='application/json'
            )
            print(f"‚úÖ Upload para S3 conclu√≠do: s3://{bucket_name}/{s3_key}")

            # --- Salvar metadados no DynamoDB ---
            try:
                bioma_inicial = getattr(mundo.planeta, 'bioma_inicial', 'Desconhecido')
                vagas = getattr(mundo.planeta, 'numero_de_jogadores', 0)

                dynamodb.put_item(
                    TableName=dynamodb_table_name,
                    Item={
                        'PK': {'S': pk},
                        'SK': {'S': sk},
                        'entityType': {'S': 'Planet'},
                        'fator': {'N': str(mundo.planeta.fator)},
                        'bioma_inicial': {'S': bioma_inicial},
                        'vagas': {'N': str(vagas)},
                        'timestamp': {'N': str(int(time.time()))}
                    }
                )
                print(f"‚úÖ Metadados do mundo {mundo.id_mundo} salvos no DynamoDB.")
                return True

            except Exception as e:
                print(f"‚ùå Falha ao salvar no DynamoDB: {e}")
                print(f"üßπ Removendo arquivo √≥rf√£o do S3: s3://{bucket_name}/{s3_key}")
                try:
                    s3.delete_object(Bucket=bucket_name, Key=s3_key)
                    print("‚úÖ Arquivo √≥rf√£o removido com sucesso.")
                except Exception as del_e:
                    print(f"‚ö†Ô∏è Falha ao remover arquivo √≥rf√£o do S3: {del_e}")
                return False

        except Exception as e:
            print(f"‚ùå Erro inesperado durante upload_mundo: {e}")
            return False

    def criar_e_upload_mundo(
        self,
        fator: int,
        bioma: str,
        bucket_name: str = "global-arena-tiles",
        s3_prefix: str = "planetas/"
    ) -> bool:
        """
        Cria um novo mundo com fator e bioma dados, e faz upload direto para S3 + DynamoDB.

        :param fator: N√≠vel de detalhe da grade geogr√°fica (ex: 4)
        :param bioma: Bioma inicial para escolha de capitais (ex: "Meadow")
        :param bucket_name: Nome do bucket S3
        :param s3_prefix: Prefixo (pasta) no bucket
        :return: True se sucesso, False caso contr√°rio
        """
        try:
            print(f"üåç Criando mundo com fator={fator}, bioma='{bioma}'...")
            mundo = Mundo(fator=fator, bioma=bioma)
            print(f"‚úÖ Mundo criado: {mundo.id_mundo}")

            sucesso = self.upload_mundo(mundo, bucket_name=bucket_name, s3_prefix=s3_prefix)

            if sucesso:
                print(f"üéâ Mundo {mundo.id_mundo} enviado com sucesso para a nuvem!")
            else:
                print(f"‚ùå Falha no upload do mundo {mundo.id_mundo}")

            return sucesso

        except Exception as e:
            print(f"‚ùå Erro ao criar e upload mundo: {e}")
            return False

    def criar_e_upload_mundo_com_retorno(
            self,
            fator: int,
            bioma: str,
            bucket_name: str = "global-arena-tiles",
            s3_prefix: str = "planetas/",
            dynamodb_table_name: str = "GlobalArena"
    ) -> Tuple[bool, Optional[Mundo]]:
        """
        Cria um novo mundo com fator e bioma dados, faz upload para S3 + DynamoDB,
        e retorna sucesso e a inst√¢ncia do mundo.
        """
        try:
            print(f"üåç Criando mundo com fator={fator}, bioma='{bioma}'...")
            mundo = Mundo(fator=fator, bioma=bioma)
            print(f"‚úÖ Mundo criado: {mundo.id_mundo}")

            sucesso = self.upload_mundo(
                mundo,
                bucket_name=bucket_name,
                s3_prefix=s3_prefix,
                dynamodb_table_name=dynamodb_table_name
            )

            if sucesso:
                print(f"üéâ Mundo {mundo.id_mundo} enviado com sucesso para a nuvem!")
            else:
                print(f"‚ùå Falha no upload do mundo {mundo.id_mundo}")

            return sucesso, mundo

        except Exception as e:
            print(f"‚ùå Erro ao criar e upload mundo: {e}")
            import traceback
            traceback.print_exc()
            return False, None

    def criar_mundo(self, fator: int, bioma: str) -> Mundo:
        """Cria e retorna um novo mundo."""
        return Mundo(fator=fator, bioma=bioma)

================================================================================
üìÑ server/core/interface.py
================================================================================
# server/interface.py
import sys
from PyQt6.QtWidgets import (
    QApplication, QMainWindow, QTabWidget, QWidget, QVBoxLayout,
    QComboBox, QSpinBox, QMessageBox, QFormLayout, QGroupBox,
    QFileDialog, QTextEdit, QPushButton
)
from server.config.signals import WorkerSignals
from server.serialization import Serializador
from server.core.manager import Gerenciador
from server.integrations.aws_loader import AWSLoader
from server.core.commander import Comandante


class Interface(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Gerenciador de Servidor - Global Arena")
        self.setGeometry(100, 100, 700, 500)

        # === Inicializa√ß√£o de depend√™ncias ===
        try:
            self.aws_loader = AWSLoader()
            self.gerenciador = Gerenciador(self.aws_loader)
            print("‚úÖ Gerenciador inicializado com AWS.")
        except Exception as e:
            QMessageBox.critical(self, "Erro AWS", f"N√£o foi poss√≠vel conectar √† AWS:\n{e}")
            self.gerenciador = None

        # ‚úÖ Inicializa o Comandante
        try:
            self.comandante = Comandante(self.gerenciador, self.aws_loader)
            self.comandante.iniciar()
            print("‚úÖ Comandante iniciado.")
        except Exception as e:
            QMessageBox.critical(self, "Erro", f"Falha ao iniciar o Comandante:\n{e}")
            self.comandante = None

        # ‚úÖ Cria e conecta os sinais
        self.setup_signals()

        # ‚úÖ Armazena o √∫ltimo mundo criado
        self.ultimo_mundo = None

        # Configura√ß√£o do sistema de abas
        self.tabs = QTabWidget()
        self.setCentralWidget(self.tabs)

        # ‚úÖ Cria as abas
        self.backup_tab = self.create_backup_tab()
        self.config_tab = QWidget()
        self.tabs.addTab(self.backup_tab, "Backup & Cria√ß√£o")
        self.tabs.addTab(self.config_tab, "Configura√ß√µes")

    def closeEvent(self, event):
        if self.comandante:
            self.comandante.parar()
        event.accept()

    def setup_signals(self):
        """Cria e conecta os sinais para comunica√ß√£o segura."""
        self.signals = WorkerSignals()
        self.signals.success.connect(self.on_success)
        self.signals.error.connect(self.on_error)
        self.signals.finished.connect(self.on_finished)

    def on_success(self, resultado):
        """Trata diferentes tipos de sucesso: cria√ß√£o de mundo ou mensagens de log."""
        if isinstance(resultado, tuple):
            # Caso 1: resultado de upload de mundo (sucesso, mundo)
            try:
                sucesso, mundo = resultado
                if sucesso:
                    self.ultimo_mundo = mundo
                    QMessageBox.information(
                        self, "Sucesso", f"Mundo {mundo.id_mundo} criado e enviado!"
                    )
                else:
                    QMessageBox.critical(self, "Falha", "Upload falhou.")
            except Exception as e:
                print(f"‚ùå Erro ao processar resultado de upload: {e}")
        else:
            # Caso 2: mensagem de log (ex: simula√ß√£o de players)
            self.log_output.append(f"üü¢ {resultado}")  # Exibe no widget de log
            print(f"üü¢ {resultado}")  # Tamb√©m imprime no terminal

    def on_error(self, mensagem: str):
        QMessageBox.critical(self, "Erro", f"Falha: {mensagem}")

    def on_finished(self):
        print("‚úÖ Opera√ß√£o conclu√≠da.")

    # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
    # M√©todos para constru√ß√£o da UI
    # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

    def create_backup_tab(self):
        """Cria a aba de opera√ß√µes de backup e cria√ß√£o de mundos"""
        tab = QWidget()
        layout = QVBoxLayout()

        # === Grupo: Criar e Upload de Mundo ===
        group_criar = QGroupBox("Criar e Enviar Novo Mundo")
        form_layout = QFormLayout()

        self.spin_fator = QSpinBox()
        self.spin_fator.setMinimum(2)
        self.spin_fator.setMaximum(8)
        self.spin_fator.setValue(4)
        form_layout.addRow("Fator:", self.spin_fator)

        self.combo_bioma = QComboBox()
        biomas = ["Meadow", "Forest", "Savanna", "Desert", "Hills", "Mountains"]
        self.combo_bioma.addItems(biomas)
        self.combo_bioma.setCurrentText("Meadow")
        form_layout.addRow("Bioma Inicial:", self.combo_bioma)

        group_criar.setLayout(form_layout)
        layout.addWidget(group_criar)

        btn_upload = QPushButton("üåç Criar e Enviar Mundo para Nuvem")
        btn_upload.clicked.connect(self.handle_criar_e_upload)
        layout.addWidget(btn_upload)

        layout.addSpacing(20)

        # === Grupo: Simula√ß√£o de Players ===
        group_sim = QGroupBox("Simula√ß√£o de Players Online")
        layout_sim = QVBoxLayout()

        btn_iniciar_sim = QPushButton("‚ñ∂Ô∏è Iniciar Simula√ß√£o de Players")
        btn_iniciar_sim.setStyleSheet("""
            QPushButton { background-color: #27ae60; color: white; font-weight: bold; border-radius: 6px; padding: 8px; }
            QPushButton:hover { background-color: #2ecc71; }
        """)
        btn_iniciar_sim.clicked.connect(self.handle_iniciar_simulacao)
        layout_sim.addWidget(btn_iniciar_sim)

        btn_parar_sim = QPushButton("‚èπÔ∏è Parar Simula√ß√£o de Players")
        btn_parar_sim.setStyleSheet("""
            QPushButton { background-color: #e74c3c; color: white; font-weight: bold; border-radius: 6px; padding: 8px; }
            QPushButton:hover { background-color: #c0392b; }
        """)
        btn_parar_sim.clicked.connect(self.handle_parar_simulacao)
        layout_sim.addWidget(btn_parar_sim)

        group_sim.setLayout(layout_sim)
        layout.addWidget(group_sim)

        layout.addSpacing(20)

        # === Grupo: Salvar Localmente ===
        group_local = QGroupBox("Salvar Estado Localmente")
        layout_local = QVBoxLayout()

        btn_save = QPushButton("üíæ Salvar Estado como JSON (Local)")
        btn_save.clicked.connect(self.handle_save_json)
        layout_local.addWidget(btn_save)

        group_local.setLayout(layout_local)
        layout.addWidget(group_local)

        layout.addSpacing(20)

        # === Bot√£o: Reinicializar Infraestrutura AWS ===
        btn_reiniciar = QPushButton("‚ö†Ô∏è Reinicializar Infraestrutura AWS")
        btn_reiniciar.setStyleSheet("""
            QPushButton {
                background-color: #a83232;
                color: white;
                font-weight: bold;
                border-radius: 6px;
                padding: 8px;
            }
            QPushButton:hover {
                background-color: #c03939;
            }
        """)
        btn_reiniciar.clicked.connect(self.handle_reinicializar_servidor)
        layout.addWidget(btn_reiniciar)
        layout.addSpacing(10)

        # === Log de Atividades ===
        self.log_output = QTextEdit()
        self.log_output.setReadOnly(True)
        self.log_output.setMaximumHeight(150)
        self.log_output.setPlaceholderText("Log de atividades...")
        layout.addWidget(self.log_output)

        layout.addStretch()
        tab.setLayout(layout)
        return tab

    def handle_iniciar_simulacao(self):
        """Inicia a simula√ß√£o de players online."""
        if not self.comandante:
            QMessageBox.critical(self, "Erro", "Comandante n√£o est√° dispon√≠vel.")
            return
        self.comandante.iniciar_simulacao_players(signals=self.signals)

    def handle_parar_simulacao(self):
        """Para a simula√ß√£o de players online."""
        if not self.comandante:
            return
        self.comandante.parar_simulacao_players()
        self.signals.success.emit("üõë Simula√ß√£o interrompida pelo usu√°rio.")

    def handle_save_json(self):
        """Salva o √∫ltimo mundo criado (se existir) como JSON local."""
        if not self.ultimo_mundo:
            QMessageBox.warning(self, "Aviso", "Nenhum mundo foi criado ainda.")
            return

        try:
            mundo = self.ultimo_mundo
            filepath, _ = QFileDialog.getSaveFileName(
                self,
                "Salvar Mundo como JSON",
                f"saves/mundo_{mundo.id_mundo}.json",
                "JSON Files (*.json)"
            )
            if not filepath:
                return  # Cancelado

            caminho_salvo = Serializador.save_mundo(mundo, filepath)
            if caminho_salvo:
                QMessageBox.information(
                    self, "Sucesso", f"Mundo salvo localmente:\n{caminho_salvo}"
                )
            else:
                QMessageBox.critical(self, "Falha", "Erro ao salvar o arquivo.")
        except Exception as e:
            QMessageBox.critical(self, "Erro", f"Falha ao salvar: {str(e)}")

    def handle_criar_e_upload(self):
        if not self.comandante:
            QMessageBox.critical(self, "Erro", "Comandante n√£o est√° dispon√≠vel.")
            return

        fator = self.spin_fator.value()
        bioma = self.combo_bioma.currentText()

        self.comandante.criar_e_upload_mundo(
            fator=fator,
            bioma=bioma,
            signals=self.signals
        )

    def handle_reinicializar_servidor(self):
        if not self.comandante:
            QMessageBox.critical(self, "Erro", "Comandante n√£o est√° dispon√≠vel.")
            return

        reply = QMessageBox.question(
            self,
            "‚ö†Ô∏è Reinicializar Infraestrutura",
            "Isso apagar√° TODOS os mundos e metadados no S3 e DynamoDB.\n"
            "Continuar?",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
        )
        if reply != QMessageBox.StandardButton.Yes:
            return

        self.comandante.reinicializar_infra(
            confirmar=False,
            signals=self.signals
        )


# Execu√ß√£o da aplica√ß√£o
if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = Interface()
    window.show()
    sys.exit(app.exec())

================================================================================
üìÑ client/main.py
================================================================================
# client/main.py

import sys
import os  # Para verificar o arquivo de sess√£o
import OpenGL.GL as gl
import ctypes

import requests
from PyQt6.QtWidgets import (
    QApplication, QMainWindow, QWidget, QVBoxLayout, QLabel, QPushButton, QHBoxLayout,
    QSizePolicy, QFrame, QMessageBox, QDialog, QFormLayout, QLineEdit, QDialogButtonBox
)
from PyQt6.QtOpenGLWidgets import QOpenGLWidget
from PyQt6.QtCore import QTimer, Qt
from PyQt6.QtGui import QSurfaceFormat, QFont
from client.components.icon_manager import GerenciadorIconesEsquerda
from client.dialogs.auth_dialog import DialogoAutenticacao
from client.widgets.waiting_room_overlay import WaitingRoomOverlay
from client.widgets.game_placeholder import GamePlaceholder

# --- Componente OpenGL ---
class MeuOpenGLWidget(QOpenGLWidget):
    """
    Widget respons√°vel pela renderiza√ß√£o OpenGL Moderna.
    """

    def __init__(self):
        super().__init__()
        self.shader_program = None
        self.VAO = None
        self.VBO = None
        # Permitir que o widget receba foco de teclado
        self.setFocusPolicy(Qt.FocusPolicy.StrongFocus)

    def initializeGL(self):
        """
        Inicializado uma vez quando o contexto OpenGL √© criado.
        Aqui compilamos shaders, criamos VAOs, VBOs etc.
        """
        print("Inicializando contexto OpenGL...")
        # Define a cor de fundo padr√£o como PRETO PURO
        gl.glClearColor(0.0, 0.0, 0.0, 1.0)

        # --- Compilar Shaders para o Tri√¢ngulo ---
        vertex_shader_source = """
        #version 330 core
        layout (location = 0) in vec3 aPos;
        layout (location = 1) in vec3 aColor;
        out vec3 ourColor;
        void main()
        {
            gl_Position = vec4(aPos, 1.0);
            ourColor = aColor;
        }
        """

        fragment_shader_source = """
        #version 330 core
        in vec3 ourColor;
        out vec4 FragColor;
        void main()
        {
            FragColor = vec4(ourColor, 1.0f);
        }
        """

        # --- Compila√ß√£o e Linkagem de Shaders ---
        try:
            # Compila√ß√£o do Vertex Shader
            vertex_shader = gl.glCreateShader(gl.GL_VERTEX_SHADER)
            gl.glShaderSource(vertex_shader, vertex_shader_source)
            gl.glCompileShader(vertex_shader)
            # Verifica√ß√£o de erros no vertex shader
            success = gl.glGetShaderiv(vertex_shader, gl.GL_COMPILE_STATUS)
            if not success:
                info_log = gl.glGetShaderInfoLog(vertex_shader)
                raise RuntimeError(f"Erro ao compilar Vertex Shader:\n{info_log.decode('utf-8')}")

            # Compila√ß√£o do Fragment Shader
            fragment_shader = gl.glCreateShader(gl.GL_FRAGMENT_SHADER)
            gl.glShaderSource(fragment_shader, fragment_shader_source)
            gl.glCompileShader(fragment_shader)
            # Verifica√ß√£o de erros no fragment shader
            success = gl.glGetShaderiv(fragment_shader, gl.GL_COMPILE_STATUS)
            if not success:
                info_log = gl.glGetShaderInfoLog(fragment_shader)
                raise RuntimeError(f"Erro ao compilar Fragment Shader:\n{info_log.decode('utf-8')}")

            # Linkagem do Programa Shader
            self.shader_program = gl.glCreateProgram()
            gl.glAttachShader(self.shader_program, vertex_shader)
            gl.glAttachShader(self.shader_program, fragment_shader)
            gl.glLinkProgram(self.shader_program)
            # Verifica√ß√£o de erros no link
            success = gl.glGetProgramiv(self.shader_program, gl.GL_LINK_STATUS)
            if not success:
                info_log = gl.glGetProgramInfoLog(self.shader_program)
                raise RuntimeError(f"Erro ao linkar Programa Shader:\n{info_log.decode('utf-8')}")

            # Deletar os shaders j√° linkados
            gl.glDeleteShader(vertex_shader)
            gl.glDeleteShader(fragment_shader)

        except RuntimeError as e:
            print(f"‚ùå Erro na inicializa√ß√£o dos shaders: {e}")
            self.shader_program = None  # Indica falha
            return  # Aborta a inicializa√ß√£o da geometria se shaders falharem

        # --- Configurar VAO e VBO para um tri√¢ngulo ---
        try:
            # Dados do tri√¢ngulo (Posi√ß√£o XYZ + Cor RGB)
            triangle_data = [
                0.0, 0.5, 0.0, 1.0, 0.0, 0.0,  # V√©rtice 0: Topo (Vermelho)
                -0.5, -0.5, 0.0, 0.0, 1.0, 0.0,  # V√©rtice 1: Esquerda (Verde)
                0.5, -0.5, 0.0, 0.0, 0.0, 1.0  # V√©rtice 2: Direita (Azul)
            ]
            triangle_data = (gl.GLfloat * len(triangle_data))(*triangle_data)

            # Gerar e vincular VAO
            self.VAO = gl.glGenVertexArrays(1)
            gl.glBindVertexArray(self.VAO)

            # Gerar e vincular VBO
            self.VBO = gl.glGenBuffers(1)
            gl.glBindBuffer(gl.GL_ARRAY_BUFFER, self.VBO)
            gl.glBufferData(gl.GL_ARRAY_BUFFER, ctypes.sizeof(triangle_data), triangle_data, gl.GL_STATIC_DRAW)

            # Definir atributos de v√©rtice
            stride = 6 * ctypes.sizeof(gl.GLfloat)
            # Posi√ß√£o (location = 0)
            gl.glVertexAttribPointer(0, 3, gl.GL_FLOAT, gl.GL_FALSE, stride, ctypes.c_void_p(0))
            gl.glEnableVertexAttribArray(0)
            # Cor (location = 1)
            gl.glVertexAttribPointer(1, 3, gl.GL_FLOAT, gl.GL_FALSE, stride,
                                     ctypes.c_void_p(3 * ctypes.sizeof(gl.GLfloat)))
            gl.glEnableVertexAttribArray(1)

            # Desvincular VAO/VBO
            gl.glBindBuffer(gl.GL_ARRAY_BUFFER, 0)
            gl.glBindVertexArray(0)

            print("‚úÖ Shaders compilados e geometria do tri√¢ngulo configurada.")

        except Exception as e:
            print(f"‚ùå Erro ao configurar geometria do tri√¢ngulo: {e}")
            # Limpar shaders em caso de falha na geometria
            if self.shader_program:
                gl.glDeleteProgram(self.shader_program)
                self.shader_program = None
            self.VAO = None
            self.VBO = None

    def resizeGL(self, w, h):
        """
        Chamado sempre que o widget √© redimensionado.
        """
        print(f"Redimensionando OpenGL para {w}x{h}")
        gl.glViewport(0, 0, w, h)
        # TODO: Atualizar matriz de proje√ß√£o se necess√°rio

    def paintGL(self):
        """
        Chamado sempre que a cena OpenGL precisa ser redesenhada.
        """
        # Limpa o buffer com a cor definida em initializeGL
        gl.glClear(gl.GL_COLOR_BUFFER_BIT | gl.GL_DEPTH_BUFFER_BIT)

# --- Componente Janela Principal ---
class JanelaPrincipal(QMainWindow):
    """
    Janela principal da aplica√ß√£o, contendo a UI 2D e o widget OpenGL.
    Layout: Barras Superior/Inferior (5% da altura),
            Laterais (max(320px, 15% da largura)),
            √Årea Central para o conte√∫do OpenGL.
    """

    def __init__(self):
        super().__init__()
        self.setWindowTitle("Global Arena - Cliente PyQt6")

        # --- Verificar estado de login ANTES de criar os √≠cones ---
        self.usuario_logado = self._verificar_login()

        # --- Controle do loop de renderiza√ß√£o ---
        self.loop_ativo = True  # Flag para evitar update() em widget deletado

        # --- Obter dimens√µes da tela para c√°lculos ---
        screen_geometry = self.screen().availableGeometry()
        screen_width = screen_geometry.width()
        screen_height = screen_geometry.height()

        # --- Calcular dimens√µes das barras ---
        bar_height = int(screen_height * 0.05)
        sidebar_width = max(320, int(screen_width * 0.15))

        print(f"üéÆ Janela PyQt6 criada. Tela: {screen_width}x{screen_height}. "
              f"Barras H: {bar_height}px, Barras V: {sidebar_width}px")

        # --- Configura√ß√£o do Layout Central ---
        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        main_window_layout = QVBoxLayout(central_widget)
        main_window_layout.setContentsMargins(0, 0, 0, 0)
        main_window_layout.setSpacing(0)

        # --- Barra Superior ---
        self.barra_superior = self._criar_barra(bar_height, is_horizontal=True, object_name="BarraSuperior")
        layout_barra_superior = QHBoxLayout(self.barra_superior)
        layout_barra_superior.setContentsMargins(10, 5, 10, 5)
        label_status = QLabel("Status: Aguardando...")
        layout_barra_superior.addWidget(label_status)
        layout_barra_superior.addStretch()

        # --- Conte√∫do Principal ---
        conteudo_principal_widget = QWidget()
        conteudo_principal_layout = QHBoxLayout(conteudo_principal_widget)
        conteudo_principal_layout.setContentsMargins(0, 0, 0, 0)
        conteudo_principal_layout.setSpacing(0)

        # --- Barra Esquerda com √çcones Interativos ---
        self.barra_esquerda = self._criar_barra(sidebar_width, is_horizontal=False, object_name="BarraEsquerda")

        # Criar gerenciador de √≠cones
        self.gerenciador_icones = GerenciadorIconesEsquerda(caminho_recursos="client/resources")

        # --- Atualizar √≠cone e nome de login com base no estado ---
        if self.usuario_logado:
            try:
                with open("session.txt", "r") as f:
                    nome_usuario = f.read().strip()
                if not nome_usuario:
                    raise ValueError("Nome vazio")
            except Exception as e:
                print(f"‚ùå Erro ao ler session.txt: {e}")
                nome_usuario = "Player"
            self.gerenciador_icones.atualizar_estado_login(True, nome_usuario)
        else:
            self.gerenciador_icones.atualizar_estado_login(False)

        # Conectar sinal de clique
        self.gerenciador_icones.icone_clicado.connect(self._ao_clicar_icone_lateral)

        # Layout da barra esquerda
        layout_esquerda = QVBoxLayout(self.barra_esquerda)
        layout_esquerda.setContentsMargins(0, 0, 0, 0)
        layout_esquerda.addWidget(self.gerenciador_icones)

        # --- √Årea Central (OpenGL + Barra Direita) ---
        area_central_widget = QWidget()
        area_central_layout = QHBoxLayout(area_central_widget)
        area_central_layout.setContentsMargins(0, 0, 0, 0)
        area_central_layout.setSpacing(0)

        # --- Criar o Container para OpenGL e Overlay do T√≠tulo ---
        self.opengl_container = QWidget()
        container_layout = QVBoxLayout(self.opengl_container)
        container_layout.setContentsMargins(0, 0, 0, 0)
        container_layout.setSpacing(0)

        # --- Widget OpenGL ---
        self.opengl_widget = MeuOpenGLWidget()
        self.opengl_widget.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)

        # --- Criar o Overlay Widget para o T√≠tulo ---
        self.overlay_widget = QWidget(self.opengl_container)
        self.overlay_widget.setWindowFlags(Qt.WindowType.Widget)
        self.overlay_widget.setAttribute(Qt.WidgetAttribute.WA_TranslucentBackground)
        self.overlay_widget.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents)
        self.overlay_widget.setStyleSheet("background: transparent; border: none;")

        # --- Layout do Overlay para o T√≠tulo e Subt√≠tulo ---
        overlay_layout = QVBoxLayout(self.overlay_widget)
        overlay_layout.setContentsMargins(0, 0, 0, 0)
        overlay_layout.setSpacing(10)
        overlay_layout.setAlignment(Qt.AlignmentFlag.AlignCenter)

        # --- Label: "Welcome to" ---
        self.label_welcome = QLabel("Welcome to")
        font_welcome = QFont()
        font_welcome.setPointSize(14)
        font_welcome.setItalic(True)
        font_welcome.setWeight(500)
        self.label_welcome.setFont(font_welcome)
        self.label_welcome.setStyleSheet("color: #aaaaaa; background: transparent; border: none;")
        self.label_welcome.setAlignment(Qt.AlignmentFlag.AlignCenter)

        # --- Label: "Global Arena" ---
        self.label_titulo = QLabel("Global Arena")
        font_titulo = QFont()
        font_titulo.setPointSize(48)
        font_titulo.setBold(True)
        font_titulo.setWeight(700)
        self.label_titulo.setFont(font_titulo)
        self.label_titulo.setStyleSheet("""
            color: white;
            background-color: transparent;
            border: none;
            text-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
        """)
        self.label_titulo.setAlignment(Qt.AlignmentFlag.AlignCenter)

        # --- Label: Subt√≠tulo ---
        self.label_subtitulo = QLabel("the only one for non-flat-earthers")
        font_subtitulo = QFont()
        font_subtitulo.setPointSize(16)
        font_subtitulo.setItalic(True)
        self.label_subtitulo.setFont(font_subtitulo)
        self.label_subtitulo.setStyleSheet("""
            color: #cccccc;
            background-color: transparent;
            border: none;
            font-style: italic;
        """)
        self.label_subtitulo.setAlignment(Qt.AlignmentFlag.AlignCenter)

        # --- Adicionar ao layout na ordem correta ---
        overlay_layout.addWidget(self.label_welcome)
        overlay_layout.addWidget(self.label_titulo)
        overlay_layout.addWidget(self.label_subtitulo)

        # --- Adicionar Widgets ao Container OpenGL ---
        container_layout.addWidget(self.opengl_widget)

        # --- Corre√ß√£o robusta do resizeEvent ---
        def _safe_resize_event(event):
            # Ajustar overlay de boas-vindas
            self.overlay_widget.setGeometry(self.opengl_container.rect())
            self.overlay_widget.raise_()

            # Ajustar overlay da sala, se existir
            if hasattr(self, 'overlay_sala') and self.overlay_sala:
                self._ajustar_overlay_sala()
                self.overlay_sala.raise_()

            QWidget.resizeEvent(self.opengl_container, event)

        self.opengl_container.resizeEvent = _safe_resize_event

        # --- FOR√áAR O OVERLAY A APARECER IMEDIATAMENTE ---
        self.overlay_widget.setGeometry(self.opengl_container.rect())
        self.overlay_widget.raise_()
        self.overlay_widget.show()

        # --- Fallback p√≥s-show: Garante posicionamento ap√≥s renderiza√ß√£o inicial ---
        QTimer.singleShot(50, lambda: [
            self.overlay_widget.setGeometry(self.opengl_container.rect()),
            self.overlay_widget.raise_(),
            self.overlay_widget.show()
        ])

        # --- Barra Direita ---
        self.barra_direita = self._criar_barra(sidebar_width, is_horizontal=False, object_name="BarraDireita")
        layout_direita = QVBoxLayout(self.barra_direita)
        layout_direita.addStretch()
        banner_placeholder = QLabel("Banner\n300x600")
        banner_placeholder.setFixedSize(300, 600)
        banner_placeholder.setStyleSheet("background-color: #333; color: white; border: 1px solid gray;")
        banner_placeholder.setAlignment(Qt.AlignmentFlag.AlignCenter)
        layout_direita.addWidget(banner_placeholder, alignment=Qt.AlignmentFlag.AlignCenter)
        layout_direita.addStretch()

        # --- Adicionar widgets √† √°rea central ---
        area_central_layout.addWidget(self.opengl_container)
        area_central_layout.addWidget(self.barra_direita)

        # --- Adicionar widgets ao conte√∫do principal ---
        conteudo_principal_layout.addWidget(self.barra_esquerda)
        conteudo_principal_layout.addWidget(area_central_widget)

        # --- Barra Inferior ---
        self.barra_inferior = self._criar_barra(bar_height, is_horizontal=True, object_name="BarraInferior")
        layout_barra_inferior = QHBoxLayout(self.barra_inferior)
        layout_barra_inferior.addWidget(QLabel("Barra Inferior"))

        # --- Adicionar todos os componentes ao layout da janela ---
        main_window_layout.addWidget(self.barra_superior)
        main_window_layout.addWidget(conteudo_principal_widget)
        main_window_layout.addWidget(self.barra_inferior)

        # --- Timer para o Loop Principal ---
        self.timer = QTimer(self)
        self.timer.timeout.connect(self.atualizar_logica)
        self.timer.start(16)  # ~60 FPS

        # --- Mostrar e aplicar fullscreen ---
        self.show()
        self.setWindowState(Qt.WindowState.WindowFullScreen)

        # --- Inicializar vari√°veis de estado ---
        self.overlay_sala = None
        self.polling_timer = None
        self.game_placeholder = None

        # --- Debug final ---
        print("‚úÖ Janela exibida. Overlay for√ßado a aparecer.")
        print("üîç Geometria do container:", self.opengl_container.geometry())
        print("üîç Geometria do overlay:", self.overlay_widget.geometry())
        print("üîç Overlay vis√≠vel?", self.overlay_widget.isVisible())

    def _mostrar_dialogo_modos(self):
        """Shows the dialog to choose between Offline and Online mode."""
        modo_dialog = QDialog(self)
        modo_dialog.setWindowTitle("Game Mode")
        modo_dialog.setModal(True)
        modo_dialog.resize(300, 150)

        layout = QVBoxLayout()
        layout.addWidget(QLabel("Choose game mode:"))

        btn_offline = QPushButton("Offline")
        btn_online = QPushButton("Online")

        layout.addWidget(btn_offline)
        layout.addWidget(btn_online)
        modo_dialog.setLayout(layout)

        # Prevent automatic acceptance
        modo_dialog.accepted.connect(lambda: None)

        def escolher_offline():
            modo_dialog.reject()
            self._ir_para_tela_pre_jogo(offline=True)

        def escolher_online():
            modo_dialog.reject()
            if self.usuario_logado:
                self._entrar_na_fila()
            else:
                # ‚úÖ Open login with callback to enter queue after login
                self._abrir_dialogo_autenticacao_completo(
                    success_callback=lambda u: self._entrar_na_fila()
                )

        btn_offline.clicked.connect(escolher_offline)
        btn_online.clicked.connect(escolher_online)

        modo_dialog.exec()

    def atualizar_logica(self):
        """Atualiza a l√≥gica do jogo e solicita redesenho do OpenGL."""
        if not self.loop_ativo:
            return  # Evita update() se o loop foi desativado

        try:
            if hasattr(self, 'opengl_widget') and self.opengl_widget:
                self.opengl_widget.update()
        except RuntimeError:
            # Widget foi deletado ‚Äî apenas pare o loop
            self.parar_loop()

    def parar_loop(self):
        """Para o loop de atualiza√ß√£o gr√°fica."""
        self.loop_ativo = False
        if self.timer:
            self.timer.stop()

    def reiniciar_loop(self):
        """Reinicia o loop de atualiza√ß√£o gr√°fica (√∫til ao voltar ao menu)."""
        if not self.loop_ativo:
            self.loop_ativo = True
            self.timer.start(18)

    def _verificar_login(self):
        """Verifica se o usu√°rio est√° logado (exemplo: arquivo session.txt existe)."""
        return os.path.exists("session.txt")

    def _criar_barra(self, tamanho, is_horizontal, object_name="Barra"):
        """Cria um widget para representar uma barra, com estilo b√°sico."""
        barra = QFrame()
        barra.setObjectName(object_name)
        if is_horizontal:
            barra.setFixedHeight(tamanho)
        else:
            barra.setFixedWidth(tamanho)
        barra.setStyleSheet(f"""
            #{object_name} {{
                background-color: #2c3e50;
                border: 1px solid #34495e;
            }}
        """)
        return barra

    def atualizar_logica(self):
        """
        Atualiza a l√≥gica do jogo e solicita redesenho do OpenGL.
        """
        self.opengl_widget.update()

    def _ao_clicar_icone_lateral(self, identificador):
        """Lida com os cliques nos √≠cones da barra lateral esquerda."""
        print(f"üñ±Ô∏è JanelaPrincipal recebeu clique no √≠cone: {identificador}")
        if identificador == "login":
            self.on_icone_login()
        elif identificador == "play":
            self.on_icone_play()
        elif identificador == "sair":
            self.on_icone_sair()

    def on_icone_login(self):
        """A√ß√£o acionada pelo √≠cone de login: abre tela de login ou logout."""
        if self.usuario_logado:
            # J√° logado ‚Üí oferece logout
            reply = QMessageBox.question(
                self,
                "Logout",
                "Voc√™ est√° logado. Deseja sair da conta?",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                QMessageBox.StandardButton.No
            )
            if reply == QMessageBox.StandardButton.Yes:
                try:
                    # ‚úÖ Remove sess√£o
                    if os.path.exists("session.txt"):
                        os.remove("session.txt")
                        print("üóëÔ∏è session.txt removed (logout).")
                    # ‚úÖ Atualiza estado
                    self.usuario_logado = False
                    self.gerenciador_icones.atualizar_estado_login(False)
                    # ‚úÖ Feedback opcional (pode ser removido para UX mais limpa)
                    # QMessageBox.information(self, "Logout", "Voc√™ saiu com sucesso.")
                except Exception as e:
                    QMessageBox.critical(self, "Erro", f"Falha ao remover sess√£o: {e}")
        else:
            # N√£o logado ‚Üí abre o di√°logo completo com login e registro
            dialog = DialogoAutenticacao(self)

            def on_login_sucesso(username: str):
                """Callback chamado ap√≥s login bem-sucedido."""
                self.usuario_logado = True
                self.gerenciador_icones.atualizar_estado_login(True, username)

            if dialog.exec() == QDialog.DialogCode.Accepted:
                # ‚úÖ O di√°logo j√° garante que o login foi bem-sucedido
                try:
                    with open("session.txt", "r") as f:
                        nome_usuario = f.read().strip()
                    # Atualiza UI com o nome do usu√°rio
                    self.usuario_logado = True
                    self.gerenciador_icones.atualizar_estado_login(True, nome_usuario)
                except Exception as e:
                    print(f"‚ùå Erro ao ler session.txt ap√≥s login: {e}")
                    # Mesmo com erro, o login foi feito ‚Äî usa fallback
                    self.gerenciador_icones.atualizar_estado_login(True, "Player")

    def on_icone_play(self):
        """Action triggered by the 'Play' icon: checks state and offers offline or online mode."""
        print("Action: 'Play' icon clicked. Checking state...")

        # ‚úÖ Stop render loop before any UI changes
        self.parar_loop()

        try:
            # ‚úÖ 1. Check if user is already in a game or queue
            response = requests.get("http://localhost:5000/jogo/status", timeout=3)
            if response.status_code == 200:
                data = response.json()
                em_partida = data.get("em_partida", False)
                em_fila = data.get("em_fila", False)

                if em_partida or em_fila:
                    # ‚úÖ Perguntar ao usu√°rio
                    msg = (
                        "Voc√™ foi encontrado em uma partida ativa ou na fila.\n\n"
                        "Deseja:\n"
                        " ‚Ä¢ 'Sim' para retomar a partida atual\n"
                        " ‚Ä¢ 'N√£o' para sair e come√ßar uma nova"
                    )
                    reply = QMessageBox.question(
                        self,
                        "Partida Detectada",
                        msg,
                        QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
                    )

                    if reply == QMessageBox.StandardButton.Yes:
                        # Retomar
                        self.mostrar_tela_jogo()
                        return
                    else:
                        # Come√ßar do zero: for√ßar sa√≠da
                        username = self._ler_username()
                        requests.post("http://localhost:5000/jogo/sair", json={"username": username})

                # Se n√£o estava em partida, ou escolheu come√ßar nova
                self._ir_para_tela_pre_jogo(offline=False)

            else:
                # Servidor respondeu, mas com erro
                self._ir_para_tela_pre_jogo(offline=False)

        except requests.exceptions.ConnectionError:
            QMessageBox.critical(self, "Erro", "N√£o foi poss√≠vel conectar ao servidor.")
        except Exception as e:
            QMessageBox.critical(self, "Erro", f"Erro inesperado: {e}")
            print(f"‚ùå Erro em on_icone_play: {e}")

    def _iniciar_offline(self, escolha, dialog):
        escolha[0] = "offline"
        dialog.accept()

    def _iniciar_online(self, escolha, dialog):
        escolha[0] = "online"
        dialog.accept()

        # Verifica login
        if not self.usuario_logado:
            print("Usu√°rio n√£o logado. Abrindo di√°logo de autentica√ß√£o...")
            self._abrir_dialogo_autenticacao_completo(success_callback=self._on_login_sucesso_pre_jogo)
        else:
            self._ir_para_tela_pre_jogo(offline=False)

    def _on_login_sucesso_pre_jogo(self, username: str):
        """Callback chamado ap√≥s login bem-sucedido no fluxo de 'play online'."""
        print(f"‚úÖ Login bem-sucedido. Iniciando pr√©-jogo online para {username}.")
        self._ir_para_tela_pre_jogo(offline=False)

    def _ir_para_tela_pre_jogo(self, offline: bool):
        if offline:
            QMessageBox.information(self, "Pr√©-Jogo", "Modo offline ser√° implementado em breve.")
        else:
            self._entrar_na_fila()  # ‚úÖ Redireciona para o matchmaking

    def on_icone_sair(self):
        """Action triggered by the 'Exit' icon: confirms intent and exits, but preserves login."""
        print("Action: 'Exit' icon clicked.")

        # Check if the user is in the waiting room
        if hasattr(self, 'overlay_sala') and self.overlay_sala is not None:
            reply = QMessageBox.question(
                self,
                "Exit Game",
                "You are in a waiting room. Exiting now will cancel your participation.\n\nDo you really want to exit?",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                QMessageBox.StandardButton.No
            )
            if reply == QMessageBox.StandardButton.No:
                return  # Cancel exit

            # Notify server that user is leaving the queue
            try:
                with open("session.txt", "r") as f:
                    username = f.read().strip()
                import requests
                requests.post(
                    "http://localhost:5000/jogo/sair",
                    json={"username": username},
                    timeout=3
                )
                print(f"üì§ {username} left the queue via 'Exit'.")
            except Exception as e:
                print(f"‚ùå Failed to notify server: {e}")
            finally:
                self._esconder_overlay_sala_espera()

        # ‚úÖ N√ÉO remove session.txt ‚Üí login ser√° lembrado na pr√≥xima abertura
        # ‚úÖ N√ÉO altera self.usuario_logado ‚Üí estado de login permanece at√© a pr√≥xima inicializa√ß√£o

        # Close the application
        self.close()

    def _abrir_dialogo_autenticacao_completo(self, success_callback=None):
        """Abre o di√°logo completo de autentica√ß√£o (login + registro)."""
        dialog = DialogoAutenticacao(parent=self)

        def on_login_sucesso(username: str):
            with open("session.txt", "w") as f:
                f.write(username)
            self.usuario_logado = True
            self.gerenciador_icones.atualizar_estado_login(True, username)
            if success_callback:
                success_callback(username)
            dialog.accept()  # Fecha o di√°logo

        def tentar_login():
            username = dialog.username_login.text().strip()
            password = dialog.senha_login.text()
            if not username or not password:
                QMessageBox.warning(dialog, "Erro", "Usu√°rio e senha s√£o obrigat√≥rios.")
                return
            try:
                response = requests.post("http://localhost:5000/auth/login",
                                         json={"username": username, "password": password})
                data = response.json()
                if response.status_code == 200 and data.get("success"):
                    on_login_sucesso(username)
                else:
                    QMessageBox.critical(dialog, "Erro", data.get("message", "Login falhou."))
            except requests.exceptions.ConnectionError:
                QMessageBox.critical(dialog, "Erro", "N√£o foi poss√≠vel conectar ao servidor.")
            except Exception as e:
                QMessageBox.critical(dialog, "Erro", f"Erro: {str(e)}")

        def tentar_registro():
            username = dialog.username_registro.text().strip()
            password = dialog.senha_registro.text()
            confirmar = dialog.confirmar_senha.text()
            if not username or not password or not confirmar:
                QMessageBox.warning(dialog, "Erro", "Todos os campos s√£o obrigat√≥rios.")
                return
            if password != confirmar:
                QMessageBox.warning(dialog, "Erro", "As senhas n√£o coincidem.")
                return
            if len(password) < 6:
                QMessageBox.warning(dialog, "Erro", "A senha deve ter pelo menos 6 caracteres.")
                return
            try:
                response = requests.post("http://localhost:5000/auth/registrar",
                                         json={"username": username, "password": password})
                data = response.json()
                if response.status_code == 200 and data.get("success"):
                    QMessageBox.information(dialog, "Sucesso", "Conta criada com sucesso! Fa√ßa login.")
                    # Preenche o campo de login e muda para aba de login
                    dialog.username_login.setText(username)
                    dialog.abas.setCurrentIndex(0)
                else:
                    QMessageBox.critical(dialog, "Erro", data.get("message", "Falha no registro."))
            except requests.exceptions.ConnectionError:
                QMessageBox.critical(dialog, "Erro", "N√£o foi poss√≠vel conectar ao servidor.")
            except Exception as e:
                QMessageBox.critical(dialog, "Erro", f"Erro: {str(e)}")

        # üîÅ Conecta os bot√µes do QDialogButtonBox ao comportamento correto
        # Remover conex√£o anterior (se houver)
        try:
            dialog.buttons.accepted.disconnect()
        except TypeError:
            pass  # J√° desconectado

        # Conecta "OK" ao comportamento da aba atual
        dialog.buttons.accepted.connect(
            lambda: tentar_login() if dialog.abas.currentIndex() == 0 else tentar_registro()
        )

        # "Cancel" j√° chama reject() ‚Üí fecha o di√°logo
        dialog.exec()

    def _abrir_tela_login(self):
        """Abre um di√°logo de login com campos de usu√°rio e senha."""

        dialog = QDialog(self)
        dialog.setWindowTitle("Entrar")
        dialog.setModal(True)
        dialog.resize(300, 120)

        layout = QFormLayout()

        username_input = QLineEdit()
        password_input = QLineEdit()
        password_input.setEchoMode(QLineEdit.EchoMode.Password)

        layout.addRow("Usu√°rio:", username_input)
        layout.addRow("Senha:", password_input)

        buttons = QDialogButtonBox(QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel)
        layout.addRow(buttons)

        dialog.setLayout(layout)

        def tentar_login():
            username = username_input.text().strip()
            password = password_input.text()

            if not username or not password:
                QMessageBox.warning(dialog, "Erro", "Usu√°rio e senha s√£o obrigat√≥rios.")
                return

            # Enviar requisi√ß√£o ao backend Flask
            try:
                response = requests.post(
                    "http://localhost:5000/auth/login",
                    json={"username": username, "password": password}
                )
                data = response.json()

                if response.status_code == 200 and data.get("success"):
                    # Login bem-sucedido
                    with open("session.txt", "w") as f:
                        f.write(username)
                    self.usuario_logado = True
                    # Atualiza UI: √≠cone + nome
                    self.gerenciador_icones.atualizar_estado_login(True, username)
                    QMessageBox.information(dialog, "Sucesso", f"Bem-vindo, {username}!")
                    dialog.accept()
                else:
                    QMessageBox.critical(dialog, "Erro", data.get("message", "Login falhou."))
            except requests.exceptions.ConnectionError:
                QMessageBox.critical(dialog, "Erro", "N√£o foi poss√≠vel conectar ao servidor.")
            except Exception as e:
                QMessageBox.critical(dialog, "Erro", f"Erro inesperado: {e}")

        buttons.accepted.connect(tentar_login)
        buttons.rejected.connect(dialog.reject)

        dialog.exec()

    def _entrar_na_fila(self):
        """Tenta entrar na fila de matchmaking e mostra a tela de espera como overlay.
        Garante limpeza proativa de estado anterior (servidor e cliente).
        """
        print("üìû Chamando /jogo/entrar...")

        # ‚úÖ Evita m√∫ltiplas execu√ß√µes simult√¢neas
        if hasattr(self, 'entrando_na_fila') and self.entrando_na_fila:
            print("‚ö†Ô∏è J√° est√° entrando na fila. Opera√ß√£o ignorada.")
            return
        self.entrando_na_fila = True

        username = None
        try:
            # 1. Ler o username
            with open("session.txt", "r") as f:
                username = f.read().strip()
            if not username:
                raise FileNotFoundError("Arquivo de sess√£o vazio.")

            # 2. ‚úÖ Limpeza proativa no servidor: for√ßa sa√≠da e limpa estado
            try:
                requests.post(
                    "http://localhost:5000/jogo/limpar_usuario",
                    json={"username": username},
                    timeout=3
                )
                print(f"üßπ Estado do usu√°rio '{username}' limpo no servidor.")
            except Exception as e:
                print(f"‚ö†Ô∏è Falha ao limpar estado no servidor (servidor offline?): {e}")
                # Continua mesmo assim ‚Äî pode ser um teste local

            # 3. ‚úÖ Limpeza local: parar polling e remover overlays
            if hasattr(self, 'polling_timer') and self.polling_timer:
                self.polling_timer.stop()
                self.polling_timer.deleteLater()
                self.polling_timer = None

            # 4. ‚úÖ For√ßar remo√ß√£o do overlay existente
            if hasattr(self, 'overlay_sala') and self.overlay_sala is not None:
                self._esconder_overlay_sala_espera()
            self.overlay_sala = None  # Garante que ser√° recriado

            # 5. ‚úÖ Entrar na fila
            response = requests.post(
                "http://localhost:5000/jogo/entrar",
                json={"modo": "online", "username": username},
                timeout=5
            )
            data = response.json()

            if data.get("success"):
                max_jogadores = data.get("max_jogadores", 4)

                # 6. ‚úÖ Mostrar overlay da sala de espera
                self._mostrar_overlay_sala_espera(username, max_jogadores)

                # 7. ‚úÖ Iniciar polling para atualizar status
                self._iniciar_polling_sala()

                print(f"‚úÖ {username} entrou na fila. Overlay exibido.")
            else:
                QMessageBox.critical(self, "Erro", data.get("message", "Falha ao entrar na fila."))

        except FileNotFoundError:
            QMessageBox.critical(self, "Erro", "Voc√™ n√£o est√° logado.")
        except requests.exceptions.ConnectionError:
            QMessageBox.critical(self, "Erro", "N√£o foi poss√≠vel conectar ao servidor.")
        except requests.exceptions.Timeout:
            QMessageBox.critical(self, "Erro", "Tempo de resposta excedido.")
        except Exception as e:
            QMessageBox.critical(self, "Erro", f"Erro inesperado: {e}")
            print(f"‚ùå Erro em _entrar_na_fila: {e}")
        finally:
            self.entrando_na_fila = False

    def on_partida_iniciada(self):
        """Chamado quando a partida come√ßa.
        Realiza limpeza completa de UI e prepara a transi√ß√£o para o modo de jogo.
        """
        print("üéÆ Partida iniciada: removendo overlays, status e parando polling...")

        # 1. Remover o widget de status da barra lateral (se existir)
        try:
            if hasattr(self, 'gerenciador_icones') and self.gerenciador_icones:
                self.gerenciador_icones.remover_status_sala()
                print("üóëÔ∏è Widget de status da sala removido da barra esquerda.")
        except Exception as e:
            print(f"‚ö†Ô∏è Falha ao remover status da sala: {e}")

        # 2. Esconder e remover o overlay da sala de espera (se existir)
        try:
            if hasattr(self, 'overlay_sala') and self.overlay_sala is not None:
                # Usa o mecanismo de fade_out do overlay, se dispon√≠vel
                if hasattr(self.overlay_sala, 'fade_out'):
                    self.overlay_sala.fade_out()
                    # Ap√≥s a anima√ß√£o, esconde e remove
                    from PyQt6.QtCore import QTimer
                    QTimer.singleShot(300, self._esconder_overlay_sala_espera)
                else:
                    self._esconder_overlay_sala_espera()
                print("üé® Overlay da sala de espera removido com sucesso.")
        except Exception as e:
            print(f"‚ö†Ô∏è Falha ao esconder overlay da sala: {e}")

        # 3. Parar o polling de status (evita chamadas desnecess√°rias)
        try:
            if hasattr(self, 'polling_timer') and self.polling_timer:
                self.polling_timer.stop()
                self.polling_timer.deleteLater()
                self.polling_timer = None
                print("‚è∏Ô∏è Polling de status da sala interrompido.")
        except Exception as e:
            print(f"‚ö†Ô∏è Falha ao parar o polling: {e}")

        # 4. Placeholder: exibir mensagem de partida iniciada
        try:
            # ‚úÖ Compat√≠vel com o c√≥digo atual
            QMessageBox.information(self, "Game Started", "Loading Planet...")
            print("üü¢ Placeholder de partida exibido: 'Loading Planet...'")

            # ‚úÖ Opcional: ativar modo de jogo no OpenGL (se implementado futuramente)
            if hasattr(self, 'opengl_widget') and self.opengl_widget:
                # Se no futuro voc√™ adicionar o m√©todo:
                # self.opengl_widget.ativar_modo_jogo()
                # Por enquanto, for√ßar atualiza√ß√£o
                self.opengl_widget.update()
        except Exception as e:
            print(f"‚ö†Ô∏è Falha ao exibir tela de jogo: {e}")

        # 5. Mensagem final de sucesso
        print("‚úÖ Transi√ß√£o para partida conclu√≠da com sucesso.")

    def _mostrar_overlay_sala_espera(self, username: str, max_jogadores: int):
        """
        Mostra o overlay da sala de espera como sobreposi√ß√£o flutuante sobre o OpenGL,
        substituindo o 'Welcome to Global Arena', sem afetar o layout do OpenGL.
        """
        # 1. Se j√° existe um overlay da sala, remova-o corretamente
        if self.overlay_sala is not None:
            self._esconder_overlay_sala_espera()

        # 2. Esconder o overlay de boas-vindas
        self.overlay_widget.hide()

        # 3. Criar o novo overlay da sala de espera
        try:
            self.overlay_sala = WaitingRoomOverlay(username, max_jogadores, parent=self.opengl_container)
        except Exception as e:
            print(f"‚ùå Falha ao criar WaitingRoomOverlay: {e}")
            self.overlay_widget.show()  # Restaura se falhar
            return

        # 4. Adicionar como widget filho direto (sem usar layout) ‚Üí evita interfer√™ncia no OpenGL
        self.overlay_sala.setParent(self.opengl_container)
        self.overlay_sala.hide()  # Inicialmente oculto para ajustar posi√ß√£o primeiro

        # 5. Ajustar posi√ß√£o e tamanho com base no container (ser√° refinado ap√≥s renderiza√ß√£o)
        self._ajustar_overlay_sala()

        # 6. Exibir o overlay
        self.overlay_sala.show()
        self.overlay_sala.raise_()  # Garante que fique na frente

        # 7. Conectar o bot√£o Cancelar com a l√≥gica de sa√≠da
        def on_cancel():
            try:
                import requests
                requests.post(
                    "http://localhost:5000/jogo/sair",
                    json={"username": username},
                    timeout=3
                )
                print(f"üì§ {username} saiu da fila via cancelamento.")
            except Exception as e:
                print(f"‚ùå Falha ao sair da fila: {e}")
            finally:
                # Sempre esconder o overlay ap√≥s tentar sair
                self._esconder_overlay_sala_espera()

        # Conectar o callback ao bot√£o Cancelar
        self.overlay_sala.connect_cancel(on_cancel)

        # 8. üëâ Garantir posicionamento p√≥s-renderiza√ß√£o (evita geometria 0x0)
        from PyQt6.QtCore import QTimer
        QTimer.singleShot(30, self._ajustar_overlay_sala)
        QTimer.singleShot(60, lambda: self.overlay_sala.raise_() if self.overlay_sala else None)

    def _esconder_overlay_sala_espera(self):
        """Remove o overlay da sala de espera e limpa a refer√™ncia."""
        if hasattr(self, 'overlay_sala') and self.overlay_sala is not None:
            # Parar timer do overlay
            if hasattr(self.overlay_sala, 'timer') and self.overlay_sala.timer:
                self.overlay_sala.timer.stop()

            # Remover do layout e deletar
            self.overlay_sala.setParent(None)
            self.overlay_sala.deleteLater()
            self.overlay_sala = None  # üëà Muito importante!
            print("üé® Overlay da sala de espera removido e refer√™ncia limpa.")

    def _ajustar_overlay_sala(self):
        """Ajusta posi√ß√£o e tamanho do overlay da sala de espera, garantindo centraliza√ß√£o e responsividade.
        Protegido contra chamadas prematuras (ex: geometria 0x0)."""
        if not self.overlay_sala or not self.opengl_container:
            return

        container_rect = self.opengl_container.rect()

        # ‚úÖ Prote√ß√£o contra chamadas prematuras (tamanho inv√°lido)
        if container_rect.width() < 10 or container_rect.height() < 10:
            print("‚ö†Ô∏è _ajustar_overlay_sala adiado: container ainda n√£o tem dimens√µes v√°lidas.")
            from PyQt6.QtCore import QTimer
            QTimer.singleShot(20, self._ajustar_overlay_sala)  # Tenta novamente em breve
            return

        # ‚úÖ Calcular dimens√µes responsivas
        max_width = 500
        min_width = 300
        padding_horizontal = 60
        target_width = min(max_width, container_rect.width() - padding_horizontal)
        width = max(min_width, target_width)  # Garante largura m√≠nima

        height = 300  # Altura fixa suficiente para o conte√∫do

        # ‚úÖ Centralizar
        x = (container_rect.width() - width) // 2
        y = (container_rect.height() - height) // 2

        # ‚úÖ Aplicar geometria
        self.overlay_sala.setGeometry(x, y, width, height)
        self.overlay_sala.raise_()  # Garante que fique na frente

        print(f"üé® Overlay ajustado: ({x}, {y}, {width}x{height}) dentro de {container_rect.size()}")

    def _iniciar_polling_sala(self):
        """Inicia o polling para atualizar o status da sala de espera a cada 1 segundo."""
        from PyQt6.QtCore import QTimer

        # Pare qualquer timer anterior
        if hasattr(self, 'polling_timer') and self.polling_timer:
            self.polling_timer.stop()
            self.polling_timer.deleteLater()

        self.polling_timer = QTimer(self)
        self.polling_timer.timeout.connect(self._atualizar_status_sala)
        self.polling_timer.start(1000)  # A cada 1 segundo
        self._atualizar_status_sala()  # Primeira atualiza√ß√£o imediata

    def _atualizar_status_sala(self):
        """Atualiza o n√∫mero de jogadores na sala via requisi√ß√£o ao servidor."""
        try:
            import requests
            response = requests.get("http://localhost:5000/status", timeout=3)
            if response.status_code == 200:
                data = response.json()
                total_na_fila = data.get("total_na_fila", 0)

                # Atualiza o overlay, se existir
                if hasattr(self, 'overlay_sala') and self.overlay_sala is not None:
                    self.overlay_sala.atualizar_status(total_na_fila)

                # Se a sala encheu, inicia a partida
                if total_na_fila >= 4:  # Ou use self.overlay_sala.max_jogadores se quiser
                    self._esconder_overlay_sala_espera()
                    self.polling_timer.stop()
                    self.on_partida_iniciada()

        except Exception as e:
            print(f"‚ùå Erro ao atualizar status da sala: {e}")
            pass

    def mostrar_tela_jogo(self):
        """Mostra a tela placeholder do jogo."""
        # Esconder overlays
        if self.overlay_widget:
            self.overlay_widget.hide()
        if self.overlay_sala:
            self._esconder_overlay_sala_espera()

        # Remover status da barra
        if hasattr(self, 'gerenciador_icones'):
            self.gerenciador_icones.remover_status_sala()

        # Parar polling
        if hasattr(self, 'polling_timer') and self.polling_timer:
            self.polling_timer.stop()

        # Criar e mostrar placeholder
        username = self._ler_username()
        self.game_placeholder = GamePlaceholder(username, parent=self.opengl_container)
        self.game_placeholder.setParent(self.opengl_container)
        self.game_placeholder.setGeometry(self.opengl_container.rect())
        self.game_placeholder.show()
        self.game_placeholder.raise_()

    def sair_da_partida(self):
        """Sai da partida e volta para o menu principal."""
        if self.game_placeholder:
            self.game_placeholder.setParent(None)
            self.game_placeholder.deleteLater()
            self.game_placeholder = None

        # Restaurar overlay de boas-vindas
        if self.overlay_widget:
            self.overlay_widget.show()
            self.overlay_widget.raise_()

        print("‚úÖ Retornou ao menu principal.")


# --- Ponto de Entrada da Aplica√ß√£o ---
def main():
    print("üéÆ Inicializando cliente gr√°fico com PyQt6...")
    app = QApplication(sys.argv)

    # Configurar o formato OpenGL padr√£o globalmente
    fmt = QSurfaceFormat()
    fmt.setVersion(3, 3)
    fmt.setProfile(QSurfaceFormat.OpenGLContextProfile.CoreProfile)
    # fmt.setDepthBufferSize(24)
    # fmt.setSamples(4)
    QSurfaceFormat.setDefaultFormat(fmt)

    try:
        janela = JanelaPrincipal()
        # janela.show() # show() j√° √© chamado dentro de __init__
        print("‚úÖ Janela principal exibida em fullscreen.")
        sys.exit(app.exec())
    except Exception as e:
        print(f"‚ùå Erro ao criar/iniciar a janela: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)


if __name__ == "__main__":
    # Cria um arquivo session.txt de placeholder para testar o √≠cone "logado"
    # with open("session.txt", "w") as f:
    #     f.write("usuario_teste_logado")
    main()

================================================================================
üìÑ client/widgets/status_room.py
================================================================================
# client/widgets/status_room.py
from PyQt6.QtWidgets import (
    QWidget, QVBoxLayout, QLabel, QPushButton, QFrame
)
from PyQt6.QtCore import Qt
import requests


class WidgetStatusSalaEspera(QWidget):
    """
    Widget compacto para exibir status da sala de espera
    diretamente na barra esquerda, entre 'Play' e 'Sair'.
    """

    def __init__(self, username: str, max_jogadores: int, parent=None):
        super().__init__(parent)
        self.username = username
        self.max_jogadores = max_jogadores
        self.parent_widget = parent
        self.timer = None
        self.setup_ui()

    def setup_ui(self):
        layout = QVBoxLayout()
        layout.setSpacing(8)
        layout.setContentsMargins(12, 10, 12, 10)

        # Fundo arredondado
        self.setStyleSheet("""
            background-color: #34495e;
            border-radius: 10px;
            border: 1px solid #3498db;
        """)
        self.setFixedHeight(110)

        # T√≠tulo
        self.titulo = QLabel("üéÆ Sala de Espera")
        self.titulo.setStyleSheet("font-size: 13px; font-weight: bold; color: #ecf0f1;")
        layout.addWidget(self.titulo)

        # Status: jogadores
        self.label_status = QLabel(f"Jogadores: 1 / {self.max_jogadores}")
        self.label_status.setStyleSheet("font-size: 12px; color: #bdc3c7;")
        layout.addWidget(self.label_status)

        # Usu√°rio
        self.label_usuario = QLabel(f"Voc√™: {self.username}")
        self.label_usuario.setStyleSheet("font-size: 11px; color: #95a5a6;")
        layout.addWidget(self.label_usuario)

        # Bot√£o Cancelar
        self.btn_cancelar = QPushButton("Cancelar")
        self.btn_cancelar.setStyleSheet("""
            QPushButton {
                background-color: #e74c3c;
                color: white;
                border: none;
                padding: 5px;
                border-radius: 6px;
                font-size: 11px;
            }
            QPushButton:hover {
                background-color: #c0392b;
            }
        """)
        self.btn_cancelar.setFixedHeight(25)
        self.btn_cancelar.clicked.connect(self.on_cancelar)
        layout.addWidget(self.btn_cancelar)

        self.setLayout(layout)

    def atualizar_status(self, total_na_fila: int):
        """Atualiza o contador de jogadores."""
        self.label_status.setText(f"Jogadores: {total_na_fila} / {self.max_jogadores}")

    def on_cancelar(self):
        """Chamado ao clicar em Cancelar."""
        try:
            with open("session.txt", "r") as f:
                username = f.read().strip()
            requests.post("http://localhost:5000/jogo/sair", json={"username": username})
        except:
            pass
        finally:
            if self.parent_widget:
                self.parent_widget.remover_status_sala()  # M√©todo que vamos adicionar

================================================================================
üìÑ client/widgets/waiting_room_overlay.py
================================================================================
# client/widgets/waiting_room_overlay.py
from PyQt6.QtWidgets import (
    QWidget, QVBoxLayout, QLabel, QPushButton, QFrame, QSizePolicy
)
from PyQt6.QtCore import Qt
from PyQt6.QtGui import QFont


class WaitingRoomOverlay(QWidget):
    """
    Overlay flutuante para exibir a sala de espera no centro da √°rea principal,
    entre as barras laterais, substituindo o 'Welcome to Global Arena'.
    """

    def __init__(self, username: str, max_jogadores: int, parent=None):
        super().__init__(parent)
        self.username = username
        self.max_jogadores = max_jogadores
        self.setup_ui()

    def setup_ui(self):
        # Fundo transl√∫cido escuro
        self.setStyleSheet("background-color: rgba(0, 0, 0, 180);")
        self.setAttribute(Qt.WidgetAttribute.WA_TranslucentBackground)
        self.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)

        # Layout principal com centraliza√ß√£o vertical
        layout = QVBoxLayout(self)
        layout.setContentsMargins(20, 15, 20, 15)
        layout.setSpacing(12)
        layout.setAlignment(Qt.AlignmentFlag.AlignCenter)

        # ‚úÖ Adicionar stretch acima para centralizar
        layout.addStretch()

        # --- T√çTULO: Waiting Room ---
        self.label_titulo = QLabel("Waiting Room")
        font_titulo = QFont()
        font_titulo.setPointSize(20)
        font_titulo.setBold(True)
        self.label_titulo.setFont(font_titulo)
        self.label_titulo.setStyleSheet("color: #3498db;")
        self.label_titulo.setAlignment(Qt.AlignmentFlag.AlignCenter)
        layout.addWidget(self.label_titulo)

        # --- SUBT√çTULO: Players: X / 4 ---
        self.label_subtitulo = QLabel(f"Players: 1 / {self.max_jogadores}")
        font_sub = QFont()
        font_sub.setPointSize(14)
        self.label_subtitulo.setFont(font_sub)
        self.label_subtitulo.setStyleSheet("color: #ecf0f1;")
        self.label_subtitulo.setAlignment(Qt.AlignmentFlag.AlignCenter)
        layout.addWidget(self.label_subtitulo)

        # --- CAIXA: Nome do jogador ---
        self.content_frame = QFrame()
        self.content_frame.setStyleSheet("""
            background-color: #2c3e50;
            border: 2px solid #3498db;
            border-radius: 16px;
            padding: 20px;
        """)
        content_layout = QVBoxLayout()
        content_layout.setSpacing(10)

        # ‚úÖ REMOVIDO: self.label_icon = QLabel("üéÆ") ‚Üí N√£o queremos o emoji

        self.label_user = QLabel(f"You: {self.username}")
        self.label_user.setStyleSheet("font-size: 14px; color: #bdc3c7;")
        self.label_user.setAlignment(Qt.AlignmentFlag.AlignCenter)
        content_layout.addWidget(self.label_user)

        self.content_frame.setLayout(content_layout)
        layout.addWidget(self.content_frame)

        # --- BOT√ÉO CANCEL ---
        self.btn_cancel = QPushButton("Cancel")
        self.btn_cancel.setStyleSheet("""
            QPushButton {
                background-color: #e74c3c;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 6px;
                font-weight: bold;
                font-size: 13px;
            }
            QPushButton:hover {
                background-color: #c0392b;
            }
        """)
        self.btn_cancel.setFixedHeight(35)
        layout.addWidget(self.btn_cancel)

        # ‚úÖ Adicionar stretch abaixo para centralizar
        layout.addStretch()

    def atualizar_status(self, total_na_fila: int):
        """Atualiza o subt√≠tulo com o n√∫mero de jogadores na fila."""
        self.label_subtitulo.setText(f"Players: {total_na_fila} / {self.max_jogadores}")

    def connect_cancel(self, callback):
        """Conecta o bot√£o Cancelar a uma fun√ß√£o."""
        if callable(callback):
            self.btn_cancel.clicked.connect(callback)

================================================================================
üìÑ client/widgets/game_placeholder.py
================================================================================
# client/widgets/game_placeholder.py
from PyQt6.QtWidgets import QWidget, QVBoxLayout, QLabel, QPushButton
from PyQt6.QtCore import Qt

class GamePlaceholder(QWidget):
    """Tela tempor√°ria que simula o jogo em andamento."""
    def __init__(self, username: str, parent=None):
        super().__init__(parent)
        self.username = username
        self.setup_ui()

    def setup_ui(self):
        layout = QVBoxLayout()
        layout.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.setLayout(layout)

        # Fundo escuro
        self.setStyleSheet("background-color: #1e1e2e; color: white;")

        # T√≠tulo
        titulo = QLabel("üåç Partida em Andamento")
        titulo.setStyleSheet("font-size: 28px; font-weight: bold; margin-bottom: 20px;")
        titulo.setAlignment(Qt.AlignmentFlag.AlignCenter)

        # Informa√ß√µes
        info = QLabel(f"Jogador: {self.username}\nModo: Online\nMundo: Global Sphere")
        info.setStyleSheet("font-size: 18px; margin-bottom: 30px;")
        info.setAlignment(Qt.AlignmentFlag.AlignCenter)

        # Bot√£o para sair
        btn_sair = QPushButton("üö™ Sair da Partida")
        btn_sair.setStyleSheet("""
            QPushButton {
                background-color: #d22d72;
                color: white;
                font-size: 16px;
                padding: 10px;
                border-radius: 8px;
            }
            QPushButton:hover {
                background-color: #ff3c8e;
            }
        """)
        btn_sair.clicked.connect(self.on_sair)

        layout.addWidget(titulo)
        layout.addWidget(info)
        layout.addWidget(btn_sair)

    def on_sair(self):
        """Chamado quando o jogador clica em 'Sair'."""
        if hasattr(self.parent(), 'sair_da_partida'):
            self.parent().sair_da_partida()
        else:
            self.hide()

================================================================================
üìÑ client/states/waiting_room.py
================================================================================
# client/states/waiting_room.py
from PyQt6.QtWidgets import (
    QWidget, QVBoxLayout, QLabel, QFrame
)
from PyQt6.QtCore import Qt, QTimer, pyqtProperty, QPropertyAnimation, QEasingCurve
from PyQt6.QtGui import QCursor
import requests


class OverlaySalaEspera(QWidget):
    """
    Widget de sobreposi√ß√£o (overlay) para exibir a sala de espera
    diretamente sobre o OpenGL, mantendo a barra de √≠cones, fundo e estrutura.
    N√£o substitui a janela principal.
    """

    def __init__(self, username: str, max_jogadores: int, parent=None):
        super().__init__(parent)
        self.username = username
        self.max_jogadores = max_jogadores
        self.parent_widget = parent  # Refer√™ncia ao widget pai (ex: opengl_container)
        self.timer = None
        self._opacity = 0.0
        self.setCursor(QCursor(Qt.CursorShape.WaitCursor))
        self.setup_ui()
        self.iniciar_polling()

    def _get_opacity(self):
        return self._opacity

    def _set_opacity(self, opacity):
        self._opacity = opacity
        # Atualiza fundo com transpar√™ncia
        self.setStyleSheet(
            f"background-color: rgba(44, 62, 80, {int(opacity * 180)}); "
            "border-radius: 15px; border: 1px solid #3498db;"
        )

    opacity = pyqtProperty(float, _get_opacity, _set_opacity)

    def setup_ui(self):
        # Layout principal
        layout = QVBoxLayout()
        layout.setSpacing(15)
        layout.setContentsMargins(20, 20, 20, 20)
        layout.setAlignment(Qt.AlignmentFlag.AlignCenter)

        # T√≠tulo
        titulo = QLabel("üéÆ Sala de Espera")
        titulo.setStyleSheet("font-size: 18px; font-weight: bold; color: #ecf0f1;")
        titulo.setAlignment(Qt.AlignmentFlag.AlignCenter)
        layout.addWidget(titulo)

        # Subt√≠tulo
        subtitulo = QLabel("Aguardando outros jogadores entrarem...")
        subtitulo.setStyleSheet("font-size: 13px; color: #bdc3c7;")
        subtitulo.setAlignment(Qt.AlignmentFlag.AlignCenter)
        layout.addWidget(subtitulo)

        # Linha separadora
        linha = QFrame()
        linha.setFrameShape(QFrame.Shape.HLine)
        linha.setFrameShadow(QFrame.Shadow.Sunken)
        linha.setStyleSheet("color: #34495e;")
        layout.addWidget(linha)

        # Status: jogadores na fila
        self.label_status = QLabel("Voc√™ entrou na fila...")
        self.label_status.setStyleSheet(
            "font-size: 16px; color: #ecf0f1; background-color: #2c3e50; "
            "padding: 10px; border-radius: 8px;"
        )
        self.label_status.setAlignment(Qt.AlignmentFlag.AlignCenter)
        layout.addWidget(self.label_status)

        # Informa√ß√£o do usu√°rio
        self.label_usuario = QLabel(f"Seu nome: {self.username}")
        self.label_usuario.setStyleSheet("font-size: 13px; color: #95a5a6;")
        self.label_usuario.setAlignment(Qt.AlignmentFlag.AlignCenter)
        layout.addWidget(self.label_usuario)

        self.setLayout(layout)

        # Estilo geral
        self.setFixedWidth(360)
        self.setFixedHeight(220)
        self.setStyleSheet("background-color: rgba(44, 62, 80, 180); border-radius: 15px; border: 1px solid #3498db;")
        self.setAttribute(Qt.WidgetAttribute.WA_TranslucentBackground)
        self.hide()  # Come√ßa oculto

    def iniciar_polling(self):
        """Inicia atualiza√ß√£o peri√≥dica do status da fila."""
        self.timer = QTimer(self)
        self.timer.timeout.connect(self.atualizar_status)
        self.timer.start(1000)  # A cada 1 segundo
        self.atualizar_status()  # Primeira atualiza√ß√£o imediata

    def atualizar_status(self):
        try:
            response = requests.get("http://localhost:5000/status", timeout=3)
            if response.status_code == 200:
                data = response.json()
                total_na_fila = data.get("total_na_fila", 0)
                self.label_status.setText(f"Jogadores na fila: {total_na_fila} / {self.max_jogadores}")
                print(f"üìä Status atual: {total_na_fila} / {self.max_jogadores}")

                if total_na_fila >= self.max_jogadores:
                    self.partida_iniciada()
        except requests.exceptions.ConnectionError:
            self.label_status.setText("‚ùå Erro de conex√£o")
        except Exception as e:
            self.label_status.setText(f"‚ùå Erro: {str(e)}")

    def partida_iniciada(self):
        """Chamado quando a sala est√° cheia."""
        if self.timer:
            self.timer.stop()
        self.label_status.setText("‚úÖ Partida iniciada! Carregando mundo...")

        # Chama fun√ß√£o da janela principal
        if hasattr(self.parent_widget, 'on_partida_iniciada'):
            # Anima√ß√£o de sa√≠da opcional antes de esconder
            self.fade_out()
            QTimer.singleShot(300, self.parent_widget.on_partida_iniciada)
        else:
            self.hide()

    def fade_in(self):
        """Anima√ß√£o de entrada suave."""
        self._opacity = 0.0
        self.show()
        self.raise_()

        anim = QPropertyAnimation(self, b"opacity")
        anim.setDuration(250)
        anim.setStartValue(0.0)
        anim.setEndValue(1.0)
        anim.setEasingCurve(QEasingCurve.Type.InOutCubic)
        anim.start(QPropertyAnimation.DeletionPolicy.DeleteWhenStopped)

    def fade_out(self):
        """Anima√ß√£o de sa√≠da suave."""
        anim = QPropertyAnimation(self, b"opacity")
        anim.setDuration(200)
        anim.setStartValue(1.0)
        anim.setEndValue(0.0)
        anim.setEasingCurve(QEasingCurve.Type.InOutCubic)
        anim.start(QPropertyAnimation.DeletionPolicy.DeleteWhenStopped)

    def showEvent(self, event):
        """Reposiciona o overlay no centro do pai ao aparecer."""
        super().showEvent(event)
        if self.parent_widget:
            x = (self.parent_widget.width() - self.width()) // 2
            y = (self.parent_widget.height() - self.height()) // 2
            self.move(x, y)
        # Inicia anima√ß√£o de entrada
        QTimer.singleShot(10, self.fade_in)

    def resizeEvent(self, event):
        """Reposiciona ao redimensionar."""
        super().resizeEvent(event)
        if self.isVisible() and self.parent_widget:
            x = (self.parent_widget.width() - self.width()) // 2
            y = (self.parent_widget.height() - self.height()) // 2
            self.move(x, y)

================================================================================
üìÑ client/dialogs/auth_dialog.py
================================================================================
# client/dialogs/auth_dialog.py
from PyQt6.QtWidgets import (
    QDialog, QTabWidget, QWidget, QFormLayout, QLineEdit,
    QDialogButtonBox, QMessageBox, QVBoxLayout
)
import requests


class DialogoAutenticacao(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Autentica√ß√£o")
        self.setModal(True)
        self.resize(350, 200)

        layout_principal = QVBoxLayout(self)

        # Abas: Login e Registro
        self.abas = QTabWidget()  # Salvando como atributo para acesso futuro
        self.abas.addTab(self.criar_aba_login(), "Entrar")
        self.abas.addTab(self.criar_aba_registro(), "Registrar")
        layout_principal.addWidget(self.abas)

        # Bot√µes comuns ‚Üí AGORA salvo como atributo: self.buttons
        self.buttons = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel
        )
        self.buttons.accepted.connect(self.on_ok)
        self.buttons.rejected.connect(self.reject)
        layout_principal.addWidget(self.buttons)

    def criar_aba_login(self):
        widget = QWidget()
        layout = QFormLayout()

        self.username_login = QLineEdit()
        self.username_login.setPlaceholderText("seu_username ou email")
        self.username_login.setToolTip("Digite seu username ou email para login.")
        layout.addRow("Username:", self.username_login)  # ‚Üê Aqui tamb√©m

        self.senha_login = QLineEdit()
        self.senha_login.setEchoMode(QLineEdit.EchoMode.Password)
        layout.addRow("Senha:", self.senha_login)

        widget.setLayout(layout)
        return widget

    def criar_aba_registro(self):
        widget = QWidget()
        layout = QFormLayout()

        self.username_registro = QLineEdit()
        self.username_registro.setPlaceholderText("ex: jogador_42")
        self.username_registro.setToolTip("Seu nome de usu√°rio √∫nico. Usado para login.")
        layout.addRow("Username:", self.username_registro)  # ‚Üê Alterado de "Usu√°rio"

        self.senha_registro = QLineEdit()
        self.senha_registro.setEchoMode(QLineEdit.EchoMode.Password)
        layout.addRow("Senha:", self.senha_registro)

        self.confirmar_senha = QLineEdit()
        self.confirmar_senha.setEchoMode(QLineEdit.EchoMode.Password)
        layout.addRow("Confirmar:", self.confirmar_senha)

        widget.setLayout(layout)
        return widget

    def on_ok(self):
        """Chamado quando o bot√£o OK √© pressionado. Executa login ou registro conforme aba ativa."""
        aba_atual = self.abas.currentIndex()  # ‚úÖ Acesso direto ao QTabWidget
        if aba_atual == 0:
            self.tentar_login()
        else:
            self.tentar_registro()

    def tentar_login(self):
        username = self.username_login.text().strip()
        password = self.senha_login.text()

        if not username or not password:
            QMessageBox.warning(self, "Erro", "Usu√°rio e senha s√£o obrigat√≥rios.")
            return

        try:
            response = requests.post(
                "http://localhost:5000/auth/login",
                json={"username": username, "password": password}
            )
            data = response.json()

            if response.status_code == 200 and data.get("success"):
                with open("session.txt", "w") as f:
                    f.write(username)
                QMessageBox.information(self, "Sucesso", f"Bem-vindo, {username}!")
                self.accept()  # Fecha o di√°logo com sucesso
            else:
                QMessageBox.critical(self, "Erro", data.get("message", "Falha no login."))
        except requests.exceptions.ConnectionError:
            QMessageBox.critical(self, "Erro", "N√£o foi poss√≠vel conectar ao servidor.")
        except Exception as e:
            QMessageBox.critical(self, "Erro", f"Erro inesperado: {e}")

    def tentar_registro(self):
        username = self.username_registro.text().strip()
        password = self.senha_registro.text()
        confirmar = self.confirmar_senha.text()

        if not username or not password or not confirmar:
            QMessageBox.warning(self, "Erro", "Todos os campos s√£o obrigat√≥rios.")
            return
        if password != confirmar:
            QMessageBox.warning(self, "Erro", "As senhas n√£o coincidem.")
            return
        if len(password) < 6:
            QMessageBox.warning(self, "Erro", "A senha deve ter pelo menos 6 caracteres.")
            return

        try:
            response = requests.post(
                "http://localhost:5000/auth/registrar",
                json={"username": username, "password": password}
            )
            data = response.json()

            if response.status_code == 200 and data.get("success"):
                QMessageBox.information(self, "Sucesso", "Conta criada com sucesso! Fa√ßa login.")
                # Podemos mudar para aba de login automaticamente
                self.parent().findChild(QTabWidget).setCurrentIndex(0)
                self.username_login.setText(username)
            else:
                QMessageBox.critical(self, "Erro", data.get("message", "Falha no registro."))
        except requests.exceptions.ConnectionError:
            QMessageBox.critical(self, "Erro", "N√£o foi poss√≠vel conectar ao servidor.")
        except Exception as e:
            QMessageBox.critical(self, "Erro", f"Erro inesperado: {e}")

================================================================================
üìÑ client/components/icon_manager.py
================================================================================
# client/components/icon_manager.py
"""Componentes para gerenciar √≠cones interativos na barra lateral esquerda."""

import os
from PyQt6.QtWidgets import QLabel, QVBoxLayout, QWidget, QHBoxLayout
from PyQt6.QtCore import Qt, pyqtSignal
from PyQt6.QtGui import QPixmap, QCursor
import requests
from client.widgets.status_room import WidgetStatusSalaEspera


class IconeInterativo(QLabel):
    """
    Um QLabel que exibe uma imagem e emite um sinal quando clicado.
    """
    clicado = pyqtSignal(str)  # Sinal emitido ao ser clicado, passando um identificador

    def __init__(self, icone_path, identificador, tamanho=(64, 64), parent=None):
        """
        :param icone_path: Caminho para o arquivo PNG do √≠cone.
        :param identificador: String √∫nica para identificar este √≠cone ("login", "play", "sair").
        :param tamanho: Tupla (largura, altura) para redimensionar o √≠cone.
        :param parent: Widget pai.
        """
        super().__init__(parent)
        self.identificador = identificador
        self.tamanho = tamanho
        self.setAlignment(Qt.AlignmentFlag.AlignCenter)

        # Estilo para feedback visual (opcional)
        self.setStyleSheet("""
            IconeInterativo {
                border: 2px solid transparent; /* Borda invis√≠vel por padr√£o */
                border-radius: 5px; /* Bordas arredondadas */
            }
            IconeInterativo:hover {
                border: 2px solid #3498db; /* Borda azul ao passar o mouse */
                background-color: rgba(52, 152, 219, 30); /* Fundo azul claro transparente */
            }
        """)
        self.setCursor(QCursor(Qt.CursorShape.PointingHandCursor))  # Muda o cursor para m√£ozinha

        self.carregar_icone(icone_path)
        # Redimensionar o QLabel para o tamanho desejado
        self.setFixedSize(*self.tamanho)

    def carregar_icone(self, caminho):
        """
        Carrega e define a imagem do √≠cone.
        Inclui verifica√ß√µes detalhadas e logs para facilitar depura√ß√£o.
        """
        print(f"[DEBUG] [IconeInterativo] Tentando carregar √≠cone '{self.identificador}' de: '{caminho}'")

        # --- Verifica√ß√µes detalhadas do caminho ---
        caminho_absoluto = os.path.abspath(caminho)
        existe = os.path.exists(caminho)
        eh_arquivo = os.path.isfile(caminho) if existe else False

        print(f"[DEBUG] [IconeInterativo] Caminho absoluto resolvido: '{caminho_absoluto}'")
        print(f"[DEBUG] [IconeInterativo] os.path.exists('{caminho}') = {existe}")
        print(f"[DEBUG] [IconeInterativo] os.path.isfile('{caminho}') = {eh_arquivo}")

        # --- Determinar se o carregamento pode prosseguir ---
        pixmap = None
        if not existe:
            print(
                f"‚ö†Ô∏è [IconeInterativo] O caminho '{caminho}' N√ÉO EXISTE. Diret√≥rio de execu√ß√£o pode estar incorreto. Usando placeholder.")
        elif not eh_arquivo:
            print(
                f"‚ö†Ô∏è [IconeInterativo] O caminho '{caminho}' EXISTE, mas N√ÉO √â um arquivo (pode ser um diret√≥rio). Usando placeholder.")
        else:
            # Caminho existe e √© um arquivo, tentar carregar com QPixmap
            print(f"[DEBUG] [IconeInterativo] Caminho v√°lido, tentando QPixmap('{caminho}')...")
            try:
                pixmap = QPixmap(caminho)

                # Verificar se o carregamento foi bem-sucedido
                if pixmap.isNull():
                    print(f"‚ö†Ô∏è [IconeInterativo] QPixmap falhou ao carregar o arquivo '{caminho}'. "
                          f"O arquivo pode estar corrompido ou n√£o ser uma imagem v√°lida. Usando placeholder.")
                    pixmap = None  # For√ßar uso do placeholder
                else:
                    print(
                        f"[DEBUG] [IconeInterativo] QPixmap carregou com sucesso. Tamanho original: {pixmap.width()}x{pixmap.height()}")

            except Exception as e:
                print(f"‚ùå [IconeInterativo] Erro inesperado ao carregar QPixmap de '{caminho}': {e}")
                import traceback
                traceback.print_exc()  # Imprime o stack trace completo
                pixmap = None  # For√ßar uso do placeholder

        # --- Criar pixmap final (carregada ou placeholder) ---
        if pixmap is None:
            # Criar um pixmap de placeholder se a imagem n√£o for carregada
            pixmap = QPixmap(self.tamanho[0], self.tamanho[1])
            pixmap.fill(Qt.GlobalColor.gray)  # Cor cinza para placeholder
            print(f"[DEBUG] [IconeInterativo] Placeholder cinza criado para '{self.identificador}'.")
        else:
            # Redimensionar a pixmap carregada para o tamanho desejado
            pixmap = pixmap.scaled(
                self.tamanho[0],
                self.tamanho[1],
                Qt.AspectRatioMode.KeepAspectRatio,
                Qt.TransformationMode.SmoothTransformation
            )
            print(
                f"[DEBUG] [IconeInterativo] Pixmap (carregada) redimensionada para {self.tamanho[0]}x{self.tamanho[1]}.")

        # --- Definir a pixmap (carregada ou placeholder) no QLabel ---
        self.setPixmap(pixmap)
        print(f"[DEBUG] [IconeInterativo] Pixmap definida para o √≠cone '{self.identificador}'.")

    def mousePressEvent(self, event):
        """Sobrescreve para emitir o sinal ao ser clicado."""
        if event.button() == Qt.MouseButton.LeftButton:
            print(f"üñ±Ô∏è √çcone '{self.identificador}' clicado.")
            self.clicado.emit(self.identificador)  # Emite o sinal com o identificador
        super().mousePressEvent(event)  # Chama o m√©todo da classe base


class GerenciadorIconesEsquerda(QWidget):
    """
    Widget que cont√©m e organiza os √≠cones interativos na barra esquerda.
    """
    icone_clicado = pyqtSignal(str)  # Re-emite o sinal dos √≠cones filhos

    def __init__(self, caminho_recursos="client/resources", parent=None):
        """
        :param caminho_recursos: Caminho para a pasta com os √≠cones PNG.
        :param parent: Widget pai.
        """
        super().__init__(parent)
        self.caminho_recursos = caminho_recursos
        self.icones = {}  # Dicion√°rio para armazenar refer√™ncias aos √≠cones {identificador: IconeInterativo}
        self.TAMANHO_ICONE = (48, 48)

        # Layout vertical para os √≠cones
        layout = QVBoxLayout(self)
        layout.setContentsMargins(10, 10, 10, 10)  # Margens internas
        layout.setSpacing(20)  # Espa√ßo entre os √≠cones
        layout.setAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft)

        # --- Criar e adicionar √≠cones ---
        # --- √çcone de Login com nome do usu√°rio ---
        icone_login_path = os.path.join(self.caminho_recursos, "log-in.png")
        self.icone_login = IconeInterativo(icone_login_path, "login", tamanho=self.TAMANHO_ICONE)
        self.icone_login.clicado.connect(self._ao_clicar_icone)

        # Layout horizontal para √≠cone + nome
        self.login_layout = QHBoxLayout()
        self.login_layout.setContentsMargins(0, 0, 0, 0)
        self.login_layout.setSpacing(8)
        self.login_layout.setAlignment(Qt.AlignmentFlag.AlignLeft)

        # Adicionar √≠cone
        self.login_layout.addWidget(self.icone_login)

        # Label para nome do usu√°rio
        self.label_nome_usuario = QLabel()
        self.label_nome_usuario.setStyleSheet("""
            color: #ecf0f1;
            background: transparent;
            border: none;
            font-size: 14px;
            font-weight: bold;
        """)
        self.label_nome_usuario.hide()
        self.login_layout.addWidget(self.label_nome_usuario)

        # Container final
        self.login_container = QWidget()
        self.login_container.setLayout(self.login_layout)

        # Adicionar ao layout principal
        layout.addWidget(self.login_container)

        # Refer√™ncia
        self.icones["login"] = self.icone_login

        # Criar um layout horizontal para o √≠cone + nome
        self.login_layout = QHBoxLayout()
        self.login_layout.setContentsMargins(0, 0, 0, 0)
        self.login_layout.setSpacing(8)  # Espa√ßo entre √≠cone e texto
        self.login_layout.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)

        # Adicionar √≠cone
        self.login_layout.addWidget(self.icone_login)

        # Adicionar label de nome (inicialmente oculto)
        self.label_nome_usuario = QLabel()
        self.label_nome_usuario.setStyleSheet("""
            color: #ecf0f1;
            background: transparent;
            border: none;
            font-family: Arial, sans-serif;
            font-size: 14px;
            font-weight: bold;
        """)
        self.label_nome_usuario.hide()  # Esconde por padr√£o
        self.login_layout.addWidget(self.label_nome_usuario)

        # Container widget para o layout horizontal
        self.login_container = QWidget()
        self.login_container.setLayout(self.login_layout)

        # Adicionar o container ao layout principal
        layout.addWidget(self.login_container)

        # Armazenar refer√™ncia
        self.icones["login"] = self.icone_login  # Mant√©m compatibilidade

        # √çcone de Play (Mais abaixo)
        icone_play_path = os.path.join(self.caminho_recursos, "play.png")
        self.icone_play = IconeInterativo(icone_play_path, "play", tamanho=self.TAMANHO_ICONE)
        self.icone_play.clicado.connect(self._ao_clicar_icone)
        layout.addWidget(self.icone_play)
        self.icones["play"] = self.icone_play

        # Espa√ßo el√°stico para empurrar o √≠cone de sair para baixo
        layout.addStretch()

        # √çcone de Sair (Inferior Esquerdo)
        icone_sair_path = os.path.join(self.caminho_recursos, "arrow-left.png")
        self.icone_sair = IconeInterativo(icone_sair_path, "sair", tamanho=self.TAMANHO_ICONE)
        self.icone_sair.clicado.connect(self._ao_clicar_icone)
        layout.addWidget(self.icone_sair)
        self.icones["sair"] = self.icone_sair

    def atualizar_estado_login(self, esta_logado: bool, nome_usuario: str = None):
        """Atualiza o √≠cone de login e mostra/esconde o nome do usu√°rio."""
        if esta_logado and nome_usuario:
            # Trocar √≠cone para o de usu√°rio logado
            caminho = os.path.join(self.caminho_recursos, "smile.png")
            self.icone_login.carregar_icone(caminho)
            # Mostrar e atualizar nome do usu√°rio
            self.label_nome_usuario.setText(nome_usuario)
            self.label_nome_usuario.show()  # ‚úÖ Garante que o label apare√ßa
        else:
            # Voltar para √≠cone de login
            caminho = os.path.join(self.caminho_recursos, "log-in.png")
            self.icone_login.carregar_icone(caminho)
            # Esconder nome do usu√°rio
            self.label_nome_usuario.hide()

    def _ao_clicar_icone(self, identificador):
        """Slot interno para reemitir o sinal do √≠cone clicado."""
        print(f"üì° GerenciadorIconesEsquerda: √çcone '{identificador}' acionado.")
        self.icone_clicado.emit(identificador)  # Re-emite o sinal para o consumidor (JanelaPrincipal)

    # M√©todos para atualizar √≠cones, se necess√°rio (ex: login/logout)
    def atualizar_icone(self, identificador, novo_caminho):
        """Atualiza a imagem de um √≠cone existente."""
        if identificador in self.icones:
            self.icones[identificador].carregar_icone(novo_caminho)
        else:
            print(f"‚ö†Ô∏è GerenciadorIconesEsquerda: √çcone '{identificador}' n√£o encontrado para atualizar.")

    def remover_status_sala(self):
        """Remove o widget de status da sala da barra lateral, se existir."""
        if hasattr(self, 'widget_status_sala') and self.widget_status_sala is not None:
            layout = self.container.layout()
            if layout is not None and self.widget_status_sala in layout:
                layout.removeWidget(self.widget_status_sala)
            self.widget_status_sala.deleteLater()
            self.widget_status_sala = None
            print("üóëÔ∏è Widget de status da sala removido da barra lateral.")

================================================================================
üìÑ shared/polygons.py
================================================================================
import math
import numpy

def dicionario_poligonos(fator):

    def icosaedro():
        
        def triangulo_original():
            
            def primeira_definicao_pontos():
                lista_pontos = []
                for x in range(fator ** 2):
                    if x % 2 == 0:
                        coord_x = x / 2 + 0.5
                        coord_y = math.sin(math.pi / 6)
                    else:
                        coord_x = x / 2 + 0.5
                        coord_y = math.sqrt(3) / 3
                    lista_pontos.append((round(coord_x, 15), round(coord_y, 15)))
                return lista_pontos
            
            def ponto_por_linha():
                lista_pontos = [0]
                ppf = fator * 2 - 1
                una = fator * 2 - 1
                while una != 1:
                    lista_pontos.append(ppf)
                    ppf += una - 2
                    una -= 2
                return lista_pontos

            def processar_coordenadas(coordenadas, indices):
                r = math.sqrt(3) / 3
                h = math.sqrt(0.75) * fator
                coords = []
                for i in range(len(indices)):
                    if i == len(indices) - 1:
                        segmento = [coordenadas[-1]]
                    else:
                        inicio, fim = indices[i], indices[i + 1]
                        segmento = coordenadas[inicio:fim]
                    for x in range(len(segmento)):
                        coefy = math.sin(math.pi / 6) * r
                        cx = (0.5 * i + 0.5 * x) + 0.5 - fator / 2
                        if x % 2 == 0:
                            cy = 0 + math.sqrt(0.75) * i + coefy - h / 2
                        else:
                            cy = r - coefy + math.sqrt(0.75) * i + coefy - h / 2
                        coords.append((cx, cy))
                return coords
            return processar_coordenadas(primeira_definicao_pontos(), ponto_por_linha())

        to = triangulo_original()

        def triangulos_equatoriais_em_pe():
            raio = fator / (2 * math.sin(math.pi / 5))
            apotema = fator / (2 * math.tan(math.pi / 5))
            theta = math.asin((raio - apotema) / fator)
            h = fator * math.sqrt(0.75)
            t1 = [(x, math.cos(theta) * y, math.sin(theta) * y) for x, y in to]
            t1 = [(x, y, z + apotema + math.sin(theta) * h / 2) for x, y, z in t1]
            return t1

        t1 = triangulos_equatoriais_em_pe()

        def rotacionar_em_torno_do_eixo_y(coordenadas, angulo_graus):
            angulo_radianos = math.radians(angulo_graus)
            cos_theta = math.cos(angulo_radianos)
            sin_theta = math.sin(angulo_radianos)
            coordenadas_rotacionadas = []
            for x, y, z in coordenadas:
                x_novo = cos_theta * x + sin_theta * z
                y_novo = y
                z_novo = -sin_theta * x + cos_theta * z
                coordenadas_rotacionadas.append((x_novo, y_novo, z_novo))
            return coordenadas_rotacionadas

        t2 = rotacionar_em_torno_do_eixo_y(t1, 72)
        t3 = rotacionar_em_torno_do_eixo_y(t1, 144)
        t4 = rotacionar_em_torno_do_eixo_y(t1, 216)
        t5 = rotacionar_em_torno_do_eixo_y(t1, 288)

        def triangulos_equatoriais_invertidos():
            raio = fator / (2 * math.sin(math.pi / 5))
            apotema = fator / (2 * math.tan(math.pi / 5))
            theta = math.asin((raio - apotema) / fator)
            h = fator * math.sqrt(0.75)
            t6 = [(x, -y) for x, y in to]
            t6 = [(x, math.cos(theta) * y, math.sin(theta) * -y) for x, y in t6]
            t6 = [(x, y, z + apotema + math.sin(theta) * h / 2) for x, y, z in t6]
            return t6

        tr = triangulos_equatoriais_invertidos()
        t6 = rotacionar_em_torno_do_eixo_y(tr, 36)
        t7 = rotacionar_em_torno_do_eixo_y(tr, 108)
        t8 = rotacionar_em_torno_do_eixo_y(tr, 180)
        t9 = rotacionar_em_torno_do_eixo_y(tr, 252)
        t10 = rotacionar_em_torno_do_eixo_y(tr, 324)

        def triangulos_polares_norte():
            alpha = math.acos(1 / (2 * math.tan(math.pi / 5) * math.sqrt(0.75)))
            apotema = fator / (2 * math.tan(math.pi / 5))
            h = fator * math.sqrt(0.75)
            deslocamento = apotema - math.cos(alpha) * h / 2
            raio = fator / (2 * math.sin(math.pi / 5))
            theta = math.asin((raio - apotema) / fator)
            deslocamento_vertical = (math.cos(theta) * h / 2) + (math.sin(alpha) * h / 2)
            tr = [(x, 0, -y) for x, y in to]
            tr = [(x, math.sin(alpha) * -z + deslocamento_vertical,
                z * math.cos(alpha) + deslocamento) for x, y, z in tr]
            return tr

        tr = triangulos_polares_norte()

        t11 = rotacionar_em_torno_do_eixo_y(tr, 36)
        t12 = rotacionar_em_torno_do_eixo_y(tr, 108)
        t13 = rotacionar_em_torno_do_eixo_y(tr, 180)
        t14 = rotacionar_em_torno_do_eixo_y(tr, 252)
        t15 = rotacionar_em_torno_do_eixo_y(tr, 324)

        def triangulos_polares_sul():
            alpha = math.acos(1 / (2 * math.tan(math.pi / 5) * math.sqrt(0.75)))
            apotema = fator / (2 * math.tan(math.pi / 5))
            h = fator * math.sqrt(0.75)
            deslocamento = apotema - math.cos(alpha) * h / 2
            raio = fator / (2 * math.sin(math.pi / 5))
            theta = math.asin((raio - apotema) / fator)
            deslocamento_vertical = (math.cos(theta) * h / 2) + (math.sin(alpha) * h / 2)
            t16 = [(x, 0, -y) for x, y in to]
            t16 = [(x, math.sin(alpha) * z - deslocamento_vertical,
                    z * math.cos(alpha) + deslocamento) for x, y, z in t16]
            return t16

        t16 = triangulos_polares_sul()
        t17 = rotacionar_em_torno_do_eixo_y(t16, 72)
        t18 = rotacionar_em_torno_do_eixo_y(t16, 144)
        t19 = rotacionar_em_torno_do_eixo_y(t16, 216)
        t20 = rotacionar_em_torno_do_eixo_y(t16, 288)
        return [t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20]

    def esfera(pontos, raio):

        def projetar_ponto_na_esfera(ponto, raio):
            x, y, z = ponto
            magnitude = math.sqrt(x**2 + y**2 + z**2)
            return (
                raio * x / magnitude,
                raio * y / magnitude,
                raio * z / magnitude
            )

        return [[projetar_ponto_na_esfera(ponto, raio) for ponto in lista] for lista in pontos]

    esfera = esfera(icosaedro(), fator)

    def poligonos():
        poligonos = []
        
        def ponto_por_linha():
            lista_pontos = [0]
            ppf = fator * 2 - 1
            una = fator * 2 - 1
            while una != 1:
                lista_pontos.append(ppf)
                ppf += una - 2
                una -= 2
            return lista_pontos

        p = ponto_por_linha()

        def hexagonos_centrais():
            hexagonos = []
            for t in esfera:
                i = 0
                for x in range(fator - 2, 0, -1):
                    for y in range(x):
                        hexagonos.append(numpy.array([
                            t[p[y] + i * 2 + 1],
                            t[p[y] + i * 2 + 2],
                            t[p[y] + i * 2 + 3],
                            t[p[y + 1] + i * 2 + 2],
                            t[p[y + 1] + i * 2 + 1],
                            t[p[y + 1] + i * 2]
                        ]))
                    i += 1
            return hexagonos

        poligonos.append(hexagonos_centrais())

        def hexagonos_tropicais_sul():
            hexagonos = []
            for x in range(5):
                for y in range(fator - 1):
                    hexagonos.append(numpy.array([
                        esfera[x][y * 2],
                        esfera[x][y * 2 + 1],
                        esfera[x][y * 2 + 2],
                        esfera[x + 15][y * 2 + 2],
                        esfera[x + 15][y * 2 + 1],
                        esfera[x + 15][y * 2]
                    ]))
            return hexagonos

        poligonos.append(hexagonos_tropicais_sul())

        def hexagonos_tropicais_norte():
            hexagonos = []
            for x in range(5, 10, 1):
                for y in range(fator - 1):
                    hexagonos.append(numpy.array([
                        esfera[x][y * 2],
                        esfera[x][y * 2 + 1],
                        esfera[x][y * 2 + 2],
                        esfera[x + 5][y * 2 + 2],
                        esfera[x + 5][y * 2 + 1],
                        esfera[x + 5][y * 2]
                    ]))
            return hexagonos

        poligonos.append(hexagonos_tropicais_norte())

        def hexagonos_equatoriais_ascendentes():
            hexagonos = []
            for x in range(5):
                for y in range(fator - 1):
                    if x == 0:
                        hexagonos.append(numpy.array([
                            esfera[x][p[y]],
                            esfera[x][p[y] + 1],
                            esfera[x][p[y + 1]],
                            esfera[x + 9][p[fator - y - 1] - 1],
                            esfera[x + 9][p[fator - y - 1] - 2],
                            esfera[x + 9][p[fator - y - 1] + 2 * y]
                        ]))
                    else:
                        hexagonos.append(numpy.array([
                            esfera[x][p[y]],
                            esfera[x][p[y] + 1],
                            esfera[x][p[y + 1]],
                            esfera[x + 4][p[fator - y - 1] - 1],
                            esfera[x + 4][p[fator - y - 1] - 2],
                            esfera[x + 4][p[fator - y - 1] + 2 * y]
                        ]))
            return hexagonos

        poligonos.append(hexagonos_equatoriais_ascendentes())

        def hexagonos_equatoriais_descendentes():
            hexagonos = []
            for x in range(5):
                for y in range(fator - 1):
                    hexagonos.append(numpy.array([
                        esfera[x][p[fator - 1 - y] + 2 * y],
                        esfera[x][p[fator - 1 - y] - 2],
                        esfera[x][p[fator - 1 - y] - 1],
                        esfera[x + 5][p[y + 1]],
                        esfera[x + 5][p[y] + 1],
                        esfera[x + 5][p[y]]
                    ]))
            return hexagonos

        poligonos.append(hexagonos_equatoriais_descendentes())

        def hexagonos_polares_norte():
            hexagonos = []
            for x in range(10, 15, 1):
                for y in range(fator - 1):
                    if x == 10:
                        hexagonos.append(numpy.array([
                            esfera[x][p[y]],
                            esfera[x][p[y] + 1],
                            esfera[x][p[y + 1]],
                            esfera[x + 4][p[y + 1] + (fator - y - 2) * 2],
                            esfera[x + 4][p[y + 1] - 2],
                            esfera[x + 4][p[y + 1] - 1]
                        ]))
                    else:
                        hexagonos.append(numpy.array([
                            esfera[x][p[y]],
                            esfera[x][p[y] + 1],
                            esfera[x][p[y + 1]],
                            esfera[x - 1][p[y + 1] + (fator - y - 2) * 2],
                            esfera[x - 1][p[y + 1] - 2],
                            esfera[x - 1][p[y + 1] - 1]
                        ]))
            return hexagonos

        poligonos.append(hexagonos_polares_norte())

        def hexagonos_polares_sul():
            hexagonos = []
            for x in range(15, 20):
                for y in range(fator - 1):
                    if x == 15:
                        hexagonos.append(numpy.array([
                            esfera[x][p[y]],
                            esfera[x][p[y] + 1],
                            esfera[x][p[y + 1]],
                            esfera[x + 4][p[y + 1] + (fator - y - 2) * 2],
                            esfera[x + 4][p[y + 1] - 2],
                            esfera[x + 4][p[y + 1] - 1]
                        ]))
                    else:
                        hexagonos.append(numpy.array([
                            esfera[x][p[y]],
                            esfera[x][p[y] + 1],
                            esfera[x][p[y + 1]],
                            esfera[x - 1][p[y + 1] + (fator - y - 2) * 2],
                            esfera[x - 1][p[y + 1] - 2],
                            esfera[x - 1][p[y + 1] - 1]
                        ]))
            return hexagonos

        poligonos.append(hexagonos_polares_sul())

        def pentagonos():

            pentagonos = []

            def pentagonos_tropicais_sul():
                pentagonos = []
                for x in range(5):
                    if x == 0:
                        pentagonos.append(numpy.array([
                            esfera[0][0],
                            esfera[9][p[fator - 1]],
                            esfera[4][p[1] - 1],
                            esfera[19][p[1] - 1],
                            esfera[15][0]
                        ]))
                    else:
                        pentagonos.append(numpy.array([
                            esfera[x][0],
                            esfera[x + 4][p[fator - 1]],
                            esfera[x - 1][p[1] - 1],
                            esfera[x + 14][p[1] - 1],
                            esfera[x + 15][0]
                        ]))
                return pentagonos

            pentagonos.extend(pentagonos_tropicais_sul())

            def pentagonos_tropicais_norte():
                pentagonos = []
                for x in range(5):
                    if x == 0:
                        pentagonos.append(numpy.array([
                            esfera[0][p[fator - 1]],
                            esfera[5][0],
                            esfera[10][0],
                            esfera[14][p[1] - 1],
                            esfera[9][p[1] - 1]
                        ]))
                    else:
                        pentagonos.append(numpy.array([
                            esfera[x][p[fator - 1]],
                            esfera[x + 5][0],
                            esfera[x + 10][0],
                            esfera[x + 9][p[1] - 1],
                            esfera[x + 4][p[1] - 1]
                        ]))
                return pentagonos

            pentagonos.extend(pentagonos_tropicais_norte())

            def pentagono_polo_norte():
                return numpy.array([
                    esfera[10][p[fator - 1]],
                    esfera[11][p[fator - 1]],
                    esfera[12][p[fator - 1]],
                    esfera[13][p[fator - 1]],
                    esfera[14][p[fator - 1]]
                ])

            pentagonos.append(pentagono_polo_norte())

            def pentagono_polo_sul():
                return numpy.array([
                    esfera[15][p[fator - 1]],
                    esfera[16][p[fator - 1]],
                    esfera[17][p[fator - 1]],
                    esfera[18][p[fator - 1]],
                    esfera[19][p[fator - 1]]
                ])

            pentagonos.append(pentagono_polo_sul())
            
            return pentagonos

        poligonos.append(pentagonos())

        return poligonos

    poligonos = poligonos()

    def dic_pol():
        coord_vert = {}
        h = 0
        for x in range(5):        
            for i, z in enumerate(range(fator - 2, 0, -1)):
                n = fator * 2 - 1
                for a in range(z):
                    coord_vert[(n - a, fator * x + i + 1)] = poligonos[0][h]
                    h += 1

        for x in range(5):
            for i, z in enumerate(range(fator - 2, 0, -1)):
                n = fator + 1
                for a in range(z):
                    coord_vert[(n + a, fator * x + 2 + i + a)] = poligonos[0][h]
                    h += 1

        for x in range(5):
            for i, z in enumerate(range(fator - 2, 0, -1)):
                n = fator - 1
                for a in range(z):
                    coord_vert[(n - a, fator * x + 1 - x * (a + 1) + i)] = poligonos[0][h]
                    h += 1

        for x in range(5):
            b = fator * x + 1 - x
            for i, z in enumerate(range(fator - 2, 0, -1)):
                n = fator * 2 + 1
                for a in range(z):
                    coord_vert[(n + a, b + i - a * x)] = poligonos[0][h]
                    h += 1
        h = 0
        for x in range(5):
            for z in range(fator - 1):
                coord_vert[(fator * 2, fator * x + z + 1)] = poligonos[1][h]
                h += 1
        h = 0
        for x in range(5):
            for z in range(fator - 1):
                coord_vert[(fator, fator * x + z + 1)] = poligonos[2][h]
                h += 1
        h = 0
        for x in range(5):
            for z in range(fator - 1):
                coord_vert[(fator * 2 - z - 1, fator * x)] = poligonos[3][h]
                h += 1
        h = 0
        for x in range(5):
            for z in range(fator - 1):
                coord_vert[(fator + z + 1, fator * x + z + 1)] = poligonos[4][h]
                h += 1
        h = 0
        for x in range(5):
            for z in range(fator - 1):
                coord_vert[(fator - z - 1, (fator - z - 1) * x)] = poligonos[5][h]
                h += 1
        h = 0
        for x in range(5):
            for i, z in enumerate(range(fator - 1, 0, -1)):
                coord_vert[(fator * 2 + i + 1, z * x)] = poligonos[6][h]
                h += 1
        h = 0
        for x in range(5):
            coord_vert[(fator * 2, fator * x)] = poligonos[7][h]
            h += 1
        for x in range(5):
            coord_vert[(fator, fator * x)] = poligonos[7][h]
            h += 1
        coord_vert[(0, 0)] = poligonos[7][h]
        h += 1
        coord_vert[(fator * 3, 0)] = poligonos[7][h]

        return coord_vert
    
    return dic_pol()

================================================================================
üìÑ shared/planet.py
================================================================================
import random
from shared.polygons import dicionario_poligonos
from shared.geography import definir_geografia

class Planeta:
    def __init__(self, fator, bioma):
        self.fator = fator
        self.bioma_inicial = bioma
        self.geografia, self.capitais_players = definir_geografia(dicionario_poligonos(fator), fator, bioma) # capitais = [(int, int), ...]
        random.shuffle(self.capitais_players)
        self.numero_de_jogadores = len(self.capitais_players)
        biomas_invalidos = {"Ice", "Sea", "Ocean", "Coast", bioma}
        capitais_player_set = set(self.capitais_players)
        nodos_validos = [
            n for n in self.geografia.nodes()
            if self.geografia.nodes[n]["bioma"] not in biomas_invalidos and n not in capitais_player_set
        ]
        npn = 27 - len(self.capitais_players)  # Lembrar de evitar npn (pa√≠ses neutros) negativo
        self.capitais_neutros = random.sample(nodos_validos, npn)
        random.shuffle(self.capitais_neutros)
        self.civilizacoes = []


================================================================================
üìÑ shared/geography.py
================================================================================
import networkx
import random
import math
from statistics import mean
from random import choice

# CUSTOS BASE
CUSTOS_BASE = {
    'Ice': 20.0,
    'Mountains': 12.0,
    'Hills': 6.0,
    'Forest': 4.0,
    'Meadow': 3.0,
    'Savanna': 4.0,
    'Desert': 5.0,
    'Coast': 0.8,
    'Sea': 0.6,
    'Ocean': 0.4
}

PENALIDADE_TRANSICAO = 15.0

def letra_grega(placa):
    letras_gregas_dict = {
        "Alpha": "Œë", "Beta": "Œí", "Gamma": "Œì", "Delta": "Œî",
        "Epsilon": "Œï", "Zeta": "Œñ", "Eta": "Œó", "Theta": "Œò",
        "Iota": "Œô", "Kappa": "Œö", "Lambda": "Œõ", "Mu": "Œú",
        "Nu": "Œù", "Xi": "Œû", "Omicron": "Œü", "Pi": "Œ†",
        "Rho": "Œ°", "Sigma": "Œ£", "Tau": "Œ§", "Upsilon": "Œ•",
        "Phi": "Œ¶", "Chi": "Œß", "Psi": "Œ®", "Omega": "Œ©"
    }
    return letras_gregas_dict.get(placa)

def definir_geografia(poligonos, fator, bioma):

    geografia = networkx.DiGraph()

    for coordenadas in poligonos:
        geografia.add_node(coordenadas)

    def tipo_de_poligono(c):
        if c == (0, 0):
            geografia.nodes[c]['tipo'] = 'pn'
            return "pn"
        elif 0 < c[0] < fator and c[1] % c[0] == 0:
            geografia.nodes[c]['tipo'] = 'ipn'
            return "ipn"
        elif 0 < c[0] < fator and c[1] % c[0] != 0:
            geografia.nodes[c]['tipo'] = 'cpn'
            return "cpn"
        elif c[0] == fator and c[1] % c[0] == 0:
            geografia.nodes[c]['tipo'] = 'ntn'
            return "ntn"
        elif c[0] == fator and c[1] % c[0] != 0:
            geografia.nodes[c]['tipo'] = 'itn'
            return "itn"
        elif fator < c[0] < fator * 2:
            geografia.nodes[c]['tipo'] = 'e'
            return "e"
        elif c[0] == fator * 2 and c[1] % fator != 0:
            geografia.nodes[c]['tipo'] = 'its'
            return "its"
        elif c[0] == fator * 2 and c[1] % fator == 0:
            geografia.nodes[c]['tipo'] = 'nts'
            return "nts"
        elif fator * 2 < c[0] < fator * 3 and c[1] % (fator * 3 - c[0]) != 0:
            geografia.nodes[c]['tipo'] = 'cps'
            return "cps"
        elif fator * 2 < c[0] < fator * 3 and c[1] % (fator * 3 - c[0]) == 0:
            geografia.nodes[c]['tipo'] = 'ips'
            return "ips"
        elif c[0] == fator * 3:
            geografia.nodes[c]['tipo'] = 'ps'
            return "ps"

    for n in list(geografia.nodes):
        no = tipo_de_poligono(n)
        if no == "pn":
            for y in range(5):
                geografia.add_edge(n, (1, y), direcao=f'S{y+1}')
            continue
        if no == "ps":
            for y in range(5):
                geografia.add_edge(n, (fator * 3 - 1, y), direcao=f'N{y+1}')
            continue
        x = n[1] // n[0]
        y = n[1] // (fator * 3 - n[0])
        if no == "ipn":
            if n[1] != n[0] * 5 - 1:
                geografia.add_edge(n, (n[0] + 1, n[1] + x), direcao='S')
                geografia.add_edge(n, (n[0] + 1, n[1] + x + 1), direcao='SE')
                geografia.add_edge(n, (n[0], n[1] + 1), direcao='E')
                geografia.add_edge(n, (n[0] - 1, n[1] - x), direcao='N')
                geografia.add_edge(n, (n[0], n[1] - 1), direcao='W') if n[1] != 0 else geografia.add_edge(n, (n[0], n[0] * 5 - 1), direcao='W')
                geografia.add_edge(n, (n[0] + 1, n[1] + x - 1), direcao='SW') if n[1] != 0 else \
                                        geografia.add_edge(n, (n[0] + 1, (n[0] + 1) * 5 - 1), direcao='SW')
            else:
                geografia.add_edge(n, (n[0] + 1, n[1] + x), direcao='S')
                geografia.add_edge(n, (n[0] + 1, n[1] + x + 1), direcao='SE')
                geografia.add_edge(n, (n[0], 0), direcao='E')
                geografia.add_edge(n, (n[0] - 1, n[1] - x), direcao='N')
                geografia.add_edge(n, (n[0], n[1] - 1), direcao='W')
                geografia.add_edge(n, (n[0] + 1, n[1] + x - 1), direcao='SW')
        elif no == "cpn":
            if n[1] != n[0] * 5 - 1:
                geografia.add_edge(n, (n[0] + 1, n[1] + x + 1), direcao='SE')
                geografia.add_edge(n, (n[0], n[1] + 1), direcao='E')
                geografia.add_edge(n, (n[0] - 1, n[1] - x), direcao='NE')
                geografia.add_edge(n, (n[0] - 1, n[1] - x - 1), direcao='NW')
                geografia.add_edge(n, (n[0], n[1] - 1), direcao='W')
                geografia.add_edge(n, (n[0] + 1, n[1] + x), direcao='SW')
            else:
                geografia.add_edge(n, (n[0] + 1, n[1] + x + 1), direcao='SE')
                geografia.add_edge(n, (n[0], 0), direcao='E')
                geografia.add_edge(n, (n[0] - 1, 0), direcao='NE')
                geografia.add_edge(n, (n[0] - 1, n[1] - x - 1), direcao='NW')
                geografia.add_edge(n, (n[0], n[1] - 1), direcao='W')
                geografia.add_edge(n, (n[0] + 1, n[1] + x), direcao='SW')
        elif no == "ntn":
            geografia.add_edge(n, (n[0] + 1, n[1]), direcao='SW')
            geografia.add_edge(n, (n[0] + 1, n[1] + 1), direcao='SE')
            geografia.add_edge(n, (n[0], n[1] + 1), direcao='NE')
            geografia.add_edge(n, (n[0] - 1, n[1] - x), direcao='N')
            geografia.add_edge(n, (n[0], n[1] - 1), direcao='NW') if n[1] != 0 else geografia.add_edge(n, (n[0], n[0] * 5 - 1), direcao='NW')
        elif no == "itn":
            if n[1] != fator * 5 - 1:
                geografia.add_edge(n, (n[0] + 1, n[1]), direcao='SW')
                geografia.add_edge(n, (n[0] + 1, n[1] + 1), direcao='NE')
                geografia.add_edge(n, (n[0], n[1] + 1), direcao='E')
                geografia.add_edge(n, (n[0] - 1, n[1] - x), direcao='NE')
                geografia.add_edge(n, (n[0] - 1, n[1] - x - 1), direcao='NW')
                geografia.add_edge(n, (n[0], n[1] - 1), direcao='W')
            else:
                geografia.add_edge(n, (n[0] + 1, n[1]), direcao='SW')
                geografia.add_edge(n, (n[0] + 1, 0), direcao='NE')
                geografia.add_edge(n, (n[0], 0), direcao='E')
                geografia.add_edge(n, (n[0] - 1, 0), direcao='NE')
                geografia.add_edge(n, (n[0] - 1, n[1] - x - 1), direcao='NW')
                geografia.add_edge(n, (n[0], n[1] - 1), direcao='W')
        elif no == "e":
            if n[1] != fator * 5 - 1:
                geografia.add_edge(n, (n[0] + 1, n[1]), direcao='SW')
                geografia.add_edge(n, (n[0] + 1, n[1] + 1), direcao='SE')
                geografia.add_edge(n, (n[0], n[1] + 1), direcao='E')
                geografia.add_edge(n, (n[0] - 1, n[1]), direcao='NE')
                geografia.add_edge(n, (n[0] - 1, n[1] - 1), direcao='NW') if n[1] != 0 else geografia.add_edge(n, (n[0] - 1, fator * 5 - 1), direcao='NW')
                geografia.add_edge(n, (n[0], n[1] - 1), direcao='W') if n[1] != 0 else geografia.add_edge(n, (n[0], fator * 5 - 1), direcao='W')
            else:
                geografia.add_edge(n, (n[0] + 1, n[1]), direcao='SW')
                geografia.add_edge(n, (n[0] + 1, 0), direcao='SE')
                geografia.add_edge(n, (n[0], 0), direcao='E')
                geografia.add_edge(n, (n[0] - 1, n[1]), direcao='NE')
                geografia.add_edge(n, (n[0] - 1, n[1] - 1), direcao='NW')
                geografia.add_edge(n, (n[0], n[1] - 1), direcao='W')
        elif no == "its":
            if n[1] != fator * 5 - 1:
                geografia.add_edge(n, (n[0] + 1, n[1] - y), direcao='SE')
                geografia.add_edge(n, (n[0], n[1] + 1), direcao='E')
                geografia.add_edge(n, (n[0] - 1, n[1]), direcao='NE')
                geografia.add_edge(n, (n[0] - 1, n[1] - 1), direcao='NW')
                geografia.add_edge(n, (n[0], n[1] - 1), direcao='W')
                geografia.add_edge(n, (n[0] + 1, n[1] - y - 1), direcao='SW')
            else:
                geografia.add_edge(n, (n[0] + 1, 0), direcao='SE')
                geografia.add_edge(n, (n[0], 0), direcao='E')
                geografia.add_edge(n, (n[0] - 1, n[1]), direcao='NE')
                geografia.add_edge(n, (n[0] - 1, n[1] - 1), direcao='NW')
                geografia.add_edge(n, (n[0], n[1] - 1), direcao='W')
                geografia.add_edge(n, (n[0] + 1, n[1] - y - 1), direcao='SW')
        elif no == "nts":
            geografia.add_edge(n, (n[0] + 1, n[1] - y), direcao='S')
            geografia.add_edge(n, (n[0], n[1] + 1), direcao='SE')
            geografia.add_edge(n, (n[0] - 1, n[1]), direcao='NE')
            geografia.add_edge(n, (n[0] - 1, n[1] - 1), direcao='NW') if n[1] != 0 else geografia.add_edge(n, (n[0] - 1, fator * 5 - 1), direcao='NW')
            geografia.add_edge(n, (n[0], n[1] - 1), direcao='SW') if n[1] != 0 else geografia.add_edge(n, (n[0], fator * 5 - 1), direcao='SW')
        elif no == "cps":
            if n[1] != (fator * 3 - n[0]) * 5 - 1:
                geografia.add_edge(n, (n[0] + 1, n[1] - y), direcao='SE')
                geografia.add_edge(n, (n[0], n[1] + 1), direcao='E')
                geografia.add_edge(n, (n[0] - 1, n[1] + y + 1), direcao='NE')
                geografia.add_edge(n, (n[0] - 1, n[1] + y), direcao='NW')
                geografia.add_edge(n, (n[0], n[1] - 1), direcao='W')
                geografia.add_edge(n, (n[0] + 1, n[1] - y - 1), direcao='SW')
            else:
                geografia.add_edge(n, (n[0] + 1, 0), direcao='SE')
                geografia.add_edge(n, (n[0], 0), direcao='E')
                geografia.add_edge(n, (n[0] - 1, n[1] + y + 1), direcao='NE')
                geografia.add_edge(n, (n[0] - 1, n[1] + y), direcao='NW')
                geografia.add_edge(n, (n[0], n[1] - 1), direcao='W')
                geografia.add_edge(n, (n[0] + 1, n[1] - y - 1), direcao='SW')
        elif no == "ips":
            if n[1] != (fator * 3 - n[0]) * 5 - 1:
                geografia.add_edge(n, (n[0] + 1, n[1] - y), direcao='S')
                geografia.add_edge(n, (n[0], n[1] + 1), direcao='SE')
                geografia.add_edge(n, (n[0] - 1, n[1] + y + 1), direcao='NE')
                geografia.add_edge(n, (n[0] - 1, n[1] + y), direcao='N')
                geografia.add_edge(n, (n[0] - 1, n[1] + y - 1), direcao='NW') if n[1] != 0 else \
                                        geografia.add_edge(n, (n[0] - 1, (fator * 3 - n[0] + 1) * 5 - 1), direcao='NW')
                geografia.add_edge(n, (n[0], n[1] - 1), direcao='SW') if n[1] != 0 else \
                                        geografia.add_edge(n, (n[0], (fator * 3 - n[0]) * 5 - 1), direcao='SW')
            else:
                geografia.add_edge(n, (n[0] + 1, n[1] - y), direcao='S')
                geografia.add_edge(n, (n[0], 0), direcao='SE')
                geografia.add_edge(n, (n[0] - 1, n[1] + y + 1), direcao='NE')
                geografia.add_edge(n, (n[0] - 1, n[1] + y), direcao='N')
                geografia.add_edge(n, (n[0] - 1, n[1] + y - 1), direcao='NW')
                geografia.add_edge(n, (n[0], n[1] - 1), direcao='SW')

    areas = list(poligonos.keys())
    areas_sem_definicao = {}
    areas_definidas = {}
    referencias_relevo = random.sample(areas, fator * 20)

    for area in areas:
        areas_sem_definicao[area] = []
        areas_definidas[area] = []

    for n in range(fator * 3 // 2):
        if not areas_sem_definicao:
            break
        for node in referencias_relevo:
            altitude = random.randint(0, 12)
            areas_definidas[node].append(altitude)
            if node in areas_sem_definicao:
                del areas_sem_definicao[node]
            distancias = networkx.single_source_shortest_path_length(geografia, node)
            nos_a_n_arestas = [node for node, distance in distancias.items() if distance == n + 1]
            for neighbor in nos_a_n_arestas:
                if neighbor in areas_sem_definicao and neighbor not in referencias_relevo:
                    areas_sem_definicao[neighbor].append(altitude)
        for chave in list(areas_sem_definicao.keys()):
            if areas_sem_definicao[chave]:
                areas_definidas[chave].append(round(mean(areas_sem_definicao[chave]), 3))
                del areas_sem_definicao[chave]

    chaves = list(areas_definidas.keys())
    random.shuffle(chaves)
    chaves_ordenadas = sorted(chaves, key=lambda chave: areas_definidas[chave])
    percentual_terra = random.randint(35, 45)
    limite_abissal = (100 - percentual_terra) // 2
    limite_barreira = limite_abissal + (100 - percentual_terra) // 3
    nivel_do_mar = 100 - percentual_terra
    limite_planicie = nivel_do_mar + (100 - nivel_do_mar) * 4 // 6
    limite_planalto = limite_planicie + (100 - limite_planicie) // 2

    for i, chave in enumerate(chaves_ordenadas):
        if i <= len(chaves_ordenadas) * limite_abissal // 100:
            geografia.nodes[chave]['altitude'] = 'abissal'
        elif i <= len(chaves_ordenadas) * limite_barreira // 100:
            geografia.nodes[chave]['altitude'] = 'barreira'
        elif i <= len(chaves_ordenadas) * nivel_do_mar // 100:
            geografia.nodes[chave]['altitude'] = 'plataforma'
        elif i <= len(chaves_ordenadas) * limite_planicie // 100:
            geografia.nodes[chave]['altitude'] = 'planicie'
        elif i <= len(chaves_ordenadas) * limite_planalto // 100:
            geografia.nodes[chave]['altitude'] = 'planalto'
        else:
            geografia.nodes[chave]['altitude'] = 'cordilheira'

    areas_sem_definicao = {}
    areas_definidas = {}
    referencias_umidade = random.sample(areas, 60)

    for area in areas:
        areas_sem_definicao[area] = []
        areas_definidas[area] = []

    for n in range(fator * 3 // 2):
        if not areas_sem_definicao:
            break
        for node in referencias_umidade:
            altitude = random.randint(0, 12)
            areas_definidas[node].append(altitude)
            if node in areas_sem_definicao:
                del areas_sem_definicao[node]
            distancias = networkx.single_source_shortest_path_length(geografia, node)
            nos_a_n_arestas = [node for node, distance in distancias.items() if distance == n + 1]
            for neighbor in nos_a_n_arestas:
                if neighbor in areas_sem_definicao and neighbor not in referencias_umidade:
                    areas_sem_definicao[neighbor].append(altitude)
        for chave in list(areas_sem_definicao.keys()):
            if areas_sem_definicao[chave]:
                areas_definidas[chave].append(round(mean(areas_sem_definicao[chave]), 3))
                del areas_sem_definicao[chave]

    chaves = list(areas_definidas.keys())
    random.shuffle(chaves)
    chaves_ordenadas = sorted(chaves, key=lambda chave: areas_definidas[chave])

    for i, chave in enumerate(chaves_ordenadas):
        if i <= len(chaves_ordenadas) * 25 // 100:
            geografia.nodes[chave]['umidade'] = 'arido'
        elif i <= len(chaves_ordenadas) * 50 // 100:
            geografia.nodes[chave]['umidade'] = 'semi-arido'
        elif i <= len(chaves_ordenadas) * 75 // 100:
            geografia.nodes[chave]['umidade'] = 'fertil'
        else:
            geografia.nodes[chave]['umidade'] = 'umido'

    # Defini√ß√£o das placas com dois pontos de refer√™ncia cada
    placas = ['Alpha', 'Beta', 'Gamma', 'Delta', 'Epsilon', 'Zeta',
            'Eta', 'Theta', 'Iota', 'Kappa', 'Lambda', 'Mu',
            'Nu', 'Xi', 'Omicron', 'Pi', 'Rho', 'Sigma',
            'Tau', 'Upsilon', 'Phi', 'Chi', 'Psi', 'Omega']
    
    # Gerar duas refer√™ncias para cada placa (total 48)
    placas_duplicadas = placas * 2
    random.shuffle(placas_duplicadas)
    referencias_geologia = random.sample(areas, 48)

    # Atribuir cada refer√™ncia a uma placa
    areas_definidas = {area: None for area in areas}
    for i, node in enumerate(referencias_geologia):
        areas_definidas[node] = placas_duplicadas[i]

    # Calcular a placa para cada n√≥ baseado na proximidade
    for node in areas_definidas:
        if areas_definidas[node] is not None:
            continue  # Pula pontos de refer√™ncia j√° definidos
        
        # Encontrar todas as dist√¢ncias para pontos de refer√™ncia
        distancias = []
        for ref in referencias_geologia:
            try:
                dist = networkx.shortest_path_length(geografia, ref, node)
                distancias.append( (ref, dist) )
            except networkx.exception.NetworkXNoPath:
                continue
        
        if not distancias:
            areas_definidas[node] = random.choice(placas)
            continue
        
        # Encontrar a dist√¢ncia m√≠nima
        min_dist = min(d[1] for d in distancias)
        candidatos = [d[0] for d in distancias if d[1] == min_dist]
        
        # Escolher aleatoriamente entre candidatos equidistantes
        ref_escolhida = random.choice(candidatos)
        areas_definidas[node] = areas_definidas[ref_escolhida]
    
    coeficiente_movimento = 300

    # Gerar cores para as placas
    cores_placas = []
    for _ in range(24):
        while True:
            r = random.randint(0, 255)
            g = random.randint(0, 255)
            b = random.randint(0, 255)
            if (r + g + b) > 127.5:
                cores_placas.append((r, g, b))
                break

    latitude_equador = fator * 3 / 2

    for chave, valor in areas_definidas.items():
        geografia.nodes[chave]['placa'] = valor
        geografia.nodes[chave]['cor_placa'] = cores_placas[placas.index(valor)]
        geografia.nodes[chave]['letra_grega'] = letra_grega(geografia.nodes[chave]['placa'])
        if chave[0] < latitude_equador:
            distancia_para_equador = latitude_equador - chave[0]
            angulo = distancia_para_equador * 90 / latitude_equador
            incidencia_solar = math.cos(math.radians(angulo))
        elif chave[0] == latitude_equador:
            distancia_para_equador = 0
            angulo = distancia_para_equador * 90 / latitude_equador
            incidencia_solar = math.cos(math.radians(angulo))
        else:
            distancia_para_equador = chave[0] - latitude_equador
            angulo = distancia_para_equador * 90 / latitude_equador
            incidencia_solar = math.cos(math.radians(angulo))
        if geografia.nodes[chave]['altitude'] == 'abissal' \
        or geografia.nodes[chave]['altitude'] == 'barreira' \
        or geografia.nodes[chave]['altitude'] == 'plataforma':
            fator_altitude = 3
        elif geografia.nodes[chave]['altitude'] == 'planicie':
            fator_altitude = 1
        elif geografia.nodes[chave]['altitude'] == 'planalto':
            fator_altitude = -1
        elif geografia.nodes[chave]['altitude'] == 'cordilheira':
            fator_altitude = -3
        if geografia.nodes[chave]['umidade'] == 'umido':
            fator_umidade = 1.5
        elif geografia.nodes[chave]['umidade'] == 'fertil':
            fator_umidade = 0.5
        elif geografia.nodes[chave]['umidade'] == 'semi-arido':
            fator_umidade = -0.5
        elif geografia.nodes[chave]['umidade'] == 'arido':
            fator_umidade = -1.5
        geografia.nodes[chave]['temperatura'] = round(40 * incidencia_solar - 8 + fator_altitude + fator_umidade, 1) - 4

    for node, atributos in geografia.nodes(data=True):
        temperatura = atributos.get('temperatura')
        altitude = atributos.get('altitude')
        umidade = atributos.get('umidade')
        
        if temperatura < 0:
            atributos['bioma'] = 'Ice'
        else:
            if altitude == 'cordilheira':
                atributos['bioma'] = 'Mountains'
            elif altitude == 'planalto':
                atributos['bioma'] = 'Hills'
            elif altitude == 'planicie':
                if umidade == 'umido':
                    atributos['bioma'] = 'Forest'
                elif umidade == 'fertil':
                    atributos['bioma'] = 'Meadow'
                elif umidade == 'semi-arido':
                    atributos['bioma'] = 'Savanna'
                else:
                    atributos['bioma'] = 'Desert'
            elif altitude == 'plataforma':
                atributos['bioma'] = 'Coast'
            elif altitude == 'barreira':
                atributos['bioma'] = 'Sea'
            else:
                atributos['bioma'] = 'Ocean'
        
        # Aplica custo base diretamente do dicion√°rio
        atributos['cust_mob'] = CUSTOS_BASE[atributos['bioma']] * coeficiente_movimento

    for u, v in geografia.edges():
        mob_u = geografia.nodes[u]['cust_mob']
        mob_v = geografia.nodes[v]['cust_mob']
        
        u_maritimo = geografia.nodes[u]['bioma'] in ['Coast', 'Sea', 'Ocean']
        v_maritimo = geografia.nodes[v]['bioma'] in ['Coast', 'Sea', 'Ocean']
        
        if u_maritimo != v_maritimo:  # Transi√ß√£o terra-mar
            geografia[u][v]['cust_mob'] = max(mob_u, mob_v) * 2 + PENALIDADE_TRANSICAO * coeficiente_movimento
        else:
            geografia[u][v]['cust_mob'] = (mob_u + mob_v) / 2

        # B√¥nus para rotas oce√¢nicas longas
        if u_maritimo and v_maritimo:
            geografia[u][v]['cust_mob'] *= 0.7

    cores_biomas = {
        'Ocean': (0, 23, 98), 'Sea': (8, 33, 113), 'Coast': (12, 71, 108), 'Meadow': (91, 174, 70), 'Savanna': (231, 190, 141),
        'Forest': (75, 129, 66), 'Desert': (242, 242, 166), 'Hills': (201, 147, 121), 'Mountains': (158, 86, 86), 'Ice': (245, 255, 245)
    }

    bioma_escolhido = []

    for node in geografia.nodes:
        geografia.nodes[node]['cor_bioma'] = cores_biomas[geografia.nodes[node]['bioma']]
        if geografia.nodes[node]['bioma'] == f'{bioma}':
            bioma_escolhido.append(node)

    bioma_escolhido = [n for n, attr in geografia.nodes(data=True) if attr['bioma'] == f'{bioma}']
    lista_capitais = [choice(bioma_escolhido)]
    while len(lista_capitais) < len(bioma_escolhido) // 2:
        d2 = {}
        for candidato in bioma_escolhido:
            if candidato in lista_capitais:
                continue
            d = {}
            for capital in lista_capitais:
                d[capital] = networkx.shortest_path_length(geografia, source=candidato, target=capital, weight='custo_mobilidade')
            d2[candidato] = min(d.values())
        if not d2:  # Se n√£o houver candidatos poss√≠veis, o planeta n√£o comporta a quantidade desejada
            print("d2 vazio")
            raise ValueError("O planeta n√£o comporta essa quantidade de civiliza√ß√µes!")
        maior_valor = max(d2.values())
        chaves_maior_valor = [chave for chave, valor in d2.items() if valor == maior_valor]
        lista_capitais.append(choice(chaves_maior_valor))

    print(f"n√∫mero de {bioma}:", len(bioma_escolhido))
    return geografia, lista_capitais


================================================================================
üìÑ shared/civilization.py
================================================================================
import random
from shared.flags import bandeira

class Civilizacao:
    def __init__(self, ref, indice, nome, player=False, ponto_inicial=None):
        self.player = player
        self.nome = nome
        self.cultura = ref.culturas[indice % len(ref.culturas)]
        self.cor = ref.civs_cores[self.nome]
        self.modalidade_bandeira = random.randint(0, 82)
        self.cores_bandeira = bandeira(self.nome, self.modalidade_bandeira)
        self.ponto_inicial = ponto_inicial
        self.provincias = []
        self.unidades = []

================================================================================
üìÑ shared/province.py
================================================================================
from shared.naming import formar_nome

class Provincia:
    def __init__(self, civilizacao, coordenadas):
        self.civilizacao = civilizacao
        self.coordenadas = coordenadas
        self.nome = formar_nome(civilizacao.cultura)

================================================================================
üìÑ shared/world.py
================================================================================
# shared/world.py
import random
from uuid import uuid4
from shared.references import Referencias
from shared.planet import Planeta
from shared.civilization import Civilizacao
from shared.province import Provincia


class Mundo:
    def __init__(self, fator=4, bioma='Meadow', id_mundo=None):
        self.id_mundo = id_mundo or str(uuid4())
        ref = Referencias()
        random.shuffle(ref.culturas)
        lista_de_cores = list(ref.civs_cores.keys())
        random.shuffle(lista_de_cores)
        self.planeta = Planeta(fator=fator, bioma=bioma)
        self.civs = []

        # Criar civiliza√ß√µes com capitais corretas
        for i, capital in enumerate(self.planeta.capitais_players):
            nome = lista_de_cores[i % len(lista_de_cores)]
            civ = Civilizacao(ref, i, nome, True, capital)
            self.civs.append(civ)

        for i, capital in enumerate(self.planeta.capitais_neutros):
            indice = i + len(self.planeta.capitais_players)
            nome = lista_de_cores[indice % len(lista_de_cores)]
            civ = Civilizacao(ref, indice, nome, False, capital)
            self.civs.append(civ)

        # Atribuir prov√≠ncia inicial usando o ponto_inicial de cada civ
        for civ in self.civs:
            provincia = Provincia(civ, civ.ponto_inicial)
            civ.provincias.append(provincia)

================================================================================
üìÑ shared/references.py
================================================================================
class Referencias:
    def __init__(self):
        self.culturas = [
            'English', 'Chinese', 'Spanish',
            'French', 'Indian', 'Russian',
            'Vietnamese', 'Turkish', 'Arabic',
            'Indonesian', 'Persian', 'Hausa',
            'Swahili', 'Portuguese', 'Telugu',
            'Bengali', 'Japanese', 'Marathi',
            'Wu', 'Yue', 'Min',
            'Korean', 'Italian', 'German'
        ]
        self.civs_cores = {
            'Black': (16, 16, 16), 'Midnight Blue': (0, 0, 127), 'Blue': (0, 0, 255),
            'Dark Green': (0, 127, 0), 'Teal': (0, 127, 127), 'Sky Blue': (32, 127, 223),
            'Green': (0, 255, 0), 'Spring Green': (0, 255, 127), 'Cyan': (0, 223, 223),
            'Maroon': (127, 0, 0), 'Purple': (127, 0, 127), 'Violet': (127, 0, 255),
            'Olive': (127, 127, 0), 'Gray': (127, 127, 127), 'Lavender': (127, 127, 255),
            'Chartreuse': (127, 255, 0), 'Light Green': (127, 223, 127), 'Pale Cyan': (127, 255, 255),
            'Red': (234, 33, 37), 'Rose': (255, 0, 127), 'Magenta': (255, 0, 255),
            'Orange': (223, 127, 32), 'Salmon': (255, 127, 127), 'Orchid': (255, 127, 255),
            'Yellow': (255, 255, 0), 'Light Yellow': (255, 255, 127), 'White': (250, 255, 253)
        }

        self.tons_de_pele = [(245, 212, 205), (212, 160, 147), (163, 106, 95), (101, 61, 53)]
        self.tons_de_cabelo = [(209, 195, 2), (140, 106, 0), (99, 55, 26), (52, 48, 47)]

================================================================================
‚úÖ Total de 33 arquivos inclu√≠dos.
================================================================================